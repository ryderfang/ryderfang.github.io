---
title: "全排列算法"
date: 2022-05-21T13:20:37+08:00
categories: [Permutations]
tags: []
---

> A permutation is an act of arranging the objects or numbers in order. Combinations are the way of selecting the objects or numbers from a group of objects or collection, in such a way that the order of the objects does not matter.

排列组合是组合/离散数学中的基础和重要的概念。

{{< katex >}}

$$
  P_n^m = A_n^m = n(n-1)(n-2)...(n-m+1) = \frac {n!}{(n-m)!}
$$

当 \\(n = m\\) 时，也就是全排列：

\\(P_n = n(n-1)(n-2)...3 \times 2 \times 1 = n!\\)

默认是不放回排列，如果是重复排列，那么排列数就是 \\(n^m\\)

哈哈，跑偏了，这篇不是要演示 [KaTex 的用法](https://katex.org/docs/supported.html) （虽然确实挺有意思的 😹）

## 排列算法

* [46. Permutations](https://leetcode.com/problems/permutations/)
* [31. Next Permutation](https://leetcode.com/problems/next-permutation/)
* [47. Permutations II](https://leetcode.com/problems/permutations-ii/)
* [60. Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)

我们知道排列数是阶乘级增长，10个数的排列就达到了 \\(10! = 3628800\\)，百万级的规模。

所以，即使我们 `O(1)` 生成一个排列，那生成全排列的算法复杂度也是 `O(n!)`，非常恐怖。

在 wiki[^1] 上有一个有意思的图，表示了九种算法，生成全排列的顺序。

![](https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-05-21-V8zUei.jpg)

> Ordering of all permutations of length \\({\displaystyle n=4}\\) generated by different algorithms. The permutations are color-coded, where 1[❤️], 2[💛], 3[💚], 4[💙]

这九种算法分别是：

1. [字典序](#字典序)
2. [邻位对换法](#邻位对换法)
3. [Heap 算法](#heap-算法4)
4. Ehrlich's star-transposition algorithm 
5. Zaks' prefix reversal algorithm
6. Sawada-Williams' algorithm
7. Corbett's algorithm
8. Single-track ordering
9. Single-track Gray code

下面是参考了一些网站[^2]，用 Swift 实现常见的全排列生成算法。

### 回溯法

主要思路：交换、排列、恢复

```swift
func permute1(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    func _p(_ a: [Int], _ l: Int, _ r: Int) {
        var tmp = a
        if l == r {
            ans.append(a)
            return
        }
        for i in l...r {
            tmp.swapAt(l, i)
            _p(tmp, l + 1, r)
            tmp.swapAt(i, l)
        }
    }
    _p(nums, 0, nums.count - 1)
    TOCK()
    return ans
}
```

### 插入法

主要思路：对于 n 的全排列，将第 n+1 个数，插入到 (0...n) 这 n+1 个位置就可以得到 n+1 的全排列。

```swift
func permute2(_ nums: [Int]) -> [[Int]] {
    TICK()
    let ans : [[Int]] = nums.reduce([[]], { partialResult, a in
        var nextResult = [[Int]]()
        for lastArray in partialResult {
            let sz = lastArray.count
            // 将 a 插入到 n-1 排列中的 sz 个位置
            for i in (0...sz) {
                // ArraySlice<Int> 类型
                let temp = lastArray[0..<i] + [a] + lastArray[i..<sz]
                nextResult.append(Array(temp))
            }
        }
        return nextResult
    })
    TOCK()
    return ans
}
```

`reduce` 是个挺有意思的方法，有两个参数，一个是初始值，一个是闭包，闭包接收两个参数，一是上一步的结果，另一个是序列中的值。

上面的代码等价于：

```swift
var ans : [[Int]] = [[]]
for i in 0..<nums.count {
    var nextResult = [[Int]]()
    for (_, item) in ans.enumerated() {
        let sz = item.count
        // 将 a 插入到 n-1 排列中的 sz 个位置
        for k in (0...sz) {
            // ArraySlice<Int> 类型
            let temp = item[0..<k] + [nums[i]] + item[k..<sz]
            nextResult.append(Array(temp))
        }
    }
    ans = nextResult
}
```

### 字典序

* 首次定义全升序为最小的序列，全降序为最大的序列。

* 问题变成从最小逐一生成下一个排列，生成下一个排列(**nextPermutation**) 的算法有四步：

  1. 从后向前找到第一个逆序的位置 \\(j\\), 即 \\(p_j < p_{j+1} >= p_{j+2}\\)
  2. 重新从后向前找到第一个比 \\(p_j\\) 大的数 \\(p_k\\)，由于 \\([j+1, n)\\) 是降序的 (第一步决定)，
  \\(k\\) 必然也是满足这个条件的最小的数，即 \\(P_k = \min\\{P_i | P_i > P_j, i > j\\}\\)
  3. 交换 \\(j\\) 和 \\(k\\) 位置的数
  4. 将 \\([j+1, n)\\) 反转 (降序变升序，其实就是重排序)

```swift
func permute3(_ nums: [Int]) -> [[Int]] {
    TICK()
    let nextPermutation : ([Int]) -> [Int]? = {
        array in
        var result = array
        let sz = array.count
        var j = -1
        // 找到第一个比后面数小的数
        for i in (0..<sz-1).reversed() {
            if result[i] < result[i+1] {
                j = i;
                break;
            }
        }
        // 找不到说明已经是全逆序，即最后一个排列
        if (j == -1) {
            return nil
        }
        var k = -1
        // 找到 [j+1, sz) 中比 j 大的数中最小的一个 k
        // 第一个就是最小的，因为 [j+1, sz) 是递减的
        for i in (j+1..<sz).reversed() {
            if result[i] > result[j] {
                k = i
                break
            }
        }
        // 交换 j - k
        result.swapAt(j, k)
        // [j+1, sz)
        result = Array(result[0...j] + result[j+1..<sz].reversed())
        return result
    }
    var ans = [[Int]]()
    ans.append(nums.sorted())
    while let next = nextPermutation(ans.last!) {
        ans.append(next)
    }
    TOCK()
    return ans
}
```

### 递归法

主要思路是，枚举原数组所有位置，将位置上的数移到结果数组中，直到原数组清空。

```swift
func permute4(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    func _p(_ a: [Int], _ result: [Int]) {
        let sz = a.count
        if sz == 0 {
            ans.append(result)
            return
        }
        for i in 0..<sz {
            let rest = Array(a[0..<i] + a[i+1..<sz])
            _p(rest, result + [a[i]])
        }
    }
    _p(nums, [])
    TOCK()
    return ans
}
```

### 邻位对换法[^3]

也就是 `Steinhaus–Johnson–Trotter` 算法。

// TODO：待补充


### Heap 算法[^4]



### 递增进位法



### 递减进位法


### 快速排列

`QuickPerm` 算法[^5]。


以下是通过 `TICK/TOCK` 宏生成的各个算法的执行时间 （以 10 个数排列为例）

| 算法 | 时间 |
| -- | -- |
| 回溯法 | 4.01 s |
| 插入法 | 4.39 s |
| 字典序 | 8.02 s |
| 递归法 | 11.13 s |

> 耗时统计
```swift
var g_start_time = NSDate()
public func TICK() {
    g_start_time = NSDate()
}
public func TOCK(function: String = #function) {
    print(String(format: "[%@] cost: %.2lf s", function, -g_start_time.timeIntervalSinceNow))
}
```

## 关于中介数[^6]

中介数是为了快速推导某个排列的中间数。以字典序为例，我们本来可以使用序号 \\(0,1,2..n!\\) 来表示各个排列。

但从这个序号推导出具体的排列，不是很容易。所以我们引入了中介数的概念。

假设排列 \\(\sigma = (\sigma_1,\sigma_2,\sigma_3,...)\\)，定义中介数为 \\(L(\sigma) = (L_{n-1}L_{n-2}..L_1)\\)

* \\(L_{n-i}\\) 表示 \\(\sigma_i\\) 右边比它的小的数的个数
* 中介数是特殊进制设计，最低位是 2 进制，次低位是 3 进制，依次类推，它的十进制结果就是字典序的序号
* 中介数的计算：\\(L(\sigma) = L_{n-1}(n-1)! + L_{n-2}(n-2)! + ... + L_1 * 1!\\)
* 一个 \\(n-1\\) 位的中介数，可以表示 \\(n!\\) 个数字，正好与排列数对应
* 一个中介数对应一个特定的排列，同样根据一个排列也能求出其中介数

中介数的应用举例：

> 求排列 83674521 之前第 2015 个排列。

另外，在前面提到的 [60. Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)

如果直接遍历，效率不高。使用中介数可以直接得到结果。

BTW, 找了好久，发现这个概念的英文叫 [Lehmer Code](https://en.wikipedia.org/wiki/Lehmer_code) - 莱默编码[^7]

## 关于去重



[^1]: https://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations
[^2]: https://www.baeldung.com/cs/array-generate-all-permutations
[^3]: [Steinhaus–Johnson–Trotter algorithm](https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm)
[^4]: https://en.wikipedia.org/wiki/Heap%27s_algorithm
[^5]: https://www.quickperm.org/01example.php
[^6]: [全排列生成算法](https://zh.m.wikipedia.org/zh-cn/%E5%85%A8%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95)
[^7]: https://en.wikipedia.org/wiki/Permutation#Numbering_permutations

