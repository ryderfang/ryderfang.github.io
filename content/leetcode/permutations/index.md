---
title: "å…¨æ’åˆ—ç®—æ³•"
date: 2022-05-21T13:20:37+08:00
categories: [Permutations]
tags: []
---

> A permutation is an act of arranging the objects or numbers in order. Combinations are the way of selecting the objects or numbers from a group of objects or collection, in such a way that the order of the objects does not matter.

æ’åˆ—ç»„åˆæ˜¯ç»„åˆ/ç¦»æ•£æ•°å­¦ä¸­çš„åŸºç¡€å’Œé‡è¦çš„æ¦‚å¿µã€‚

{{< katex >}}

$$
  P_n^m = A_n^m = n(n-1)(n-2)...(n-m+1) = \frac {n!}{(n-m)!}
$$

å½“ \\(n = m\\) æ—¶ï¼Œä¹Ÿå°±æ˜¯å…¨æ’åˆ—ï¼š

\\(P_n = n(n-1)(n-2)...3 \times 2 \times 1 = n!\\)

é»˜è®¤æ˜¯ä¸æ”¾å›æ’åˆ—ï¼Œå¦‚æœæ˜¯é‡å¤æ’åˆ—ï¼Œé‚£ä¹ˆæ’åˆ—æ•°å°±æ˜¯ \\(n^m\\)

å“ˆå“ˆï¼Œè·‘åäº†ï¼Œè¿™ç¯‡ä¸æ˜¯è¦æ¼”ç¤º [KaTex çš„ç”¨æ³•](https://katex.org/docs/supported.html) ï¼ˆè™½ç„¶ç¡®å®æŒºæœ‰æ„æ€çš„ ğŸ˜¹ï¼‰

## åº”ç”¨

* [46. Permutations](https://leetcode.com/problems/permutations/)
* [31. Next Permutation](https://leetcode.com/problems/next-permutation/)
* [47. Permutations II](https://leetcode.com/problems/permutations-ii/)
* [60. Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)

## æ’åˆ—ç®—æ³•

æˆ‘ä»¬çŸ¥é“æ’åˆ—æ•°æ˜¯é˜¶ä¹˜çº§å¢é•¿ï¼Œ10ä¸ªæ•°çš„æ’åˆ—å°±è¾¾åˆ°äº† \\(10! = 3628800\\)ï¼Œç™¾ä¸‡çº§çš„è§„æ¨¡ã€‚

æ‰€ä»¥ï¼Œå³ä½¿æˆ‘ä»¬ `O(1)` ç”Ÿæˆä¸€ä¸ªæ’åˆ—ï¼Œé‚£ç”Ÿæˆå…¨æ’åˆ—çš„ç®—æ³•å¤æ‚åº¦ä¹Ÿæ˜¯ `O(n!)`ï¼Œéå¸¸ææ€–ã€‚

åœ¨ wiki[^1] ä¸Šæœ‰ä¸€ä¸ªæœ‰æ„æ€çš„å›¾ï¼Œè¡¨ç¤ºäº†ä¹ç§ç®—æ³•ï¼Œç”Ÿæˆå…¨æ’åˆ—çš„é¡ºåºã€‚

![](https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-05-21-V8zUei.jpg)

> Ordering of all permutations of length \\({\displaystyle n=4}\\) generated by different algorithms. The permutations are color-coded, where 1[â¤ï¸], 2[ğŸ’›], 3[ğŸ’š], 4[ğŸ’™]

è¿™ä¹ç§ç®—æ³•åˆ†åˆ«æ˜¯ï¼š

1. [å­—å…¸åº](#å­—å…¸åº)
2. [é‚»ä½å¯¹æ¢æ³•](#é‚»ä½å¯¹æ¢æ³•)
3. [Heap ç®—æ³•](#heap-ç®—æ³•4)
4. Ehrlich's star-transposition algorithm 
5. Zaks' prefix reversal algorithm
6. Sawada-Williams' algorithm
7. Corbett's algorithm
8. Single-track ordering
9. Single-track Gray code

ä¸‹é¢æ˜¯å‚è€ƒäº†ä¸€äº›ç½‘ç«™[^2]ï¼Œç”¨ Swift å®ç°å¸¸è§çš„å…¨æ’åˆ—ç”Ÿæˆç®—æ³•ã€‚

### å›æº¯æ³•

ä¸»è¦æ€è·¯ï¼šäº¤æ¢ã€æ’åˆ—ã€æ¢å¤

```swift
func permute1(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    func _p(_ a: [Int], _ l: Int, _ r: Int) {
        var tmp = a
        if l == r {
            ans.append(a)
            return
        }
        for i in l...r {
            tmp.swapAt(l, i)
            _p(tmp, l + 1, r)
            tmp.swapAt(i, l)
        }
    }
    _p(nums, 0, nums.count - 1)
    TOCK()
    return ans
}
```

### æ’å…¥æ³•

ä¸»è¦æ€è·¯ï¼šå¯¹äº n çš„å…¨æ’åˆ—ï¼Œå°†ç¬¬ n+1 ä¸ªæ•°ï¼Œæ’å…¥åˆ° (0...n) è¿™ n+1 ä¸ªä½ç½®å°±å¯ä»¥å¾—åˆ° n+1 çš„å…¨æ’åˆ—ã€‚

```swift
func permute2(_ nums: [Int]) -> [[Int]] {
    TICK()
    let ans : [[Int]] = nums.reduce([[]], { partialResult, a in
        var nextResult = [[Int]]()
        for lastArray in partialResult {
            let sz = lastArray.count
            // å°† a æ’å…¥åˆ° n-1 æ’åˆ—ä¸­çš„ sz ä¸ªä½ç½®
            for i in (0...sz) {
                // ArraySlice<Int> ç±»å‹
                let temp = lastArray[0..<i] + [a] + lastArray[i..<sz]
                nextResult.append(Array(temp))
            }
        }
        return nextResult
    })
    TOCK()
    return ans
}
```

`reduce` æ˜¯ä¸ªæŒºæœ‰æ„æ€çš„æ–¹æ³•ï¼Œæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ˜¯åˆå§‹å€¼ï¼Œä¸€ä¸ªæ˜¯é—­åŒ…ï¼Œé—­åŒ…æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œä¸€æ˜¯ä¸Šä¸€æ­¥çš„ç»“æœï¼Œå¦ä¸€ä¸ªæ˜¯åºåˆ—ä¸­çš„å€¼ã€‚

ä¸Šé¢çš„ä»£ç ç­‰ä»·äºï¼š

```swift
var ans : [[Int]] = [[]]
for i in 0..<nums.count {
    var nextResult = [[Int]]()
    for (_, item) in ans.enumerated() {
        let sz = item.count
        // å°† a æ’å…¥åˆ° n-1 æ’åˆ—ä¸­çš„ sz ä¸ªä½ç½®
        for k in (0...sz) {
            // ArraySlice<Int> ç±»å‹
            let temp = item[0..<k] + [nums[i]] + item[k..<sz]
            nextResult.append(Array(temp))
        }
    }
    ans = nextResult
}
```

### å­—å…¸åº

* é¦–æ¬¡å®šä¹‰å…¨å‡åºä¸ºæœ€å°çš„åºåˆ—ï¼Œå…¨é™åºä¸ºæœ€å¤§çš„åºåˆ—ã€‚

* é—®é¢˜å˜æˆä»æœ€å°é€ä¸€ç”Ÿæˆä¸‹ä¸€ä¸ªæ’åˆ—ï¼Œç”Ÿæˆä¸‹ä¸€ä¸ªæ’åˆ—(**nextPermutation**) çš„ç®—æ³•æœ‰å››æ­¥ï¼š

  1. ä»åå‘å‰æ‰¾åˆ°ç¬¬ä¸€ä¸ªé€†åºçš„ä½ç½® \\(j\\), å³ \\(p_j < p_{j+1} >= p_{j+2}\\)
  2. é‡æ–°ä»åå‘å‰æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯” \\(p_j\\) å¤§çš„æ•° \\(p_k\\)ï¼Œç”±äº \\([j+1, n)\\) æ˜¯é™åºçš„ (ç¬¬ä¸€æ­¥å†³å®š)ï¼Œ
  \\(k\\) å¿…ç„¶ä¹Ÿæ˜¯æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„æœ€å°çš„æ•°ï¼Œå³ \\(P_k = \min\\{P_i | P_i > P_j, i > j\\}\\)
  3. äº¤æ¢ \\(j\\) å’Œ \\(k\\) ä½ç½®çš„æ•°
  4. å°† \\([j+1, n)\\) åè½¬ (é™åºå˜å‡åºï¼Œå…¶å®å°±æ˜¯é‡æ’åº)

```swift
func permute3(_ nums: [Int]) -> [[Int]] {
    TICK()
    let nextPermutation : ([Int]) -> [Int]? = {
        array in
        var result = array
        let sz = array.count
        var j = -1
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”åé¢æ•°å°çš„æ•°
        for i in (0..<sz-1).reversed() {
            if result[i] < result[i+1] {
                j = i;
                break;
            }
        }
        // æ‰¾ä¸åˆ°è¯´æ˜å·²ç»æ˜¯å…¨é€†åºï¼Œå³æœ€åä¸€ä¸ªæ’åˆ—
        if (j == -1) {
            return nil
        }
        var k = -1
        // æ‰¾åˆ° [j+1, sz) ä¸­æ¯” j å¤§çš„æ•°ä¸­æœ€å°çš„ä¸€ä¸ª k
        // ç¬¬ä¸€ä¸ªå°±æ˜¯æœ€å°çš„ï¼Œå› ä¸º [j+1, sz) æ˜¯é€’å‡çš„
        for i in (j+1..<sz).reversed() {
            if result[i] > result[j] {
                k = i
                break
            }
        }
        // äº¤æ¢ j - k
        result.swapAt(j, k)
        // [j+1, sz)
        result = Array(result[0...j] + result[j+1..<sz].reversed())
        return result
    }
    var ans = [[Int]]()
    ans.append(nums.sorted())
    while let next = nextPermutation(ans.last!) {
        ans.append(next)
    }
    TOCK()
    return ans
}
```

### é€’å½’æ³• âœ¨

ä¸»è¦æ€è·¯æ˜¯ï¼Œæšä¸¾åŸæ•°ç»„æ‰€æœ‰ä½ç½®ï¼Œå°†ä½ç½®ä¸Šçš„æ•°ç§»åˆ°ç»“æœæ•°ç»„ä¸­ï¼Œç›´åˆ°åŸæ•°ç»„æ¸…ç©ºã€‚

```swift
func permute4(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    func _p(_ a: [Int], _ result: [Int]) {
        let sz = a.count
        if sz == 0 {
            ans.append(result)
            return
        }
        for i in 0..<sz {
            let rest = Array(a[0..<i] + a[i+1..<sz])
            _p(rest, result + [a[i]])
        }
    }
    _p(nums, [])
    TOCK()
    return ans
}
```

### é‚»ä½å¯¹æ¢æ³•[^3]

ä¹Ÿå°±æ˜¯ `Steinhausâ€“Johnsonâ€“Trotter` ç®—æ³•ã€‚

é¦–å…ˆï¼Œå®šä¹‰å‡åºæ˜¯æ­£æ–¹å‘ï¼Œè€Œå¯¹äº \\(a[i] > a[j], i < j\\)ï¼Œå°±æ˜¯ä¸€ä¸ªé€†åºå¯¹ã€‚

* åˆå§‹åŒ–ä¸€ä¸ªæ–¹å‘æ•°ç»„ï¼Œé»˜è®¤å…¨ 0ï¼Œè¡¨ç¤ºå‘å·¦äº¤æ¢ï¼Œå¦‚æœå˜æˆ 1ï¼Œå°±æ˜¯å‘å³äº¤æ¢
* ç¡®è®¤ä¸€ä¸ªå…ƒç´ æ˜¯å¦èƒ½äº¤æ¢ï¼ˆæ´»åŠ¨çŠ¶æ€ï¼‰ï¼šåœ¨å®ƒçš„æ–¹å‘ä¸Šï¼Œå®ƒçš„é‚»ä½æ¯”è‡ªå·±å°ã€‚

ç®—æ³•æ­¥éª¤å°±æ˜¯ï¼š

1. åˆå§‹åŒ–æ–¹å‘æ•°ç»„ï¼Œå…¨éƒ¨å‘å·¦äº¤æ¢
2. æ‰¾åˆ°æ‰€æœ‰å¤„äºæ´»åŠ¨çŠ¶æ€å…ƒç´ ä¸­æœ€å¤§çš„ä¸€ä¸ª
3. å°†å®ƒä¸é‚»ä½äº¤æ¢
4. å°†æ‰€æœ‰å¤§äºä¸Šé¢è¿™ä¸ªå…ƒç´ ï¼ˆéæ´»åŠ¨çŠ¶æ€ï¼‰çš„å…¶ä»–å…ƒç´ æ–¹å‘åè½¬
5. è·³è½¬ 2ï¼Œç›´è‡³æ‰¾ä¸åˆ°è¿™æ ·çš„å…ƒç´ 

```swift
func permute5(_ nums: [Int]) -> [[Int]] {
    TICK()
    var a = nums
    let sz = a.count
    var ans = [[Int]]()
    // -1 means left, 1 means right
    var directions = [Int](repeating: -1, count: sz)
    func _movable() -> Int? {
        var max = 1
        var pos = -1
        for i in 0..<sz {
            if a[i] < max {
                continue
            }
            if (directions[i] > 0 && i < sz - 1 && a[i] > a[i+1]) ||
                (directions[i] < 0 && i > 0 && a[i] > a[i-1]) {
                max = a[i]
                pos = i
            }
        }
        if (pos >= 0) {
            return pos
        }
        return nil
    }
    ans.append(a)
    while let max_i = _movable() {
        let max_v = a[max_i]
        a.swapAt(max_i, max_i + directions[max_i])
        // æ³¨æ„ï¼šæ–¹å‘ä¹Ÿè¦è·Ÿç€äº¤æ¢
        directions.swapAt(max_i, max_i + directions[max_i])
        ans.append(a)
        for i in 0..<sz {
            if (a[i] > max_v) {
                directions[i] = -directions[i]
            }
        }
    }
    TOCK()
    return ans
}
```

> ç›¸æ¯”å­—å…¸åºæ¥è¯´ï¼Œé‚»ä½äº¤æ¢åœ¨äº¤æ¢è¿™ä¸€æ­¥æ›´å¿«ï¼Œä½†æ˜¯æŸ¥æ‰¾æœ€å¤§å¯ç§»åŠ¨å…ƒç´ å’Œä¿®æ”¹æ–¹å‘æ—¶ï¼Œéœ€è¦éå†ã€‚æ•´ä½“æ¥è¯´ï¼Œæ—¶é—´å·®ä¸å¤šã€‚

### Heap ç®—æ³•[^4]

```swift
func _permute6(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    func _heap(k: Int, a: inout [Int]) {
        if k == 1 {
            ans.append(a)
            return
        }
        // Generate permutations with k-th unaltered
        // Initially k = length(A)
        _heap(k: k-1, a: &a)
        // Generate permutations for k-th swapped with each k-1 initial
        for i in 0..<k-1 {
            // Swap choice dependent on parity of k (even or odd)
            if k % 2 == 0 {
                a.swapAt(i, k-1)
            } else {
                a.swapAt(0, k-1)
            }
            _heap(k: k-1, a: &a)
        }
    }
    var a = nums
    _heap(k: a.count, a: &a)
    TOCK()
    return ans
}
```

### é€’å¢è¿›ä½æ³•

```swift
func permute7(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    let sz = nums.count
    var inc = [Int](repeating: 0, count: sz)
    // inc[i] è¡¨ç¤º (i+1) å³è¾¹æ¯”å®ƒçš„å°çš„æ•°çš„ä¸ªæ•°ï¼Œæ˜¯ (i+1) è¿›åˆ¶æ•°
    // inc[0] æ€»æ˜¯ 0
    func _outInc() -> String {
        let rev : [String] = inc[1...].reversed().map({ String($0) })
        return rev.joined()
    }
    
    // æœ€ä½ä½æ˜¯ 2 è¿›åˆ¶ï¼Œé€’å¢æ—¶è¿›ä½å¤š
    func _increace() -> Bool {
        var i = 1
        var carry = 1
        while i < sz {
            if carry == 0 {
                break
            }
            let sum = inc[i] + carry
            inc[i] = sum % (i + 1)
            carry = sum / (i + 1)
            i += 1
        }
        // å¦‚æœè¿˜æœ‰è¿›ä½ï¼Œè¯´æ˜å·²ç»åˆ°äº†æœ€å¤§çš„æ’åˆ—
        return (carry == 0)
    }
    
    func _next() -> Bool {
        // æ ¹æ®å½“å‰ä¸­ä»‹æ•°æ±‚æ’åˆ—
        var p = [Int](repeating: 0, count: sz)
        for i in (0..<sz).reversed() {
            var count = 0
            var j = sz - 1
            // inc[i] + 1 çš„ç©ºä½ï¼Œæ”¾ sz - i
            while j >= 0 {
                if p[j] == 0 {
                    count += 1
                }
                if (count > inc[i]) {
                    break
                }
                j -= 1
            }
            // p[j] = i + 1
            p[j] = nums[i]
        }
        ans.append(p)
        
        //print(_outInc())
        // ä¸­ä»‹æ•° + 1
        return _increace()
    }
    
    while _next() {
        
    }
    TOCK()
    return ans
}
```

### é€’å‡è¿›ä½æ³•

```swift
func permute8(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    let sz = nums.count
    var inc = [Int](repeating: 0, count: sz)
    // inc[i] è¡¨ç¤º (n-i) å³è¾¹æ¯”å®ƒçš„å°çš„æ•°çš„ä¸ªæ•°ï¼Œæ˜¯ (n-i) è¿›åˆ¶æ•°
    // inc[sz-1] æ€»æ˜¯ 0
    func _outInc() -> String {
        let rev : [String] = inc[0..<sz-1].reversed().map({ String($0) })
        return rev.joined()
    }
    
    // æœ€ä½ä½æ˜¯ n è¿›åˆ¶ï¼Œé€’å¢æ—¶è¿›ä½å°‘
    func _increace() -> Bool {
        var i = 0
        var carry = 1
        while i < sz - 1 {
            if carry == 0 {
                break
            }
            let sum = inc[i] + carry
            inc[i] = sum % (sz - i)
            carry = sum / (sz - i)
            i += 1
        }
        // å¦‚æœè¿˜æœ‰è¿›ä½ï¼Œè¯´æ˜å·²ç»åˆ°äº†æœ€å¤§çš„æ’åˆ—
        return (carry == 0)
    }
    
    func _next() -> Bool {
        // æ ¹æ®å½“å‰ä¸­ä»‹æ•°æ±‚æ’åˆ—
        var p = [Int](repeating: 0, count: sz)
        for i in 0..<sz {
            var count = 0
            var j = sz - 1
            // inc[i] + 1 çš„ç©ºä½ï¼Œæ”¾ sz - i
            while j >= 0 {
                if p[j] == 0 {
                    count += 1
                }
                if (count > inc[i]) {
                    break
                }
                j -= 1
            }
            // p[j] = sz - i
            p[j] = nums[sz - i - 1]
        }
        ans.append(p)
        
        //print(_outInc())
        // ä¸­ä»‹æ•° + 1
        return _increace()
    }
    
    while _next() {
        
    }
    TOCK()
    return ans
}
```

å¯ä»¥çœ‹å‡ºæ¥ï¼Œé€’å‡è¿›ä½åˆ¶å’Œé€’å¢è¿›ä½åˆ¶æ³•éå¸¸ç±»ä¼¼ã€‚åŒºåˆ«ä»…åœ¨äºï¼š

* ä¸­ä»‹æ•°çš„æœ€ä½ä½ï¼Œé€’å‡æ³•æ˜¯ \\(n\\) è¿›åˆ¶æ•°ï¼Œè€Œé€’å¢æ³•æ˜¯ \\(2\\) è¿›åˆ¶ï¼Œè¿™æ ·åœ¨è¿­ä»£æ—¶ï¼Œé€’å¢æ³•éœ€è¦è¿›ä½çš„æ¬¡æ•°æ›´å¤šã€‚

### å¿«é€Ÿæ’åˆ—

`QuickPerm` ç®—æ³•[^5]ã€‚

```swift
func permute9(_ nums: [Int]) -> [[Int]] {
    TICK()
    var ans = [[Int]]()
    var a = nums
    // init: [0,0,0...0]
    var p = [Int](repeating: 0, count: a.count)
    ans.append(a)
    var i = 1
    var j : Int
    while i < a.count {
        if (p[i] < i) {
            // if i is odd, j = p[i]; else 0
            j = i % 2 * p[i]
            // swap(a[i], a[j])
            (a[i], a[j]) = (a[j], a[i])
            ans.append(a)
            p[i] += 1
            i = 1
        } else {
            p[i] = 0
            i += 1
        }
    }
    TOCK()
    return ans
}
```

å¼€å§‹æˆ‘æ²¡å¤ªç†è§£è¿™ä¸ªç®—æ³•çš„é€»è¾‘ï¼Œåæ¥çœ‹åˆ°äº† `Heap` ç®—æ³•çš„ [éé€’å½’å®ç°](https://en.wikipedia.org/wiki/Heap%27s_algorithm#Details_of_the_algorithm)ã€‚

ä¸èƒ½è¯´æ¯”è¾ƒç›¸ä¼¼å§ï¼Œåªèƒ½è¯´ä¸€æ¨¡ä¸€æ ·ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯è¿™ä¸ªç®—æ³•æ”¹è¿›äº†èµ·å§‹ç‚¹ä» `i = 0` å˜æˆäº† `i = 1`ï¼Œå› ä¸º `i = 0` è¿›å…¥å¾ªç¯åä»€ä¹ˆä¹Ÿæ²¡æœ‰å˜åŒ–å°±è¿›å…¥äº† `i = 1` çš„çŠ¶æ€ã€‚ä½†æ˜¯è¿™ä¸€ç‚¹ä¼˜åŒ–ï¼Œåœ¨æ•°æ®é‡å·¨å¤§çš„æƒ…å†µä¸‹ï¼Œæ˜¯è´¨çš„æå‡ï¼

å¦å¤–ï¼Œåœ¨å®ƒçš„å®˜ç½‘ä¸Šï¼Œè¿™ä¸€å®ç°è¢«ç§°ä¸º `Counting`ï¼Œè¿˜æœ‰å¦ä¸€ç§å®ç°å« [`Countdown`](https://www.quickperm.org/01example.php)ï¼ŒåŒºåˆ«å°±åœ¨äº \\(P[]\\) æ•°ç»„çš„åˆå§‹åŒ–å’Œä¿®æ”¹æ–¹å¼ï¼Œä¸€ä¸ªé€’å¢ã€ä¸€ä¸ªé€’å‡ã€‚

## è€—æ—¶ç»Ÿè®¡ âŒ›

ä»¥ä¸‹æ˜¯é€šè¿‡ `TICK/TOCK` å®ç”Ÿæˆçš„å„ä¸ªç®—æ³•çš„æ‰§è¡Œæ—¶é—´ ï¼ˆä»¥ 10 ä¸ªæ•°æ’åˆ—ä¸ºä¾‹ï¼‰

| ç®—æ³• | æ—¶é—´ |
| -- | -- |
| å›æº¯æ³• | 4.97 s |
| æ’å…¥æ³• | 4.58 s |
| å­—å…¸åº | 8.24 s |
| é€’å½’æ³• | 11.49 s |
| é‚»ä½å¯¹æ¢æ³• | 28.37 s |
| Heap ç®—æ³• | **2.57 s** |
| é€’å¢è¿›ä½æ³• | 16.70 s |
| é€’å‡å¯¹æ¢æ³• | 19.67 s |
| å¿«é€Ÿæ’åˆ—ç®—æ³• | **0.78 s** |

ä¸æ„§æ˜¯ `å¿«é€Ÿæ’åˆ—` ç®—æ³•ï¼

* ç»Ÿè®¡å®
```swift
var g_start_time = NSDate()
public func TICK() {
    g_start_time = NSDate()
}
public func TOCK(function: String = #function) {
    print(String(format: "[%@] cost: %.2lf s", function, -g_start_time.timeIntervalSinceNow))
}
```

## æœ€ä½³å®è·µ ğŸš€

ä¸Šé¢è®²äº†éå¸¸å¤šçš„ç®—æ³•ï¼Œä½†æ˜¯æœ‰äº›éš¾ä»¥ç†è§£ï¼Œæˆ‘è§‰å¾—å¯¹äºåŒç±»ç®—æ³•ï¼Œåªéœ€è®°ä½æœ€å®¹æ˜“ç†è§£çš„é€»è¾‘å³å¯ã€‚

```swift
func permute(_ nums: [Int]) -> [[Int]] {
    guard !nums.isEmpty else { return [] }
    
    var ans = [[Int]]()
    var a = nums
    let n = nums.count
    func _p(_ index: Int) {
        if index == n {
            ans.append(a)
            return
        }
        for i in index..<n {
            a.swapAt(index, i)
            _p(index + 1)
            a.swapAt(i, index)
        }
    }
    _p(0)
    return ans
}
```

## å…³äºå»é‡

å¯¹äºæœ‰é‡å¤å…ƒç´ çš„æ’åˆ—[^6]ï¼š

* [47. Permutations II](https://leetcode.com/problems/permutations-ii/)

æœ€å®¹æ˜“æƒ³åˆ°çš„æ˜¯ï¼Œä¸ç®¡é‡å¤å…ƒç´ ï¼Œå…ˆæ±‚å‡ºæ‰€æœ‰æ’åˆ—ã€‚ç„¶åå†å»é‡ã€‚

æˆ‘ä»¬åœ¨ä¸Šé¢çš„æœ€ä½³å®è·µä¸Šç¨åŠ æ”¹åŠ¨ï¼š

```swift
func permuteUnique(_ nums: [Int]) -> [[Int]] {
    guard !nums.isEmpty else { return [] }
    
    var ans = Set<[Int]>()
    var a = nums
    let n = nums.count
    func _p(_ index: Int) {
        if index == n {
            ans.insert(a)
            return
        }
        for i in index..<n {
            a.swapAt(index, i)
            _p(index + 1)
            a.swapAt(i, index)
        }
    }
    _p(0)
    return Array(ans)
}
```

![](https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-05-29-eTF3Mg.png)

ä¹Ÿè¿˜è¡Œï¼Œå°±æ˜¯ä¾èµ– `Set` çš„æ€§è´¨ï¼Œæœ‰ç‚¹è€—æ—¶ã€‚é‚£ä¹ˆæ€ä¹ˆåœ¨æ±‚æ’åˆ—è¿‡ç¨‹ä¸­ç›´æ¥å¿½ç•¥é‡å¤é¡¹å‘¢ï¼Ÿ

```swift
func permuteUnique2(_ nums: [Int]) -> [[Int]] {
    guard !nums.isEmpty else { return [] }

    let n = nums.count
    var ans = [[Int]]()
    var used = [Bool](repeating: false, count: n)
    let a = nums.sorted()
    func _backTracking(locatedAt index: Int, with result: inout [Int]) -> Void {
        guard index < n else {
            ans.append(result)
            return
        }
        for i in 0..<n {
            if used[i] {
                continue
            } else if (i > 0 && a[i] == a[i-1] && !used[i-1]) {
                // è¿™é‡Œæ˜¯å”¯ä¸€çš„åŒºåˆ«
                continue
            }
            result.append(a[i])
            used[i] = true
            _backTracking(locatedAt: index + 1, with: &result)
            used[i] = false
            result.removeLast()
        }
    }
    
    var tmp = [Int]()
    _backTracking(locatedAt: 0, with: &tmp)
    return ans
}
```

å¦‚æœæ²¡æœ‰è¿™å¥ `if (i > 0 && a[i] == a[i-1] && !used[i-1])` åˆ¤æ–­ï¼Œå°±æ˜¯æ— é‡å¤å…ƒç´ çš„å…¨æ’åˆ—å›æº¯ç®—æ³•ã€‚

è¿™å¥çš„é€»è¾‘æ˜¯ï¼Œåœ¨æ‰€æœ‰ç›¸åŒçš„æœªé€‰æ‹©å…ƒç´ ä¸­ï¼Œé€‰æ‹©ä¸€ä¸ªåºå·æœ€å°çš„ã€‚

[^1]: https://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations
[^2]: https://www.baeldung.com/cs/array-generate-all-permutations
[^3]: [Steinhausâ€“Johnsonâ€“Trotter algorithm](https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm)
[^4]: https://en.wikipedia.org/wiki/Heap%27s_algorithm
[^5]: https://www.quickperm.org/quickperm.php
[^6]: https://segmentfault.com/a/1190000040142137
