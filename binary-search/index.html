<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>很难写“正确”的二分查找 | 热爱可抵岁月漫长</title><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ryderfang.com/binary-search/featured-image.jpg"><meta name=twitter:title content="很难写“正确”的二分查找"><meta name=twitter:description content><meta name=twitter:creator content="@ryderfang"><meta name=Description content="而不是给文明以岁月"><meta property="og:title" content="很难写“正确”的二分查找"><meta property="og:description" content="“二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 O(log n)，空间复杂度 O(1)，相比线性搜索优秀太多。
但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本1能准确写对“二分”查找。"><meta property="og:type" content="article"><meta property="og:url" content="https://ryderfang.com/binary-search/"><meta property="og:image" content="https://ryderfang.com/binary-search/featured-image.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-08T17:52:24+08:00"><meta property="article:modified_time" content="2022-03-08T17:52:24+08:00"><meta property="og:site_name" content="热爱可抵岁月漫长"><meta name=application-name content="uBlogger"><meta name=apple-mobile-web-app-title content="uBlogger"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=192x192 href=/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=/android-chrome-512x512.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://ryderfang.com/binary-search/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/lib/prismjs/prism.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"很难写“正确”的二分查找","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/ryderfang.com\/binary-search\/"},"image":[{"@type":"ImageObject","url":"https:\/\/ryderfang.com\/binary-search\/featured-image.jpg","width":728,"height":485}],"genre":"posts","keywords":"search","wordCount":1973,"url":"https:\/\/ryderfang.com\/binary-search\/","datePublished":"2022-03-08T17:52:24+08:00","dateModified":"2022-03-08T17:52:24+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Person","name":"","image":[{"@type":"ImageObject","url":"https:\/\/ryder-1252249141.cos.ap-shanghai.myqcloud.com\/uPic\/2021-11-05-avatar2.jpg"}]},"author":{"@type":"Person","name":""},"description":""}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"主页","item":"https:\/\/ryderfang.com\/"},{"@type":"ListItem","position":2,"name":"Algorithm","item":"https://ryderfang.com/categories/algorithm/"},{"@type":"ListItem","position":3,"name":"很难写“正确”的二分查找"}]}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header><div class="desktop header" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=给岁月以文明 class="header-logo logo-svg"><img loading=lazy decoding=async class=logo src=/geoclerk.png alt=/geoclerk.png title=/geoclerk.png><span class=header-title-pre><i class="fas fa-pencil-alt fa-fw"></i></span>光锥之内，皆是命运 💫</a></div><div class=menu><nav><h2 class=display-hidden>Основная навигация</h2><ul class=menu-inner><li><a class=menu-item href=/posts/>Posts</a></li><li><a class=menu-item href=/tags/>Tags</a></li><li><a class=menu-item href=/categories/>Categories</a></li><li><a class=menu-item href=/about/>About</a></li><li><a class=menu-item href=https://github.com/upagge/ublogger title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a></li></ul></nav><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><span class="svg-icon icon-search"></span></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><span class="svg-icon icon-cancel"></span></a>
<span class="search-button search-loading" id=search-loading-desktop><span class="svg-icon icon-loading"></span></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><span class="svg-icon icon-moon"></span></a></div></div></div><div class="mobile header" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=给岁月以文明 class=header-logo><img loading=lazy decoding=async class=logo src=/geoclerk.png alt=/geoclerk.png title=/geoclerk.png><span class=header-title-pre><i class="fas fa-pencil-alt fa-fw"></i></span>光锥之内，皆是命运 💫</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><span class="svg-icon icon-search"></span></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><span class="svg-icon icon-cancel"></span></a>
<span class="search-button search-loading" id=search-loading-mobile><span class="svg-icon icon-loading"></span></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><nav><h2 class=display-hidden>Основная навигация</h2><ul><li><a class=menu-item href=/posts/ title>Posts</a></li><li><a class=menu-item href=/tags/ title>Tags</a></li><li><a class=menu-item href=/categories/ title>Categories</a></li><li><a class=menu-item href=/about/ title>About</a></li><li><a class=menu-item href=https://github.com/upagge/ublogger title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a></li></ul></nav><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><span class="svg-icon icon-moon"></span></a></div></div></div><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div></header><main class=main><div class="container content-article page-toc theme-classic"><div class=toc id=toc-auto><div class=toc-title>目录</div><div class=toc-content id=toc-content-auto></div></div><article><header class=header-post><div class=post-title><div class=post-all-meta><nav class=breadcrumbs><ol><li><a href=/>主页</a></li><li><a href=/categories/algorithm/>Algorithm</a></li><li>很难写“正确”的二分查找</li></ol></nav><h1 class="single-title flipInX">很难写“正确”的二分查找</h1><div class="post-meta summary-post-meta"><span class="post-category meta-item"><a href=/categories/algorithm/><span class="svg-icon icon-folder"></span>Algorithm</a>
</span><span class="post-meta-date meta-item"><span class="svg-icon icon-clock"></span><time class=timeago datetime=2022-03-08>2022-03-08</time>
</span><span class="post-meta-words meta-item"><span class="svg-icon icon-pencil"></span>约 1973 字</span>
<span class="post-meta-reading meta-item"><span class="svg-icon icon-stopwatch"></span>预计阅读 4 分钟</span></div></div></div></header><div class="article-post toc-start"><div class="content-block content-block-first content-block-position"><div class="post single"><div class=image-theme-classic><img src=https://ryderfang.com/binary-search/featured-image.jpg style=width:100%></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#减少一次判断>减少一次判断</a></li><li><a href=#关于-cell-和-floor>关于 cell 和 floor</a></li><li><a href=#关于溢出>关于溢出</a></li><li><a href=#如果有重复元素>如果有重复元素</a></li><li><a href=#处处是坑>处处是坑</a></li><li><a href=#总之>总之</a></li></ul></nav></div></div><p>“二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 <code>O(log n)</code>，空间复杂度 <code>O(1)</code>，相比线性搜索优秀太多。</p><p>但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>能准确写对“二分”查找。</p><blockquote><p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 &mldr; — 高德纳</p></blockquote><p>二分查找的前提是待查找的序列是有序的。</p><p>本身算法逻辑非常简单<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=n>function</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=bp>T</span><span class=p>)</span> <span class=n>is</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>:=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=o>:=</span> <span class=n>n</span> − <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=n>while</span> <span class=n>L</span> ≤ <span class=n>R</span> <span class=n>do</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>:=</span> <span class=nf>floor</span><span class=p>((</span><span class=n>L</span> <span class=o>+</span> <span class=n>R</span><span class=p>)</span> <span class=o>/</span> <span class=m>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>if</span> <span class=n>A[m]</span> <span class=o>&lt;</span> <span class=bp>T</span> <span class=n>then</span>
</span></span><span class=line><span class=cl>            <span class=n>L</span> <span class=o>:=</span> <span class=n>m</span> <span class=o>+</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=n>else</span> <span class=n>if</span> <span class=n>A[m]</span> <span class=o>&gt;</span> <span class=bp>T</span> <span class=n>then</span>
</span></span><span class=line><span class=cl>            <span class=n>R</span> <span class=o>:=</span> <span class=n>m</span> − <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=n>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>return</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=n>unsuccessful</span>
</span></span></code></pre></div><h2 id=减少一次判断 class=headerLink><a href=#%e5%87%8f%e5%b0%91%e4%b8%80%e6%ac%a1%e5%88%a4%e6%96%ad class=header-mark></a>减少一次判断</h2><p>上述伪代码每次循环都会比较 mid 与 target 是否相等，如果去掉这个比较，将之放到循环退出时，就可以在每次循环中减少一次比较，总得循环次数仅比上面的算法多一次。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=n>function</span> <span class=nf>binary_search_alternative</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=bp>T</span><span class=p>)</span> <span class=n>is</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>:=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=o>:=</span> <span class=n>n</span> − <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=n>while</span> <span class=n>L</span> <span class=o>!=</span> <span class=n>R</span> <span class=n>do</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>:=</span> <span class=nf>ceil</span><span class=p>((</span><span class=n>L</span> <span class=o>+</span> <span class=n>R</span><span class=p>)</span> <span class=o>/</span> <span class=m>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>if</span> <span class=n>A[m]</span> <span class=o>&gt;</span> <span class=bp>T</span> <span class=n>then</span>
</span></span><span class=line><span class=cl>            <span class=n>R</span> <span class=o>:=</span> <span class=n>m</span> − <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=n>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>L</span> <span class=o>:=</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>    <span class=n>if</span> <span class=n>A[L]</span> <span class=o>=</span> <span class=bp>T</span> <span class=n>then</span>
</span></span><span class=line><span class=cl>        <span class=n>return</span> <span class=n>L</span>
</span></span><span class=line><span class=cl>    <span class=n>return</span> <span class=n>unsuccessful</span>
</span></span></code></pre></div><h2 id=关于-cell-和-floor class=headerLink><a href=#%e5%85%b3%e4%ba%8e-cell-%e5%92%8c-floor class=header-mark></a>关于 cell 和 floor</h2><p>可以看出来，上面两个实现中在取 mid 时使用了不同的方法，一个是 <code>floor()</code>，一个是 <code>ceil()</code>，</p><p><code>floor((0 + 1) / 2) = 0</code></p><p><code>ceil((0 + 1) / 2) = 1</code></p><p>为什么会有这个不同呢？在 <a href=https://stackoverflow.com/questions/27655955/why-does-binary-search-algorithm-use-floor-and-not-ceiling-not-in-an-half-open target=_blank rel="noopener noreffer">StackOverflow</a> 上有很好的解释：</p><ul><li>如果更新二元组 (l, r) -> (m + 1, m - 1) 时，这两种方法都可以，结果是一样的。</li><li>如果是 (l, r) -> (m, m - 1) 时，必须要使用 <code>ceil</code>，否则循环无法退出。比如 l = 0, r = 1, A = [1, 2]， target = 2 时，floor 会导致 l 一直被更新为 0，无法退出。</li><li>如果是 (l, r) -> (m + 1, m) 时，必须要使用 <code>floor</code>，否则同时循环无法退出。比如 l = 0, r = 1, A = [1, 2]，target = 1 时，ceil 会导致 r 一直被更新成 1。</li></ul><blockquote><p>总之，就是更新下边界更多时，使用 floor，更新上边界更多时，使用 ceil。</p></blockquote><h2 id=关于溢出 class=headerLink><a href=#%e5%85%b3%e4%ba%8e%e6%ba%a2%e5%87%ba class=header-mark></a>关于溢出</h2><p>上述算法中还有一个问题，计算 <code>mid = floor((L + R) / 2)</code> 存在可能的溢出错误，这在 <code>C++</code> 中比较常见，比如 <code>l = r = 2^31-1</code>，相加就会溢出整数范围！</p><p>正常的写法是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>mid</span> <span class=o>=</span> <span class=n>l</span> <span class=o>+</span> <span class=p>(</span><span class=n>r</span> <span class=o>-</span> <span class=n>l</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span></code></pre></div><h2 id=如果有重复元素 class=headerLink><a href=#%e5%a6%82%e6%9e%9c%e6%9c%89%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0 class=header-mark></a>如果有重复元素</h2><p>如果序列中存在重复元素，比如 <code>[1, 2, 3, 3, 3, 4, 5]</code>，要查找 <code>T = 3</code>，可能会有多个结果。</p><p>如果只是判断 target 是否存在，上述的算法都没有问题。但是如果想找到 index 最小或最大的 target 位置，算法就需要做一些修改。</p><p>参考 C++ 标准库中的 <code>std::binary_search</code> 的实现<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ForwardIterator</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>binary_search</span> <span class=p>(</span><span class=n>ForwardIterator</span> <span class=n>first</span><span class=p>,</span> <span class=n>ForwardIterator</span> <span class=n>last</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>first</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>lower_bound</span><span class=p>(</span><span class=n>first</span><span class=p>,</span><span class=n>last</span><span class=p>,</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span><span class=n>first</span><span class=o>!=</span><span class=n>last</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>val</span><span class=o>&lt;*</span><span class=n>first</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用了 <code>std::lower_bound()</code> 方法，这个方法就是在一个序列中找值为 val 的最小 index 位置，同理还有一个找最大 index 方法的函数 <code>std::upper_bound()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ForwardIterator</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>ForwardIterator</span> <span class=n>lower_bound</span> <span class=p>(</span><span class=n>ForwardIterator</span> <span class=n>first</span><span class=p>,</span> <span class=n>ForwardIterator</span> <span class=n>last</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ForwardIterator</span> <span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>iterator_traits</span><span class=o>&lt;</span><span class=n>ForwardIterator</span><span class=o>&gt;::</span><span class=n>difference_type</span> <span class=n>count</span><span class=p>,</span> <span class=n>step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>count</span> <span class=o>=</span> <span class=n>distance</span><span class=p>(</span><span class=n>first</span><span class=p>,</span><span class=n>last</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>count</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>it</span> <span class=o>=</span> <span class=n>first</span><span class=p>;</span> <span class=n>step</span><span class=o>=</span><span class=n>count</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=n>advance</span> <span class=p>(</span><span class=n>it</span><span class=p>,</span><span class=n>step</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=o>&lt;</span><span class=n>val</span><span class=p>)</span> <span class=p>{</span>                 <span class=c1>// or: if (comp(*it,val)), for version (2)
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>first</span><span class=o>=++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>count</span><span class=o>-=</span><span class=n>step</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>count</span><span class=o>=</span><span class=n>step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ForwardIterator</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>ForwardIterator</span> <span class=n>upper_bound</span> <span class=p>(</span><span class=n>ForwardIterator</span> <span class=n>first</span><span class=p>,</span> <span class=n>ForwardIterator</span> <span class=n>last</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ForwardIterator</span> <span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>iterator_traits</span><span class=o>&lt;</span><span class=n>ForwardIterator</span><span class=o>&gt;::</span><span class=n>difference_type</span> <span class=n>count</span><span class=p>,</span> <span class=n>step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>count</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>distance</span><span class=p>(</span><span class=n>first</span><span class=p>,</span><span class=n>last</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=n>count</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>it</span> <span class=o>=</span> <span class=n>first</span><span class=p>;</span> <span class=n>step</span><span class=o>=</span><span class=n>count</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=n>std</span><span class=o>::</span><span class=n>advance</span> <span class=p>(</span><span class=n>it</span><span class=p>,</span><span class=n>step</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>val</span><span class=o>&lt;*</span><span class=n>it</span><span class=p>))</span>                 <span class=c1>// or: if (!comp(val,*it)), for version (2)
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>{</span> <span class=n>first</span><span class=o>=++</span><span class=n>it</span><span class=p>;</span> <span class=n>count</span><span class=o>-=</span><span class=n>step</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=n>count</span><span class=o>=</span><span class=n>step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>区别就是在更新 <code>left = mid + 1</code> 时，如果想取左边界，条件是 <code>mid &lt; val</code>；如果想取右边界，条件是 <code>mid &lt;= val</code>。</p><h2 id=处处是坑 class=headerLink><a href=#%e5%a4%84%e5%a4%84%e6%98%af%e5%9d%91 class=header-mark></a>处处是坑</h2><p>知乎有<a href=https://zhuanlan.zhihu.com/p/343138037 target=_blank rel="noopener noreffer">一篇专栏文章：&lt;聊聊一看就会一写就跪的二分查找></a>讲了二分中的各个坑点，我们逐一看一下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FirstGreaterOrEqual</span><span class=p>(</span><span class=nx>array</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>target</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 初始化区间左端点： -1  ||  0  ||  1  ？
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>l</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 初始化区间右端点： len(array) - 1  ||  len(array)  ||  len(array) + 1  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>r</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>array</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 当区间不为空时循环： l + 1 &lt; r  ||  l &lt; r  ||  l &lt;= r  ||  l &lt;= r + 1  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>l</span> <span class=p>&lt;</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 计算区间中点： l + (r - l) / 2  ||  l + (r - l + 1) / 2  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>m</span> <span class=o>:=</span> <span class=nx>l</span> <span class=o>+</span> <span class=p>(</span><span class=nx>r</span> <span class=o>-</span> <span class=nx>l</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 将中点对应的元素同target比较： &gt;  ||  &gt;=  ||  &lt;  || &lt;=  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>array</span><span class=p>[</span><span class=nx>m</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 继续查找右侧这一半： m - 1  ||  m  ||  m + 1  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>l</span> <span class=p>=</span> <span class=nx>m</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 继续查找左侧这一半： m - 1  ||  m  ||  m + 1  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>r</span> <span class=p>=</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这里应该是 l - 1  ||  l  ||  l + 1  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这里应该是 r - 1  ||  r  ||  r + 1  ?
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nx>l</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这是一段 go 语言代码，不过不影响理解它的逻辑，其实它就是在 array 中找 target 的左边界。</p><p>来一一解释作者提出的这些坑：</p><ol><li><p>区间左端点 <code>l = 0</code> 或者其他？</p></li><li><p>区间右端点 <code>r = len(array)</code> 还是 <code>len(array) - 1</code>？</p></li></ol><p>这两个是一个问题，整个区间有四种状态 <code>(l, r)</code> <code>[l, r]</code> <code>(l, r]</code> <code>[l, r]</code></p><p>对于数组从 0 开始的语言，左闭区间是合适的。</p><p>右开右闭都是可行的，只需要在循环判断时做一下调整</p><ul><li>[l, r] -> l &lt; r + 1</li><li>[l, r) -> l &lt; r</li></ul><p>一般来说，我们都会选择 <code>l = 0 & [l, r)</code> 这种组合。</p><ol start=3><li>循环结束条件是 <code>&lt;</code> 还是 <code>&lt;=</code> 还是 <code>!=</code></li></ol><p><code>&lt;</code> 和 <code>!=</code> 都可以，对于非递减序列来说，一般用 <code>&lt;</code>。</p><p>如果 <code>l = r</code> 时，仍然进入循环，同时如果 <code>array[l] >= target</code>，会导致循环无法退出。</p><ol start=4><li>区间中间计算</li></ol><p><code>l + (r - l + 1) / 2</code> 这就属于是 <code>ceil</code> 操作。这个在前面也解释过，不再赘述。</p><ol start=5><li>判断条件</li></ol><p>同样的，取决于问题是取最左边的位置还是最右边的，上一节也解释过。</p><ol start=6><li>返回值</li></ol><p>结束条件是 <code>l == r</code>，所以返回 <code>l</code> 没有问题。但是这个位置并不一定能满足 <code>array[l] == target</code>，甚至于可能越界。</p><p>返回值 <code>l</code> 表示：<code>[0, l)</code> 位置都是小于 <code>target</code> 的，而 <code>[l, len)</code> 则是大于等于 <code>target</code> 的。这里 <code>l</code> 可能等于 <code>len</code> (越界)。</p><blockquote><p>所以在使用二分查找，来判断 target 是否存在时，要注意判断是否越界。</p></blockquote><p>作者最后给了一种通用解决方案，将判断逻辑变成一个闭包方法作为参数传入，这样就可以得出多个二分变种问题的解法。</p><h2 id=总之 class=headerLink><a href=#%e6%80%bb%e4%b9%8b class=header-mark></a>总之</h2><p>可见，想写对二分不容易，那么我们只记一种正确的写法，归纳成模板即可</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># template</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>_bsearch</span><span class=p>(</span><span class=n>a</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>x</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>l</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>r</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=kc>None</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=n>r</span> <span class=ow>or</span> <span class=nb>len</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>l</span> <span class=o>&lt;</span> <span class=n>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>=</span> <span class=n>l</span> <span class=o>+</span> <span class=p>(</span><span class=n>r</span> <span class=o>-</span> <span class=n>l</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>a</span><span class=p>[</span><span class=n>m</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span> <span class=o>=</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span>
</span></span></code></pre></div><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98 target=_blank rel="noopener noreffer">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Binary_search_algorithm target=_blank rel="noopener noreffer">https://en.wikipedia.org/wiki/Binary_search_algorithm</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=http://www.cplusplus.com/reference/algorithm/binary_search/ target=_blank rel="noopener noreffer">http://www.cplusplus.com/reference/algorithm/binary_search/</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer><div class=post><div class=post-share><div class=share-link><a class="share-icon share-twitter" href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://ryderfang.com/binary-search/ data-title=很难写“正确”的二分查找 data-via=ryderfang data-hashtags=search><span class="svg-social-icon icon-twitter"></span></a></div><div class=share-link><a class="share-icon share-facebook" href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://ryderfang.com/binary-search/ data-hashtag=search><span class="svg-social-icon icon-facebook"></span></a></div><div class=share-link><a class="share-icon share-weibo" href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://ryderfang.com/binary-search/ data-title=很难写“正确”的二分查找><span class="svg-social-icon icon-weibo"></span></a></div></div><div class=block-author><div class=author-avatar><a href=https://github.com/ryderfang/ target=_blank><img alt="人生如逆旅，我亦是行人。 ── 宋·苏轼 《临江仙·送钱穆父》" src=https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2021-11-05-avatar2.jpg></a></div><div class=author-info><div class=name><a href=https://github.com/ryderfang/ target=_blank></a></div><div class=number-posts>人生如逆旅，我亦是行人。 ── 宋·苏轼 《临江仙·送钱穆父》</span></div></div></div><div class=post-tags><a href=/tags/search/ class=tag>search</a></div></div></footer></div><div id=toc-final></div></div></article><section class="page single comments content-block-position"><h1 class=display-hidden>Комментарии</h1><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></section></div></main><footer class=footer><div class=footer-container><div class=footer-line>© 2016 - 2022 Ryder Fang · &lt;/> Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a> and <a href=https://github.com/uPagge/uBlogger target=_blank>uBlogger</a></div><div class=footer-line><span class=license><a href=https://opensource.org/licenses/MIT/ target=_blank>MIT</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href=https://beian.miit.gov.cn/ target=_blank rel=noopener><u>沪ICP备2021031507号-1</u></a></span></div></div></footer></div><aside id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="svg-icon icon-arrow-up"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="svg-icon icon-comments-fixed"></i></a></aside><script src=/lib/smooth-scroll/smooth-scroll.min.js></script><script src=/lib/autocomplete/autocomplete.min.js></script><script src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script src=/lib/clipboard/clipboard.min.js></script><script src=/lib/sharer/sharer.min.js></script><script src=/lib/prismjs/prism.js></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"Utterances",lightTheme:"github-light",repo:"ryderfang/ryderfang.github.io"}},search:{algoliaAppID:"KNWHHR2LLW",algoliaIndex:"ryder_blog",algoliaSearchKey:"99980e3c2014fb8c463a83c546a3f4a6",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"}}</script><script src=/js/theme.min.js></script></body></html>