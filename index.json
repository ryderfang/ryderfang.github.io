[{"categories":["Algorithm"],"content":"“二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 O(log n)，空间复杂度 O(1)，相比线性搜索优秀太多。 但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本1能准确写对“二分”查找。 尽管二分查找的基本思想相对简单，但细节可以令人难以招架 … — 高德纳 二分查找的前提是待查找的序列是有序的。 本身算法逻辑非常简单2： function binary_search(A, n, T) is L := 0 R := n − 1 while L ≤ R do m := floor((L + R) / 2) if A[m] \u003c T then L := m + 1 else if A[m] \u003e T then R := m − 1 else: return m return unsuccessful ","date":"2022-03-08","objectID":"/binary-search/:0:0","tags":["search"],"title":"很难写“正确”的二分查找","uri":"/binary-search/"},{"categories":["Algorithm"],"content":"减少一次判断上述伪代码每次循环都会比较 mid 与 target 是否相等，如果去掉这个比较，将之放到循环退出时，就可以在每次循环中减少一次比较，总得循环次数仅比上面的算法多一次。 function binary_search_alternative(A, n, T) is L := 0 R := n − 1 while L != R do m := ceil((L + R) / 2) if A[m] \u003e T then R := m − 1 else: L := m if A[L] = T then return L return unsuccessful ","date":"2022-03-08","objectID":"/binary-search/:1:0","tags":["search"],"title":"很难写“正确”的二分查找","uri":"/binary-search/"},{"categories":["Algorithm"],"content":"关于 cell 和 floor可以看出来，上面两个实现中在取 mid 时使用了不同的方法，一个是 floor()，一个是 ceil()， floor((0 + 1) / 2) = 0 ceil((0 + 1) / 2) = 1 为什么会有这个不同呢？在 StackOverflow 上有很好的解释： 如果更新二元组 (l, r) -\u003e (m + 1, m - 1) 时，这两种方法都可以，结果是一样的。 如果是 (l, r) -\u003e (m, m - 1) 时，必须要使用 ceil，否则循环无法退出。比如 l = 0, r = 1, A = [1, 2]， target = 2 时，floor 会导致 l 一直被更新为 0，无法退出。 如果是 (l, r) -\u003e (m + 1, m) 时，必须要使用 floor，否则同时循环无法退出。比如 l = 0, r = 1, A = [1, 2]，target = 1 时，ceil 会导致 r 一直被更新成 1。 总之，就是更新下边界更多时，使用 floor，更新上边界更多时，使用 ceil。 ","date":"2022-03-08","objectID":"/binary-search/:2:0","tags":["search"],"title":"很难写“正确”的二分查找","uri":"/binary-search/"},{"categories":["Algorithm"],"content":"关于溢出上述算法中还有一个问题，计算 mid = floor((L + R) / 2) 存在可能的溢出错误，这在 C++ 中比较常见，比如 l = r = 2^31-1，相加就会溢出整数范围！ 正常的写法是： mid = l + (r - l) // 2 ","date":"2022-03-08","objectID":"/binary-search/:3:0","tags":["search"],"title":"很难写“正确”的二分查找","uri":"/binary-search/"},{"categories":["Algorithm"],"content":"如果有重复元素如果序列中存在重复元素，比如 [1, 2, 3, 3, 3, 4, 5]，要查找 T = 3，可能会有多个结果。 如果只是判断 target 是否存在，上述的算法都没有问题。但是如果想找到 index 最小或最大的 target 位置，算法就需要做一些修改。 参考 C++ 标准库中的 std::binary_search 的实现3： template \u003cclass ForwardIterator, class T\u003e bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026 val) { first = std::lower_bound(first,last,val); return (first!=last \u0026\u0026 !(val\u003c*first)); } 调用了 std::lower_bound() 方法，这个方法就是在一个序列中找值为 val 的最小 index 位置，同理还有一个找最大 index 方法的函数 std::upper_bound() template \u003cclass ForwardIterator, class T\u003e ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T\u0026 val) { ForwardIterator it; iterator_traits\u003cForwardIterator\u003e::difference_type count, step; count = distance(first,last); while (count\u003e0) { it = first; step=count/2; advance (it,step); if (*it\u003cval) { // or: if (comp(*it,val)), for version (2) first=++it; count-=step+1; } else count=step; } return first; } template \u003cclass ForwardIterator, class T\u003e ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T\u0026 val) { ForwardIterator it; iterator_traits\u003cForwardIterator\u003e::difference_type count, step; count = std::distance(first,last); while (count\u003e0) { it = first; step=count/2; std::advance (it,step); if (!(val\u003c*it)) // or: if (!comp(val,*it)), for version (2) { first=++it; count-=step+1; } else count=step; } return first; } 区别就是在更新 left = mid + 1 时，如果想取左边界，条件是 mid \u003c val；如果想取右边界，条件是 mid \u003c= val。 ","date":"2022-03-08","objectID":"/binary-search/:4:0","tags":["search"],"title":"很难写“正确”的二分查找","uri":"/binary-search/"},{"categories":["Algorithm"],"content":"处处是坑知乎有一篇专栏文章：\u003c聊聊一看就会一写就跪的二分查找\u003e讲了二分中的各个坑点，我们逐一看一下： func FirstGreaterOrEqual(array []int, target int) int { // 初始化区间左端点： -1 || 0 || 1 ？ l := 0 // 初始化区间右端点： len(array) - 1 || len(array) || len(array) + 1 ? r := len(array) // 当区间不为空时循环： l + 1 \u003c r || l \u003c r || l \u003c= r || l \u003c= r + 1 ? for l \u003c r { // 计算区间中点： l + (r - l) / 2 || l + (r - l + 1) / 2 ? m := l + (r - l) / 2 // 将中点对应的元素同target比较： \u003e || \u003e= || \u003c || \u003c= ? if array[m] \u003c target { // 继续查找右侧这一半： m - 1 || m || m + 1 ? l = m + 1 } else { // 继续查找左侧这一半： m - 1 || m || m + 1 ? r = m } } // 这里应该是 l - 1 || l || l + 1 ? // 这里应该是 r - 1 || r || r + 1 ? return l } 这是一段 go 语言代码，不过不影响理解它的逻辑，其实它就是在 array 中找 target 的左边界。 来一一解释作者提出的这些坑： 区间左端点 l = 0 或者其他？ 区间右端点 r = len(array) 还是 len(array) - 1？ 这两个是一个问题，整个区间有四种状态 (l, r) [l, r] (l, r] [l, r] 对于数组从 0 开始的语言，左闭区间是合适的。 右开右闭都是可行的，只需要在循环判断时做一下调整 [l, r] -\u003e l \u003c r + 1 [l, r) -\u003e l \u003c r 一般来说，我们都会选择 l = 0 \u0026 [l, r) 这种组合。 循环结束条件是 \u003c 还是 \u003c= 还是 != \u003c 和 != 都可以，对于非递减序列来说，一般用 \u003c。 如果 l = r 时，仍然进入循环，同时如果 array[l] \u003e= target，会导致循环无法退出。 区间中间计算 l + (r - l + 1) / 2 这就属于是 ceil 操作。这个在前面也解释过，不再赘述。 判断条件 同样的，取决于问题是取最左边的位置还是最右边的，上一节也解释过。 返回值 结束条件是 l == r，所以返回 l 没有问题。但是这个位置并不一定能满足 array[l] == target，甚至于可能越界。 返回值 l 表示：[0, l) 位置都是小于 target 的，而 [l, len) 则是大于等于 target 的。这里 l 可能等于 len (越界)。 所以在使用二分查找，来判断 target 是否存在时，要注意判断是否越界。 作者最后给了一种通用解决方案，将判断逻辑变成一个闭包方法作为参数传入，这样就可以得出多个二分变种问题的解法。 ","date":"2022-03-08","objectID":"/binary-search/:5:0","tags":["search"],"title":"很难写“正确”的二分查找","uri":"/binary-search/"},{"categories":["Algorithm"],"content":"总之可见，想写对二分不容易，那么我们只记一种正确的写法，归纳成模板即可 # template def _bsearch(a: List[int], x: int, l: int = 0, r: int = None) -\u003e int: r = r or len(a) while l \u003c r: m = l + (r - l) // 2 if a[m] \u003c x: l = m + 1 else: r = m return l https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98 ↩︎ https://en.wikipedia.org/wiki/Binary_search_algorithm ↩︎ http://www.cplusplus.com/reference/algorithm/binary_search/ ↩︎ ","date":"2022-03-08","objectID":"/binary-search/:6:0","tags":["search"],"title":"很难写“正确”的二分查找","uri":"/binary-search/"},{"categories":["ObjC"],"content":"获取 Class 对象的方法有很多，本文主要是收集整理它们的区别以及探究具体的实现。 ","date":"2022-02-23","objectID":"/get-class/:0:0","tags":["ObjC","Runtime"],"title":"获取 OC Class 对象","uri":"/get-class/"},{"categories":["ObjC"],"content":"class 方法有两种 class 方法，一个是实例方法，一个是类方法： @interface NSObject \u003cNSObject\u003e - (Class)class OBJC_SWIFT_UNAVAILABLE(\"use 'type(of: anObject)' instead\"); + (Class)class OBJC_SWIFT_UNAVAILABLE(\"use 'aClass.self' instead\"); @end 查看 runtime 的源码：NSObject.mm 可以看到它们的实现： + (id)self { return (id)self; } - (id)self { return self; } + (Class)class { return self; } - (Class)class { return object_getClass(self); } 所以，说给类对象发 class 消息，得到的是类本身 self，也就是 [NSObject class] == [NSObject self] 给实例对象发 class 消息，相当于调用了 object_getClass ","date":"2022-02-23","objectID":"/get-class/:1:0","tags":["ObjC","Runtime"],"title":"获取 OC Class 对象","uri":"/get-class/"},{"categories":["ObjC"],"content":"object_getClass那么这个方法的实现是怎么样的呢？ 同样查看 runtime 源码：objc-class.mm Class _Nullable object_getClass(id _Nullable obj) Class object_getClass(id obj) { if (obj) return obj-\u003egetIsa(); else return Nil; } 调用了 类的 getIsa() 方法 // objc-object.h inline Class objc_object::getIsa() { if (!isTaggedPointer()) return ISA(); uintptr_t ptr = (uintptr_t)this; if (isExtTaggedPointer()) { uintptr_t slot = (ptr \u003e\u003e _OBJC_TAG_EXT_SLOT_SHIFT) \u0026 _OBJC_TAG_EXT_SLOT_MASK; return objc_tag_ext_classes[slot]; } else { uintptr_t slot = (ptr \u003e\u003e _OBJC_TAG_SLOT_SHIFT) \u0026 _OBJC_TAG_SLOT_MASK; return objc_tag_classes[slot]; } } ","date":"2022-02-23","objectID":"/get-class/:2:0","tags":["ObjC","Runtime"],"title":"获取 OC Class 对象","uri":"/get-class/"},{"categories":["ObjC"],"content":"objc_getClass这个方法和上面的 object_getClass 长得很像，但还是有一些区别： 参数不一样，一个是 id，一个是 const char *，也就是一个传入是个类对象，一个是类名 实现不一样，一个调用的是 obj-\u003egetIsa()，一个调用的是 loop_up_class() // objc-runtime.mm Class objc_getClass(const char *aClassName) { if (!aClassName) return Nil; // NO unconnected, YES class handler return look_up_class(aClassName, NO, YES); } 调用了 look_up_class: // objc-runtime-new.mm Class look_up_class(const char *name, bool includeUnconnected __attribute__((unused)), bool includeClassHandler __attribute__((unused))) { if (!name) return nil; Class result; bool unrealized; { runtimeLock.lock(); result = getClassExceptSomeSwift(name); unrealized = result \u0026\u0026 !result-\u003eisRealized(); if (unrealized) { result = realizeClassMaybeSwiftAndUnlock(result, runtimeLock); // runtimeLock is now unlocked } else { runtimeLock.unlock(); } } if (!result) { // Ask Swift about its un-instantiated classes. // We use thread-local storage to prevent infinite recursion // if the hook function provokes another lookup of the same name // (for example, if the hook calls objc_allocateClassPair) auto *tls = _objc_fetch_pthread_data(true); // Stop if this thread is already looking up this name. for (unsigned i = 0; i \u003c tls-\u003eclassNameLookupsUsed; i++) { if (0 == strcmp(name, tls-\u003eclassNameLookups[i])) { return nil; } } // Save this lookup in tls. if (tls-\u003eclassNameLookupsUsed == tls-\u003eclassNameLookupsAllocated) { tls-\u003eclassNameLookupsAllocated = (tls-\u003eclassNameLookupsAllocated * 2 ?: 1); size_t size = tls-\u003eclassNameLookupsAllocated * sizeof(tls-\u003eclassNameLookups[0]); tls-\u003eclassNameLookups = (const char **) realloc(tls-\u003eclassNameLookups, size); } tls-\u003eclassNameLookups[tls-\u003eclassNameLookupsUsed++] = name; // Call the hook. Class swiftcls = nil; if (GetClassHook.get()(name, \u0026swiftcls)) { ASSERT(swiftcls-\u003eisRealized()); result = swiftcls; } // Erase the name from tls. unsigned slot = --tls-\u003eclassNameLookupsUsed; ASSERT(slot \u003e= 0 \u0026\u0026 slot \u003c tls-\u003eclassNameLookupsAllocated); ASSERT(name == tls-\u003eclassNameLookups[slot]); tls-\u003eclassNameLookups[slot] = nil; } return result; } ","date":"2022-02-23","objectID":"/get-class/:3:0","tags":["ObjC","Runtime"],"title":"获取 OC Class 对象","uri":"/get-class/"},{"categories":["ObjC"],"content":"NSClassFromString这个在 Foundation.framework 中的实现，并没有开源， 函数原型是 FOUNDATION_EXPORT Class _Nullable NSClassFromString(NSString *aClassName); 与 objc_getClass 参数一样，传入 Class 的名字，返回 Class 地址。 有大佬通过研究汇编分析出它的具体实现：从汇编代码探究 NSClassFromString 实现 最后，做个试验： Student *stu = [Student new]; Class cls = [stu class]; NSLog(@\"%p %p %p %p %p\", cls, [Student class], objc_getClass(\"Student\"), object_getClass(stu), NSClassFromString(@\"Student\")); 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 可以看出来，这四种方法拿到的结果是一样的。 ","date":"2022-02-23","objectID":"/get-class/:4:0","tags":["ObjC","Runtime"],"title":"获取 OC Class 对象","uri":"/get-class/"},{"categories":["ObjC"],"content":"Meta 这个词在 2021 年下半年开始火爆，而后 Facebook 改名 Meta 引发各大科技公司跟风押注。似乎全球资本都在追逐“元宇宙”的概念，但什么是“元宇宙”，各家有各家的说法，没有一个统一的标准。 我个人感觉，元宇宙就是个伪概念。除了一堆跟风炒概念准备割韭菜的老庄家和引颈待收割的韭菜外，各个公司在做的与“元宇宙”相关的事，似乎都是一些“复古网络游戏”。 历史是一个轮回，唯有资本逐利是永恒的。不出三年，这个概念应该就不会有人提了，一如 VR 的喧嚣与沉寂。 ","date":"2022-02-14","objectID":"/meta-class/:0:0","tags":["ObjC","Runtime"],"title":"从 Meta 说起","uri":"/meta-class/"},{"categories":["ObjC"],"content":"Meta 的起源以上只是个引子，与本文无关 \u003c生硬的转折 😅\u003e。本文继续讨论 Runtime，聚焦 OC 中的 MetaClass。 Greg Parker 经典图 ","date":"2022-02-14","objectID":"/meta-class/:1:0","tags":["ObjC","Runtime"],"title":"从 Meta 说起","uri":"/meta-class/"},{"categories":["ObjC"],"content":"为什么要这么设计由于 OC 是 Smalltalk 语言哲学的一种实践，“在 Smalltalk 中，所有的值都是对象”。因此一个实例是对象，它的类也是一个对象。 实例中的 isa 指针指向了它的类对象，那么类对象的 isa 指针指向谁呢？—— 指向它的元类对象 MetaClass！ Since a class is an object, it must be an instance of some other class: a metaclass. 1 那么能不能不这么设计呢？ 当然能，但是这样就不那么 “Smalltalk” 了。非 Smalltalk 语言如 C++，与 OC 的一个重要区别是： C++ 支持多重继承 ","date":"2022-02-14","objectID":"/meta-class/:2:0","tags":["ObjC","Runtime"],"title":"从 Meta 说起","uri":"/meta-class/"},{"categories":["ObjC"],"content":"Meta 与 继承关系定义一对父类与子类： @interface Person : NSObject @end @interface Student : Person @end package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } ","date":"2022-02-14","objectID":"/meta-class/:3:0","tags":["ObjC","Runtime"],"title":"从 Meta 说起","uri":"/meta-class/"},{"categories":["ObjC"],"content":"isa 链定义一个子类的实例 Student *stu，根据之前的文章 class-object-isa，实例本质上是一个 objc_object 结构体，内部存在一个 isa 指针，指向的是 Student 这个类对象。 而类对象 Student 本质上是一个 objc_class 结构体，继承自 objc_object，所以内部也有一个 isa 指针，类对象的 isa 指针指向的是它的元类对象。 所以，这条链，也就是上图中最下面一行虚线所示： 实例 –\u003e 类 –\u003e 元类 那么元类的 isa 又指向谁呢，图中显示的是 根元类，通过代码来获取一下这条链： Student *stu = [Student new]; NSLog(@\"Student instance addr: %p\", stu); Class cls = [stu class]; NSLog(@\"Student class addr: %p\", cls); id rootMetaClass = nil; while (cls) { NSLog(@\"isa: %s addr: %p\", object_getClassName(cls), cls); Class tmp = object_getClass(cls); if (tmp == cls) { rootMetaClass = cls; break; } cls = tmp; } NSLog(@\"root MetaClass: %p\", rootMetaClass); –\u003e Student instance addr: 0x100668810 Student class addr: 0x10000e7b8 isa: Student addr: 0x10000e7b8 isa: NSObject addr: 0x10000e790 isa: NSObject addr: 0x7fff806e7060 root MetaClass: 0x7fff806e7060 可以看出来，元类对象最终指向的是根元类对象，但它的名字也叫 NSObject，同时根元类的 isa 是指向自身的，所以最终形成了闭环。 实例 –\u003e 类 –\u003e 元类 –\u003e 根元类 ↩️ ","date":"2022-02-14","objectID":"/meta-class/:3:1","tags":["ObjC","Runtime"],"title":"从 Meta 说起","uri":"/meta-class/"},{"categories":["ObjC"],"content":"继承链再来看一下继承关系， Class cls = [stu class]; id rootClass = nil; while (cls) { NSLog(@\"class: %s addr: %p\", object_getClassName(cls), cls); if (!class_getSuperclass(cls)) { rootClass = cls; } cls = class_getSuperclass(cls); } NSLog(@\"rootClass: %p\", rootClass); –\u003e class: Student addr: 0x10000e7b8 class: Person addr: 0x10000e768 class: NSObject addr: 0x7fff806e7088 rootClass: 0x7fff806e7088 继承链比较简单： 子类 -\u003e 父类 -\u003e 根类 -\u003e nil 可以看出来根类没有父类，顺便我们看一下根类的 isa 指向哪里？ NSLog(@\"rootClass'isa: %p\", object_getClass(rootClass)); // rootClass'isa: 0x7fff806e7060 地址 0x7fff806e7060 与前面根元类 rootMetaClass 一样，这也证实了 根类 --\u003e 根元类。 http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html ↩︎ ","date":"2022-02-14","objectID":"/meta-class/:3:2","tags":["ObjC","Runtime"],"title":"从 Meta 说起","uri":"/meta-class/"},{"categories":["ObjC"],"content":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。 参考 OC 编译过程 我们可以借助 clang 工具将 OC 源码预处理成 CPP 来窥探 OC 的内部实现。 定义一个简单的类： @interface Foo : NSObject @property (nonatomic, assign) BOOL ppty1; @property (nonatomic, copy) NSString *ppty2; - (BOOL)iMethod1; - (void)iMethod2:(NSString *)p1; + (void)cMethod1; @end 通过命令 clang -rewrite-objc xx.m 得到一个 9 万多行的 cpp 文件 😱 https://gist.github.com/ryderfang/75a852f1ae0961aeea97127f7d9ca6c5 ","date":"2022-01-04","objectID":"/class-object-isa/:0:0","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"TL;DR太长不看版： 🧸 objc_object 是所有实例对象的底层结构，内部只有一个 isa 🎁 objc_class 是所有类/元类对象的底层结构，它也有一个 isa 指针，指向自己的元类 OC 1.0 OC 2.0 id 实例 typedef struct objc_object *id; typedef struct objc_object *id; objc_object struct objc_object {} struct objc_object {} Class 类 typedef struct objc_class *Class; typedef struct objc_class *Class; objc_class struct objc_class {} struct objc_class : objc_object {} ","date":"2022-01-04","objectID":"/class-object-isa/:1:0","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"Class 是什么","date":"2022-01-04","objectID":"/class-object-isa/:2:0","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"Class 1.0在 \u003cobjc/objc.h\u003e 中有这样一行： typedef struct objc_class *Class; 在 iOS 15 之前 \u003cobjc/runtime.h\u003e 中曾经有 objc_class 的定义： https://opensource.apple.com/source/objc4/objc4-750/runtime/runtime.h.auto.html /* Types */ #if !OBJC_TYPES_DEFINED struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; /* Use `Class` instead of `struct objc_class *` */ #endif 目前我使用的 Xcode 13.2.1 中已经找不到这个定义，也就是说在 macOS 12.1 / iOS 15.2 中，OBJC1 已经被完全废弃。 Hint: 按照官方文档 Runtime Version 的解释, legacy 版本 (OC 1.0) 在 2007 年就完全废弃了，所有 iPhone 和 OSX 10.5 以后的 Mac 上使用的都是 modern 版本 (OC 2.0)! 技巧 根据 wiki 的说明，OC 2.0 于 2006 年发布，而 iPhone 第一代 是在 2007 年发布的，Mac OS X 10.5 Leopard 也是在 2007 年上市。 从这个宏 OBJC2_UNAVAILABLE 可以看出来 OBJC2 这种定义会失效。那么 OBJC2 是什么？ ","date":"2022-01-04","objectID":"/class-object-isa/:2:1","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"Class 2.0在 objc-runtime-new.h 中定义了 objc_class 的 2.0 版本： struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... } 参考 1 和 2 了解到，苹果在 2006 年重写了 runtime，发布了新的 Runtime 2.0，那么 __OBJC2__ 这个宏是什么时候生效的呢？ 通过查找苹果公开的 runtime 源码：https://opensource.apple.com/source/objc4/ 发现： 从 objc4-750 这个版本开始，在 objc-config.h 中开始有了 __OBJC2__ 的定义！ // Define __OBJC2__ for the benefit of our asm files. #ifndef __OBJC2__ # if TARGET_OS_OSX \u0026\u0026 !TARGET_OS_IOSMAC \u0026\u0026 __i386__ // old ABI # else # define __OBJC2__ 1 # endif #endif 来自 apple 的 commit： https://github.com/apple-oss-distributions/objc4/commit/26c7408b94ead1f04a0b5976e354a03966ce61ea 在 objc-api.h 中定义了 OBJC_ISA_AVAILABILITY: /* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable * in the future */ #if !defined(OBJC_ISA_AVAILABILITY) # if __OBJC2__ # define OBJC_ISA_AVAILABILITY __attribute__((deprecated)) # else # define OBJC_ISA_AVAILABILITY /* still available */# endif #endif 在 objc-private.h 中同时定义了 OBJC_TYPES_DEFINED: /* Isolate ourselves from the definitions of id and Class in the compiler * and public headers. */ #ifdef _OBJC_OBJC_H_ #error include objc-private.h before other headers #endif #define OBJC_TYPES_DEFINED 1 同时也定义了 Class 和 id typedef struct objc_class *Class; typedef struct objc_object *id; 所以，不管 OC 1.0 还是 2.0， Class 都是一个叫 objc_class 的结构体指针。 ","date":"2022-01-04","objectID":"/class-object-isa/:2:2","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"Object 与 id在 \u003cobjc/objc.h\u003e 中，定义 https://opensource.apple.com/source/objc4/objc4-750/runtime/objc.h.auto.html ","date":"2022-01-04","objectID":"/class-object-isa/:3:0","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"Object 1.0#if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; #endif 同样被包在 OBJC_TYPES_DEFINED 宏中，也就是 OC 2.0 并不生效。 那么，OC 2.0 的 objc_object 是什么样的呢，在 objc-private.h 中定义了： ","date":"2022-01-04","objectID":"/class-object-isa/:3:1","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"Object 2.0struct objc_object { private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ // initClassIsa(): class objects // initProtocolIsa(): protocol objects // initIsa(): other objects void initIsa(Class cls /*nonpointer=false*/); void initClassIsa(Class cls /*nonpointer=maybe*/); void initProtocolIsa(Class cls /*nonpointer=maybe*/); void initInstanceIsa(Class cls, bool hasCxxDtor); // 省略大量方法 private: void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor); // 省略大量方法` }; 可以看出来不管 OC 1.0 还是 2.0, objc_object 都是一个包含着一个叫 isa 指针/变量 的对象。 ","date":"2022-01-04","objectID":"/class-object-isa/:3:2","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["ObjC"],"content":"isa 又是什么在 1.0 版本中 isa 就是一个 Class 对象，也就是一个指向 objc_class 的指针，而在 2.0 时，isa 是一个叫 isa_t 的结构体变量。 那么 isa_t 是什么呢？ 同样在 objc-private.h 中有定义： union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } uintptr_t bits; private: // Accessing the class requires custom ptrauth operations, so // force clients to go through setClass/getClass by making this // private. Class cls; public: #if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h }; bool isDeallocating() { return extra_rc == 0 \u0026\u0026 has_sidetable_rc == 0; } void setDeallocating() { extra_rc = 0; has_sidetable_rc = 0; } #endif void setClass(Class cls, objc_object *obj); Class getClass(bool authenticated); Class getDecodedClass(bool authenticated); }; 参考 1 的图： 作为一个 union 结构，与 struct 区别在于，成员之间会互相覆盖，union 的总内存占用等于最大的成员占用的内存大小，而 struct 大小至少是成员内存占用之和，如果需要字节对齐则会更大。 所以采用 union 结构可以节省内存。 在 objc-object.h 中，有 objc_object::initIsa() 的实现： inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { ASSERT(!isTaggedPointer()); if (!nonpointer) { isa = isa_t((uintptr_t)cls); } else { ASSERT(!DisableNonpointerIsa); ASSERT(!cls-\u003einstancesRequireRawIsa()); isa_t newisa(0); #if SUPPORT_INDEXED_ISA ASSERT(cls-\u003eclassArrayIndex() \u003e 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-\u003eclassArrayIndex(); #else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls \u003e\u003e 3; #endif // This write must be performed in a single store in some cases // (for example when realizing a class because other threads // may simultaneously try to use the class). // fixme use atomics here to guarantee single-store and to // guarantee memory order w.r.t. the class index table // ...but not too atomic because we don't want to hurt instantiation isa = newisa; } } 可以看出 isa_t 中的 Class 与 bits 是互斥的，避免了互相覆盖的问题。 https://halfrost.com/objc_runtime_isa_class/ ↩︎ https://kangzubin.com/objc1.0-class-object/ ↩︎ ","date":"2022-01-04","objectID":"/class-object-isa/:4:0","tags":["ObjC","Runtime"],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["Optimize"],"content":"本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章： Responding to the Launch of Your App 有个主要的流程图： 另外，还有一篇介绍如何优化启动速度的文章，毕竟只有准确了解了启动中做了哪些事，才能更针对地进行优化。 Reducing Your App’s Launch Time 这里还参考了以下几篇文章： [1]: iOS App 启动优化 [2]: iOS App 从点击到启动 [3]: 深入了解 App 启动过程 总结一下： ","date":"2021-12-28","objectID":"/app-launch-process/:0:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"系统层","date":"2021-12-28","objectID":"/app-launch-process/:1:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"pre-main 阶段","date":"2021-12-28","objectID":"/app-launch-process/:2:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"main 方法","date":"2021-12-28","objectID":"/app-launch-process/:3:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"首屏渲染后","date":"2021-12-28","objectID":"/app-launch-process/:4:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["ObjC"],"content":"概述Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。 当我们在讲 Runtime 的时候，我们在说什么？ 根据官方文档的定义， Objective-C Runtime Objective-C Runtime Programming Guide Runtime 是一个动态库 (/usr/lib/libobjc.A.dylib)，用于实现 OC 语言的动态性。 这个动态性主要体现在三个方面 1: Dynamic Typing 运行时才能决定对象的类型，也就是说编译器不检查类型合法性 Dynamic Binding 运行时才能知道方法被如何执行，也就是消息机制 (messaging) Dynamic Loading 允许动态添加类、方法等 ","date":"2021-12-28","objectID":"/what-is-runtime/:1:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"起源孙源大佬在 博客 中说过，OC2 其实是 C 语言与 SmallTalk3 思想结合的产物。 与同属 SmallTalk 学派的语言 Java, Python 和 Ruby 一样，OC 具有面向对象、动态类型和反射式等特点。 Objective-C = C + Preprocessor + Runtime SmallTalk 领先了时代 20 年，至今 OC 仍然没有实现它的全部特性。 ","date":"2021-12-28","objectID":"/what-is-runtime/:2:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Runtime Version存在两个版本的 Runtime，modern 和 legacy： https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html#//apple_ref/doc/uid/TP40008048-CH106-SW1 按照官方的说明，所有 iPhone 和 10.5 版本之后的 Mac OSX 64 位程序都使用的 OC 2.0。 Runtime 源码: https://opensource.apple.com/source/objc4/ 下载 tarballs: https://opensource.apple.com/tarballs/objc4/ 可调试项目: https://github.com/RetVal/objc-runtime ","date":"2021-12-28","objectID":"/what-is-runtime/:3:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Runtime 里有什么Runtime 的源码可以在 RetVal/objc-runtime 这里找到，甚至可以 Debug。 主要包含如下几个方面，后续会逐个总结。 ","date":"2021-12-28","objectID":"/what-is-runtime/:4:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Class/Object 与 isa参考：Class Object 与 isa ","date":"2021-12-28","objectID":"/what-is-runtime/:4:1","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"MetaClass 元类指向链: 实例 -\u003e 类 -\u003e 元类 -\u003e 根元类 -\u003e 根元类 (isa 指向自己) 类的继承链: 子类 -\u003e 父类 -\u003e NSObject -\u003e nil 元类的继承链: 子类元类 -\u003e 父类元类 -\u003e 根元类 -\u003e NSObject -\u003e nil 参考：从 Meta 说起 ","date":"2021-12-28","objectID":"/what-is-runtime/:4:2","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Method/IMP/SEL","date":"2021-12-28","objectID":"/what-is-runtime/:4:3","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Category","date":"2021-12-28","objectID":"/what-is-runtime/:4:4","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Messaging","date":"2021-12-28","objectID":"/what-is-runtime/:4:5","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Swizzling","date":"2021-12-28","objectID":"/what-is-runtime/:4:6","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"其它常用方法++++++ https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html ↩︎ https://zh.wikipedia.org/wiki/Objective-C ↩︎ https://zh.wikipedia.org/zh-hans/Smalltalk ↩︎ ","date":"2021-12-28","objectID":"/what-is-runtime/:4:7","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"很早之前看过一个 前端 Roadmap，图做的非常漂亮。最近发现有人做了类似的 移动端 Roadmap， 其中 iOS 是这样的： 还有 Swift 的，暂时先不关注了。这里综合一下形成文字版，方面查缺补漏。 iOS 的体系结构如下图： Ref: iOS abstraction layers 需要重点关注的有下面几个方面： ","date":"2021-12-23","objectID":"/objc-roadmap/:0:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Foundation","date":"2021-12-23","objectID":"/objc-roadmap/:1:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"I. ARC/MRC 3️⃣ARC is supported in Xcode 4.2 for OS X v10.6 and v10.7 (64-bit applications) and for iOS 4 and iOS 5. 现在除了一些老项目，基本没有 MRC 为主的代码了，所以只需要简单了解下 MRC 与 ARC 的区别即可 MRC 需要手动写 dealloc，并且一定要最后再调用父类的 dealloc； ARC 一般不需要写 dealloc，也不需要调用 [super dealloc]。移除 NSNotification Observer 和 KVC Observer 例外。 在 ARC 的工程中使用 MRC，需要在工程中设置源文件的编译选项 -fno-objc-arc ","date":"2021-12-23","objectID":"/objc-roadmap/:1:1","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"II. AutoReleasePool 4️⃣ AutoReleasePool 的数据结构 AutoReleasePool 与 @autoreleasepool ","date":"2021-12-23","objectID":"/objc-roadmap/:1:2","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"III. Block 5️⃣ block 的结构体类型 block 如何捕获外部变量 循环引用 与 Weak-Strong Dance ","date":"2021-12-23","objectID":"/objc-roadmap/:1:3","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"IV. Category 5️⃣ load 加载时机 load 与 initialze category 覆盖原类方法的原理 category 同名方法调用顺序 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:4","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"V. HotPatch 1️⃣ JSPatch 的原理 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:5","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"VI. KVC 2️⃣ KVC 是如何实现的 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:6","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"VII. KVO 4️⃣ KVO 的原理 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:7","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"VIII. MultiThread 4️⃣ 哪些多线程方法 互斥锁与自旋锁 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:8","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"IX. Network 3️⃣ NSURLSession 与 NSURLConnection ","date":"2021-12-23","objectID":"/objc-roadmap/:1:9","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"X. NSTimer 5️⃣ timer 与 Runloop timer 导致循环引用的产生与解决 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:10","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"XI. Property 5️⃣ 不同属性的区别 weak 与 copy atomic 并不是线程安全的 如何实现一个弱引用容器 + [NSPointerArray weakObjectsPointerArray] 弱引用数组 + [NSMapTable weakToWeakObjectsMapTable] 弱引用表 + [NSHashTable weakObjectsHashTable] 弱引用 hash 表 + [NSValue valueWithNonretainedObject:] 弱引用对象 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:11","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"XII. Runloop 4️⃣ Runloop 与线程的关系 如何实现一个常驻线程 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:12","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"XIII. Runtime 5️⃣一图胜千言，引用 Runtime 工程师 Greg Parker 在其博客中给出的经典图 系列文章：Runtime 是个啥？ ","date":"2021-12-23","objectID":"/objc-roadmap/:1:13","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"UIKit","date":"2021-12-23","objectID":"/objc-roadmap/:2:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"UIView 与 CALayer bounds 与 frame setNeedsDisplay 与 layoutIfNeeded ","date":"2021-12-23","objectID":"/objc-roadmap/:2:1","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"常用 UI 组件 UIScrollView UITableView UICollectionView ","date":"2021-12-23","objectID":"/objc-roadmap/:2:2","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"AutoLayout Masonary 原理 ","date":"2021-12-23","objectID":"/objc-roadmap/:2:3","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"UIResponder touch events hitTest ","date":"2021-12-23","objectID":"/objc-roadmap/:2:4","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"离屏渲染 layoutSubview 与 drawRect ","date":"2021-12-23","objectID":"/objc-roadmap/:2:5","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Core 系列","date":"2021-12-23","objectID":"/objc-roadmap/:3:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Core Graphics 高效绘制圆角 ","date":"2021-12-23","objectID":"/objc-roadmap/:3:1","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Core Data","date":"2021-12-23","objectID":"/objc-roadmap/:3:2","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"AVFoundation","date":"2021-12-23","objectID":"/objc-roadmap/:3:3","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["Challenge"],"content":"时隔两年，再次拾起博客。 我完全不是一个有恒心的人，而且做什么事都是三分钟热度。包括博客，从 Jekyll 到 Hexo，再到现在 Hugo。 有新鲜玩意都想把玩一下，折腾完了又觉得索然无味。注重形式大于内容，纠结字体字号、各种样式的事情，反而没什么内容沉淀下来。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:0:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"关于博客在腾讯云买了域名 ryderfang.com，然后折腾备案、SSL 证书部署、nginx 配置静态页面等等， 目前源文件拖管在 Github 上，每次 push 自动触发 Actions， 完成编译并推送到 gh-pages 分支的操作。站内搜索使用 algolia，使用手动 Actions 的方式，需要时触发更新。 同样在腾讯云买了一个轻应用服务器，托管一下这个静态博客，不打算再折腾自动化了，需要同步的时候 ssh 登录一下，手动拉一下 repo 就好。 技巧 哈哈，总是在打脸，还是把自动同步服务器做成了一个 Action - name: remote ssh command uses: appleboy/ssh-action@master with: host: ${{ secrets.TENCENT_CLOUD_HOST }} username: ubuntu key: ${{ secrets.TENCENT_CLOUD_KEY }} port: 22 script: | whoami cd blog \u0026\u0026 git pull echo 'Done!' 再把之前的博客内容整理到新的博客上，发现并没多少值得保留的，真是有点惭愧。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:1:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"技术目标常常想起小时候爸爸告诫我的话： 有志之人立常志，无志之人常立志。 但是，这么多年的工作经历，让我认识到自己只是个普通人。普通的技术、普通的能力和普通的志向，甚至于在 “内卷” 与 “躺平” 的浪潮中，已经逐渐想要躺平。 最近又看到一句话： 到底什么样的终点，才配得上这一路的颠沛流离 ?! 是啊，或许，我们只是想去码头整点薯条，人生本无太多意义。 扯远了，总之，普通人就定几个能完成的普通目标。也不要过分自责，因为你就是一粒宇宙的尘埃。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"写文章到年底还有一个多月，输出 2-3 篇技术博客。 UPDATE: 算完成 80% 吧，内容还需要补充 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:1","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"iOS 技术栈继续完善 iOS 八股技术栈: https://github.com/ryderfang/iOSBagu，尽可能去了解一些犄角旮旯的知识点。 UPDATE: 没有完成，需要尽快补齐 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:2","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"读书读一点其他领域的书，随便看一点。 UPDATE: 没有完成，多读书是 2022 重点目标 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:3","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"生活目标","date":"2021-11-16","objectID":"/2021-personal-challeng/:3:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"健康身体 NO.1，换季的时候，一家人都得了咽炎，去医院太折腾了。希望全家都健康，宝宝也快点长大，少让姥姥和大家操点心吧。 成功 UPDATE: 安安越来越大了，前段时间脸上又被虫咬了一大块，最近快长好了。 平安、健康、快乐，足矣。没有别的希冀。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:3:1","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"早起每天送老婆上班，虽然累，但还是挺好的，早到公司一小时，可以做很多事了。困的问题就中午多午睡一会儿吧。 能睡说明自己还年轻吧，至少没有失眠的困扰，感觉至少要睡十个小时才能满足，也只能周末才有这个机会了。 UPDATE: 本来年底想面试一下来年换个工作，但老婆可能也要换，准备还是继续苟一段时间。 总的来说，鹅厂的人文关怀还是可以的。但不同项目组也差异很大，PCG 确实是个天坑。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:3:2","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"结语就这些吧，我感觉能完成 80% 就已经很不错了。元旦的时候再来 check 一下 🚀 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:4:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":null,"content":"我是谁互联网游荡者，历经 ‘BAT’ 三家公司，现任鹅厂废柴搬砖工。 I worked from B (Bilibili) A (Alibaba) T (Tencent), still too vegetable as a primary coder. Now I’m living with my wife and little son in Shanghai, China. Life is too short, Just enjoy it. ","date":"2021-11-11","objectID":"/about/:1:0","tags":null,"title":"$whoami","uri":"/about/"},{"categories":null,"content":"经历🐧 腾讯科技（上海）有限公司 客户端开发 2019.11 - INF 手 Q 开发 相机渲染，道具特效等 图片、视频编辑 AI 端智能 🚼 口碑（上海）信息技术有限公司 | 阿里巴巴 高级无线开发工程师 2017.10 - 2019.11 口碑掌柜 业务开发、投放体系建设 Lottie 接入 阿里云语音SDK 技术专项 端 AI 智能算法 H5 容器相关 🏝 上海哔哩哔哩科技有限公司 | 幻电信息科技 iOS 开发工程师 2016.04 - 2017.10 iOS 客户端 C++ 转 iOS 开发 业务开发，视频收藏夹 图片治理，webP 接入等 UGC 投稿助手 QT \u0026 C++ 开发 多线程视频文件上传 稿件管理功能等 📟 上海二三四五网络科技有限公司 2013.12 - 2016.04 2345 单核/双核 浏览器 浏览器业务开发 逆向技术、Flash 兼容 广告拦截技术 看图王、好压 DirectUI C++ 多线程开发 +++ ","date":"2021-11-11","objectID":"/about/:2:0","tags":null,"title":"$whoami","uri":"/about/"},{"categories":["Challenge"],"content":"信息 Mark Zuckerberg 每年都会发布自己的年度挑战 Personal Challenge So，我也要给自己立一些 Flag… ","date":"2018-01-29","objectID":"/2018-personal-challenge/:0:0","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"技术目标//\u003c!-- --\u003e console.log('达到中初级前端工程师水平') //\u003c!-- --\u003e UPDATE: 并没有达到 😢 这将是技术广度拓宽的一年。 最近几年，随着中年危机的提前到来，90年码农越来越焦虑，在知乎上的各种问题: 35 岁以上的互联网 / 科技行业从业者面临裁员时，应如何规划职业发展？ 新时代的中年危机长啥样？ 30岁程序员的出路 知乎圆桌 - 30 岁人生攻略 等等 很多人表达了这样一个观点，要想维持职场生命力，必须要努力掌握更深更广地技能。 成为所谓的斜杠 (Slash) 青年，不再满足于单一职业，而是多元化发展。 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:1:0","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"生活目标","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:0","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"早点睡觉常年处于缺觉的状态，整个人都不好了 TODO: 最好 11:30 pm 前睡觉 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:1","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"锻炼身体小肚子减减减呀！ ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:2","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"家里收拾好养了点花花草草，买了一只小龟龟，希望它明年还在 UPDATE: 小龟龟被我养死了 😭 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:3","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"结婚吧在一起快一年了，喜欢她的性格，也觉得该修成正果，安定下来了。 成功 UPDATE: 2018.12.01 相识 520 天，我们结婚啦！👫 💕💕 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:4","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["RTFM"],"content":"Chromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏 当然是因为好用(zhuāng bī) 了 😅 废话少说，下载地址： https://download-chromium.appspot.com/ 如果下载不了，可以试下： Windows https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/ Mac https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Mac/ 打不开之类的需要翻墙的问题自行解决吧。 ","date":"2018-01-26","objectID":"/chromium-api-keys/:0:0","tags":["Chrome"],"title":"Chromium 缺少 Google API 密钥解决办法","uri":"/chromium-api-keys/"},{"categories":["RTFM"],"content":"问题打开 Chromium 会提示 缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用 😒 由于 Chromium 使用的 API 都需要自行申请密钥才能使用。 所以 在 https://console.cloud.google.com/ 上创建密钥。 相关文档：http://www.chromium.org/developers/how-tos/api-keys 最后密钥有三个，位置在 https://console.cloud.google.com/apis/credentials GOOGLE_API_KEY GOOGLE_DEFAULT_CLIENT_ID GOOGLE_DEFAULT_CLIENT_SECRET ","date":"2018-01-26","objectID":"/chromium-api-keys/:1:0","tags":["Chrome"],"title":"Chromium 缺少 Google API 密钥解决办法","uri":"/chromium-api-keys/"},{"categories":["RTFM"],"content":"解决官方的解决方法是： 将下面三行写到 ~/.bash_profile 中，然后重启浏览器即可 export GOOGLE_API_KEY=\"****\" export GOOGLE_DEFAULT_CLIENT_ID=\"**** export GOOGLE_DEFAULT_CLIENT_SECRET=\"****\" $source ~/.bash_profile 这样，有时是管用的。特别是在 Windows上，使用类似的在命令行输入： setx GOOGLE_API_KEY your_key_goes_here setx GOOGLE_DEFAULT_CLIENT_ID your_client_id_goes_here setx GOOGLE_DEFAULT_CLIENT_SECRET your_client_secret_goes_here 但是 Mac 上有时不管用，参考: https://gist.github.com/cvan/44a6d60457b20133191bd7b104f9dcc4 在文档最后，发现有个哥们写了一个 Python 脚本，试了下，很好用！ 我 Fork 了一下，修复了一个 bug，给他提了 PR (https://github.com/ezeeyahoo/ChromiumSyncEnabler/pull/1) https://github.com/ryderfang/ChromiumSyncEnabler 跑下来重启 Chromium 就 OK 了！ ","date":"2018-01-26","objectID":"/chromium-api-keys/:2:0","tags":["Chrome"],"title":"Chromium 缺少 Google API 密钥解决办法","uri":"/chromium-api-keys/"},{"categories":["RTFM"],"content":"Visual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。 其中 社区版 Community Version 是永久免费的。 唯一不足的是在导出图表为图片时，右下角会有一个水印。 本文就是要使用 Python 去除这个水印，输出 png 图片。 该方法参考了网络上手动去除的方法，需要有一些操作 ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:0:0","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"导出首先需要将完成的图表导出为 svg 格式的图片： 选择 svg 格式保存： 这样我们就得到了一个带水印的 svg 图片: ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:1:0","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"去除水印 处理 svg 图片 Svg（Scalable Vector Graphics，可缩放矢量图形） 是一种矢量图片格式，可以使用文本编辑器直接打开，可以看得到在最后几行有水印的内容，所以我们可以用代码自动把他们去掉（当然也可以手动删除）。 水印内容在 Svg 文件中： \u003ctext x=\"68\" xml:space=\"preserve\" y=\"276\" stroke=\"none\" \u003ePowered ByVisual Paradigm Community Edition\u003c/text \u003e\u003cimage font-size=\"12\" x=\"303\" y=\"264\" fill=\"white\" width=\"16\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABvklEQVR42o1TPUgC YRi+z1PSzWrSc6ho6W/xNIhEoZoCl/a2fqaGoJKwyHIp16ZyCyIolwpq6c8lIz0h h6ACa/KWOHGz4byezz7lkNM8eHjf7/ve53l/vu84rsWXEcVo2uOJtYrhW5A3YCKE 48YXnE7zoSzfty3AyFHdln/R4bBA5O5fgQbyiUbIK6oY5gjxG1XCtyAngFl7qXT+ Y7UOwR+glTSK8EZkomlJMZsNCrKs7iuKOuXzJboUJYAqemrtHEBkGwsTIy/pe0bZ /Rmvd6K27svnx7Q/cu08LIliiPpmlvEGJo0DL4sRSKVyBuEZledznKpeYs+u6/YF nKt6C+jpe14QPjCsQUpmQVYgaNK0R9hPYJLtZ5Eo5JGkVF0AmUZAvoBLM5WBXhZs A6YB+pi+AAudD+zOnMuVjBcKheoMbOXyG0wcWKGtAPr77gauKyYTFU8g+xrsUWex mKu2r79Gye3eQkAE7i4wCtQG+YTMKZwt0zOUv274DjCLJGZBoEqv9JRtyyDfgrwK f09PNnyJ6OuBiYSxPAbecf9UMNZIbvovUBE8FjRINrEMNJbd1t9I28Gz7YD7DHKo WdwvFl2vGaThOSEAAAAASUVORK5CYII=\" height=\"16\" stroke=\"white\" preserveAspectRatio=\"none\" /\u003e 用 Python 读取文件内容，去除这一段内容即可。 转换成 png 图片 然后将 Svg 格式转换成 png格式，这里有现成的库 cairosvg 来实现。 完整的代码可以在 我的 Github 上找到。 ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:1:1","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"使用方法 需要先安装 cairosvg: $ pip3 install cairosvg 可能会报错，Pillow 安装失败，提示： The headers or library files could not be found for zlib. 可以尝试一下: $ xcode-select —-install $ brew install libtiff libjpeg webp little-cms2 $ pip3 install Pillow 安装 cairosvg 成功后，使用 Python3 import cairosvg 发现还是报错: \u003e\u003e\u003e import cairosvg Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/__init__.py\", line 29, in \u003cmodule\u003e from . import surface File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/surface.py\", line 24, in \u003cmodule\u003e import cairocffi as cairo File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\", line 41, in \u003cmodule\u003e cairo = dlopen(ffi, 'cairo', 'cairo-2') File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\", line 38, in dlopen raise OSError(\"dlopen() failed to load a library: %s\" % ' / '.join(names)) OSError: dlopen() failed to load a library: cairo / cairo-2 经过搜索，发现还需要安装 cairo 和 libffi： $ brew install cairo pango gdk-pixbuf libffi 终于弄完了 源文件： vp_remove_watermark.py 核心代码如下： import cairosvg svg_content = '' with open(src_name, 'r') as f: svg_content = f.read() end = svg_content.rfind('\u003c/g') beg = svg_content.rfind('\u003cg', 0, end) svg_content = svg_content[:beg] + svg_content[end:] with open('./vp_test_out.svg', 'w') as f: f.write(svg_content) cairosvg.svg2png(url='./vp_test_out.svg', write_to=dst_name) 赶紧跑起来 $ python vp_remove_watermark test.svg -o out.png ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:1:2","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"最近开始学习 Vue.js, 一脸懵逼地进入前端世界。 不使用 vue-cli 和 webpack 这些构建工具，使用单个 html 引入 Vue。 html 内容是这样的: \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eHello, Vue\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003cspan v-bind:title=\"message\"\u003e鼠标悬停\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: '#app', data: { message: '页面加载于 ' + new Date().toLocaleString() } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 用浏览器打开这个 html 就可以看到效果（鼠标悬停显示『页面加载于yyyy-MM-dd hh:mm:ss』） 安装 Vue-Devtools，但是插件栏显示 Vue.js not detected 由于访问的路径是 file:// 文件路径，Chrome 扩展默认是不能访问的。 ","date":"2018-01-24","objectID":"/vue-devtools/:0:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"Vue.js not detected打开右上角 ... -\u003e 更多工具 -\u003e 扩展程序，找到 Vue.js devtools，选中 允许访问文件网址: OK，然后 devtools 仍然不可用，提示 Vue.js is detected on this page. Devtools inspection is not available because it's in production mode or explicitly disabled by the author. 由于我们使用的 vue.js https://cdn.jsdelivr.net/npm/vue 是生产版本，所以不能访问。 ","date":"2018-01-24","objectID":"/vue-devtools/:1:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"Production mode下载开发版本的vue.js，放到本地，修改src路径为本地即可。 开发版本: https://vuejs.org/js/vue.js 生产版本: https://vuejs.org/js/vue.min.js (或者 https://cdn.jsdelivr.net/npm/vue) ","date":"2018-01-24","objectID":"/vue-devtools/:2:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"Vue-Devtools这样，打开开发者工具 (option + command + i || F12) 可以看到多了一个Vue的Tab: ","date":"2018-01-24","objectID":"/vue-devtools/:3:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是: $ npm install -g hexo $ hexo init $ hexo generate (hexo g) $ hexo server (hexo s) $ hexo new [name] - 新建文章 $ hexo new page [name] - 新建页面 正常情况下，这样就会启动本地的服务:http://localhost:4000，但现实总是残酷的， 由于国内XXX的网络环境，总会遇到各种各样的问题， 下面总结一下本博客迁移到Hexo过程中遇到的一些问题。 ","date":"2017-09-27","objectID":"/hexo-workflow/:0:0","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"NPM 源node的包管理工具npm，默认使用国外的源，访问比较慢，建议换成国内源，一般是淘宝npm: $ npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用cnpm代替npm进行模块安装了: $ cnpm install [name] 或者，使用nrm (npm的源管理工具): $ npm install nrm $ nrm ls * npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ $ nrm use taobao $ nrm test taobao ","date":"2017-09-27","objectID":"/hexo-workflow/:1:0","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"Hexo 安装","date":"2017-09-27","objectID":"/hexo-workflow/:2:0","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"hexo-serverhexo server执行失败: ERROR Plugin load filed: hexo-server 需要单独安装hexo-server: $ npm install hexo-server --save ","date":"2017-09-27","objectID":"/hexo-workflow/:2:1","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"node-sass$ npm install node-sass --save 如果出现如下情况: $ node scripts/install.js Cannot download \"https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node\": read ECONNRESET Hint: If github.com is not accessible in your location try setting a proxy via HTTP_PROXY, e.g. export HTTP_PROXY=http://example.com:1234 or configure npm proxy via npm config set proxy http://example.com:8080 $ node-sass@4.5.3 postinstall /private/tmp/node_modules/node-sass $ node scripts/build.js 说明github访问比较慢，两种方法： 修改host: http://tool.chinaz.com/dns?type=1\u0026host=github.com\u0026ip= 找一个TTL比较小的host，如: 192.30.255.112 github.com 直接去github下载 https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node 然后将该文件放到目录:~/.npm/node-sass/4.5.3/darwin-x64-51_binding.node 再执行安装命令 $ npm intall node-sass --save ","date":"2017-09-27","objectID":"/hexo-workflow/:2:2","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"hexo-renderer-scss有些主题需要安装hexo-renderer-scss: $ npm install hexo-renderer-scss --save 会出现错误: ERROR Plugin load failed: hexo-renderer-scss Error: ENOENT: no such file or directory, scandir 'xxx/node_modules/node-sass/vendor' at Object.fs.readdirSync (fs.js:914:18) ... 提示这个目录找不到，那我们手动创建好了: $ mkdir xxx/node_modules/node-sass/vendor $ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor 接下来还是报错: ERROR Plugin load failed: hexo-renderer-scss Error: Missing binding xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 7.x Found bindings for the following environments: 到这个目录下，把刚刚下载的darwin-x64-51_binding.node重命名复制进去好了: $ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/ $ cp darwin-x64-51_binding.node xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node ","date":"2017-09-27","objectID":"/hexo-workflow/:2:3","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"页面空白有时执行hexo s后显示服务启动，但页面打开空白，显示Cannot GET /，这种情况有很多原因， 可以尝试: $ npm install $ hexo cl $ hexo g $ hexo s 如果还有问题，查看一下npm插件是否安装正常: $ npm ls --depth 0 hexo-site@0.0.0 xxx ├── hexo@3.3.9 ├── hexo-deployer-git@0.3.1 ├── hexo-generator-archive@0.1.4 ├── hexo-generator-baidu-sitemap@0.1.2 ├── hexo-generator-category@0.1.3 ├── hexo-generator-feed@1.2.2 ├── hexo-generator-index@0.2.1 ├── hexo-generator-sitemap@1.2.0 ├── hexo-generator-tag@0.2.0 ├── hexo-renderer-ejs@0.3.1 ├── hexo-renderer-marked@0.3.0 ├── hexo-renderer-scss@1.0.3 ├── hexo-renderer-stylus@0.3.3 ├── hexo-server@0.2.2 └── node-sass@4.5.3 npm ERR! invalid: hexo-generator-baidu-sitemap@0.0.8 xxx/node_modules/hexo-generator-baidu-sitemap/node_modules/hexo-generator-baidu-sitemap 可以看到hexo-generator-baidu-sitemap这个插件安装失败了，尝试重新安装或者删除它: $ npm install hexo-generator-baidu-sitemap --save $ npm uninstall hexo-generator-baidu-sitemap 或者在package.json中将它删除掉。 ","date":"2017-09-27","objectID":"/hexo-workflow/:2:4","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["ObjC"],"content":"来自一个神奇的域名 http://fuckingblocksyntax.com/ ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:0:0","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"Declaration","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:0","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"local variablereturnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:1","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"property@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:2","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"method parameter- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:3","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"argument to a method call[someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:4","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"typedeftypedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:5","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"Hint block 在 ARC 下是否声明为 copy 属性 It is still a good idea to declare block properties as having copy semantics since a block assigned to a strong property will in fact be copied. Apple recommends this as well: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:2:0","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["Windows"],"content":"最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。 我自己在虚拟机中试了下，确实这样！ 在用户机器中获取了 DUMP，只看到有几个线程一直在跑，调用堆栈中也看不到太多信息（主要是没有线程 CPU 占用信息），一时没有方法。 今天突然想到 VS2013，新版本增加了一些功能，貌似有性能分析相关的。 找了一下，果然在调试菜单下发现了性能与诊断： 选择 CPU使用率，就开始分析啦！ 很快就给出了分析结果： 哈哈！瞬间定位 CPU 占用元凶，原来是一个后台线程一直在跑（空转），设计不合理。这个线程最早设计成自驱动的，找到原因就好办了，改成被驱动式就行了！ ","date":"2016-08-08","objectID":"/detect-cpu-usage-with-vs2013/:0:0","tags":["CPU"],"title":"VS2013 检测 CPU 占用率","uri":"/detect-cpu-usage-with-vs2013/"},{"categories":["RTFM"],"content":"安装 Ruby 和 Ruby DevKit Ruby 2.2.4 Ruby DevKit 切换到安装目录： $ cd C:\\RubyDevKit $ ruby dk.rb init $ ruby dk.rb install 安装Jekyll $ gem install jekyll $ gem install wdm 切换到博客目录运行 bash $ jekyll build [--watch/-w] $ jekyll serve [--watch/-w] 用浏览器打开http://127.0.0.1:4000，即可看到效果，而且在修改文件的同时刷新页面即可实时更新。 可以通过–port 888指定端口号，更多命令行参数参考[官方手册]1 安装有问题，可以参考更多文档： [Running Jekyll on Windows]2 [Jekyll Windows]3 [Setup Jekyll on Windows]4 http://jekyll.bootcss.com/docs/configuration/ “配置” ↩︎ http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html ↩︎ http://jekyll-windows.juthilo.com/ ↩︎ http://yizeng.me/2013/05/10/setup-jekyll-on-windows/ ↩︎ ","date":"2016-06-05","objectID":"/install-jekyll-locally/:0:0","tags":["Jekyll","Blog"],"title":"Jekyll 本地安装","uri":"/install-jekyll-locally/"}]