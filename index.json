[{"content":" 熟悉一门语言，可以从熟悉它的关键字入手。\n 本文列举一下 Swift 区别 OC 的一些特有关键字吧。这里仅列举常用的，完整的关键词列表可以参考：Swift 语言参考/关键字和标点符号\n@autoclosure #  Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.\n —— Swift 官方教程\n自动闭包，也是一种闭包。\n自动就是省略了 {}，系统自动将一个表达式转换成闭包。有个前提是这个闭包不能有参数。否则会收到编译错误：\n Argument type of @autoclosure parameter must be \u0026lsquo;()\u0026rsquo;\n private func _autoclosure(_ bar: @autoclosure () -\u0026gt; Bool) { if bar() { print(#function) } } 闭包是个值得讨论的话题，有机会单独写一篇文章。\n@escaping # 逃溢闭包，是指闭包的生命周期被延长。正常情况下在闭包作为函数参数时，函数执行完，闭包就被释放了。\n但是，如果闭包被缓存或延迟执行，生命周期被延长到函数执行之后。就需要显示指明 @escaping，否则会编译报错。\n因为 Swift 3 以后，闭包默认都是 nonescape 的。\n Escaping closure captures non-escaping parameter \u0026lsquo;bar\u0026rsquo;\n private func _escapingclosure(_ arg1: Int, _ arg2: Int, _ bar: @escaping (_ a: Int, _ b: Int) -\u0026gt; Int) { let concurrentQueue = DispatchQueue(label: \u0026#34;com.ryder.concurrent.queue1\u0026#34;, attributes: .concurrent) concurrentQueue.asyncAfter(wallDeadline: .now() + 1.5) { print(bar(arg1, arg2)) } } @convention # 也是用于修饰闭包的\n@convention(c) 修饰的闭包会返回 C 类型的函数指针，用于传给参数是函数指针的 C 方法。\n@convention(block) 修复的闭包会返回 block，用于传给参数是 block 的 OC 方法。\ndefer # defer 后面接一个闭包，表示推迟这个闭包执行到 defer 语句的作用域之后。\nprivate func _defer() { var num = 1 defer { print(\u0026#34;Defer: \\(num)\u0026#34;) } num += 1 print(\u0026#34;Number: \\(num)\u0026#34;) } // Number: 2 // Defer: 2  defer 内的闭包不会持有外部值。\n More: 喵总遇到的 defer 死锁问题\ndeinit # deinit { print(String(format: \u0026#34;%@ dealloced.\u0026#34;, String(describing: self))) } 析构方法。\nextension # 扩展，类似于 OC 的 category。\n扩展的作用主要有：\n 添加计算实例属性和计算类型属性 定义实例方法和类型方法 提供新初始化器 定义下标 定义和使用新内嵌类型 使现有的类型遵循某协议   类型方法的定义，所有类型都可以有类型方法，不限于 class/struct/enum。都可以使用 static func， 而在 class 中还可以使用 class func。\n 注意：扩展不能直接定义存储类属性，也就是不能有属性的实例。也没有 OC 的关联对象可以使用 （当然我们可以桥接一个 OC 实现）。\n那么怎么办呢？有个取巧的办法是定义一个类变量。\nextension MyOCFunction { private static var _temp = 0 var fact: Int { get { return MyOCFunction._temp } set { MyOCFunction._temp = newValue } } } fallthrough # 贯穿。Swift 中的 case 默认是非贯穿的，也就是 case 执行完之后自动退出，所以也就不需要 break 了。\n但是，如果你希望像其他语言一样，多个 case 执行一段逻辑，则可以在 case 后使用 fallthrough\nfileprivate # Swift 共有五种访问控制关键字，从高到低：\n open, 可以被本模块和外部模块任意访问 public, 与 open 唯一的区别是不能被外部模块继承和重写 (can\u0026rsquo;t subclass or override outside the module) internal, 默认 的级别，本模块内任意访问，不能被外部访问 fileprivate, 当前文件可见 private, 实体作用域可见，对于属性来说，仅当前类和它的 externsion 可见  这几个关键字可以用于修饰实体，如属性、基本类型、函数等。\nfinal #  final 修饰类，表示这个类不对被继承 （不能修饰 struct/enum，因为它们本来就不会被继承） final 修饰类中的属性、方法，表示不能被子类重写 显然，final 和 open 关键字是互斥的  guard # guard 守卫，用于校验某个条件，并退出当前作用域。\n在 guard..else 块中必须使用 return/throw 显式退出。\nlet temp = 0 guard temp != 0 else { print(\u0026#34;zero checked.\u0026#34;) return } inout # inout 用于在函数内修改值类型数据。在调用时，需要在参数前加 \u0026amp;\nvar num = 1 self._inout(num: \u0026amp;num) private func _inout(num: inout Int) { num *= 2 } inout 的工作方式是这样的（copy-in-copy-out）：\n 函数调用时，参数的值被拷贝。 函数体内部，拷贝后的值被修改。 函数返回后，拷贝后的值被赋值给原参数。  let/var # let - constant 修饰常量，仅可赋值一次 var - variable 修饰变量，可以被改变\n不管是常量还是变量，定义都遵循标识符的 定义标准，我们可以使用各种 Unicode 字符包括 emoji 来定义名称。\nprivate func _var() { var 🐶🐮 = \u0026#34;dogcow\u0026#34;; 🐶🐮 = \u0026#34;cowdog\u0026#34; print(🐶🐮) let 💩 = \u0026#34;shit\u0026#34; print(💩) } lazy # lazy 用在属性中，表示这个属性只有在被访问到才会执行初始化。也就是所谓的“懒加载”，避免的无效的内存占用。\n另一种用法，在序列，如 Array 的计算时，可以使用 lazy 只计算关心的值，如：\n// 只输出两次 `Calculating..` private func _lazy () { let array = Array(0..\u0026lt;100) let incArray = array.lazy.map{(item) -\u0026gt; Int in print(\u0026#34;Calculating..\u0026#34;) return item + 1 } print(incArray[0], incArray[8]) } 如果没有 lazy，那么 map 会被调用 100 次。\nref: https://swift.gg/2016/03/25/being-lazy/\nmutating # 对于 struct/enum 值类型对象来说，使用 mutating 修饰的方法才能修改它们的属性。\nstruct Meeting { var name : String var date : Date? init() { self.name = \u0026#34;\u0026#34; self.date = Date() } mutating func cancel() { self.date = nil } } Optional # 可选类型。\n 这是 Swift 区别 OC 的一个主要特征。\n prefix/infix/postfix # 用于修饰自定义操作符的，prefix 表示操作符在变量前，同理 infix 和 postfix 分别是中缀表达式和后缀表达式。\n自定义操作符方法，必须是 static 的。\nextension Vector2D { static prefix func +++ (vector: inout Vector2D) -\u0026gt; Vector2D { vector += vector return vector } } struct/class # 结构体与类的区别，在 之前 已经介绍过，不再赘述。\ntuple # 元组，通过圆括号和分号，将不同的类型组成在一起，形成一个新的类型。tuple 甚至可以嵌套包含别的 tuple。\n A tuple type is a comma-separated list of zero or more types, enclosed in parentheses.\n 通常用于函数返回值。\n一个有趣的事实：\nVoid 是 () 的 typealias，其实就是一个空的 tuple\ntypealias # Swift 中替代 typedef 的关键字。\n","date":"April 26 2022","permalink":"/posts/2022/keywords-in-swift/","section":"碎语闲言","summary":"熟悉一门语言，可以从熟悉它的关键字入手。","title":"Swift 中的关键字"},{"content":" 我是万万没想到，现在客户端面试卷到要问 ⌜图灵机⌟ 了。\n —— 某公司一面后有感\n大清废除八股已经 120 年了，但我们选拔制度并没有明显的改变。不管是面试还是晋升，无不充斥着八股套路。\n“破题“结束，闲话少说。\n三大架构中公共的 View 和 Model 很好理解：\n  View，也就是 UI，是用户看到的界面，是 Model 的外在表现\n  Model，Data Logic，是数据的集合\n  MVC #  Controller 是什么？类似一个中枢的概念，控制着数据如何被展示出来。  类型 1 # MVC 架构有很多设计。最早的版本是这样的：\n   用户通过操作 View 来完成系统更新，整个控制流是单向的。\n当然还有一种，用户只通过 Controller 来操作，这在 Wikipedia 中可以看到。\n类型 2 # 如果 View 和 Controller 都接收用户指令的话，就会变化成这样：\n     Controller 可以直接接收用户指令，如通过 scheme/url 进入某个页面，而不是通过直接操作 View。这时，Controller 响应的方法， 可能是 Update/Manipulate(操纵) Model，也可能是更新 View。\n  用户直接操作 View，这里 View 如果想要变更 Model，只能通过 Controller 中转。\n  有时，Model 的变更会直接通知 View （通过观察者的方式）。\n  这个实现，也就是阮一峰在博客1中提到的 Backbone.js 的架构方式。\n类型 3 # 在 iOS 开发中，MVC 被苹果演变成了如下方式：\n   解除了 Model -\u0026gt; View 之间的耦合。\nMVP # 在上述类型 3 的 MVC 模型中，将 Controller 替换成 Presenter，就是 MVP 模型。\n 也就是说，Presenter 作为 View/Model 的中枢，承载了所有显示相关的逻辑2。   在 MVP 架构下原先的 UIViewController 其实变成了 View 的一部分。\nMVVM3 #  区别与 MVP 的显著特征就是 View \u0026lt;-\u0026gt; Model 之间使用了数据绑定 (Data-binding) 技术。使两者在松耦合的同时，也能及时感知对方的变化。     Data Binding 在前端框架中比较常见，比如 Vue 中：https://v1.vuejs.org/guide/syntax.html\n\u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; 在 iOS 中，要实现双向绑定，可以使用 RAC 框架 ReactiveCocoa\nSwftUI 中的 @Binding 也可以实现类似的功能。（或许不是？这里待学习）\n  https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"April 25 2022","permalink":"/posts/2022/mvc-mvp-mvvm.md/","section":"碎语闲言","summary":"我是万万没想到，现在客户端面试卷到要问 ⌜图灵机⌟ 了。","title":"面试八股之 MVC/MVP/MVVM"},{"content":"   很多年前，我在本科时，学习数据结构用的教科书上面这本 《数据结构教程》（蔡子经、施伯乐 编著）。 在家翻了下，发现已经找不到了。不知道什么时候遗失了，因为我一般不会丢弃书籍，尤其是专业书。\n写这篇的目的是帮自己回忆一下，有些数据结构和算法的内容都已经被忘记了。 比如 Trie 树、B 树等结构，Floyd 算法本质是个 DP，还有 KMP 算法，常看常忘。\n数据结构这门课的教科书五花八门，尤其以严蔚敏的那版最为出名。目前看网上好评最高的是清华大学的邓俊辉教授的 《数据结构（C++ 语言版）》。本文参考：\nhttps://cloud.tsinghua.edu.cn/d/76cbab99574046698804/files/?p=%2Fdsacpp-3rd-edn.pdf\n 虽然有电子版，等疫情结束还是会买本实体书支持下老师。\n 这本书有自己的官网：https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/index.htm\nI. 数据结构 # 队列、链表、栈这些基础的结构按下不提，主要看看有哪些平时用得很少容易忽略的类型。\n优先队列 # 二叉树的遍历 # Huffman 编码 # 邻接矩阵 # 邻接表 # II. 算法 # 散列 hash # 字符串 # BMP # BM # Karp-Rabin 算法 # 二叉树/平衡树 # 二叉搜索树，又叫二叉查找树 (Binary Search Tree)，简称 BST。\n平衡二叉树，也就是平衡树 (self-Balancing Binary Bearch Tree)，简称 BBST。\n平衡树有非常多的 种类\n常见的有：\nAVL 树 # 伸展树 # B 树 # 红黑树 # k-d 树 # 图论 # BFS # DFS # 最短路 # ","date":"April 22 2022","permalink":"/leetcode/base/algo-in-data-structure/","section":"算法专栏","summary":"很多年前，我在本科时，学习数据结构用的教科书上面这本 《数据结构教程》（蔡子经、施伯乐 编著）。 在家翻了下，发现已经找不到了。不知道什么时候遗失了，因为我一般不会丢弃书籍，尤其是专业书。","title":"重拾数据结构中的算法"},{"content":" 参考：swift.bootcss.com  基本语法 # 分号 #  分号在 Swift 中不是必须的，当然在一行中多个语句间还是需要的。   越看越觉得像 Python :)\n 空格 #  Swift 对于空格有着一定的约束，相对 OC 来说更严格，但又没有 Python 那么精确 （不需要游标卡尺 🤡）  // \u0026#39;=\u0026#39; must have consistent whitespace on both sides var a= 1 + 2 // \u0026#39;+\u0026#39; is not a postfix unary operator var a = 1+ 2 // Consecutive statements on a line must be separated by \u0026#39;;\u0026#39; var a = 1 +2 // ok var a = 1 + 2 // ok, not recommand var a = 1+2 switch #   Swift 中的 switch 支持任意类型，而 OC 只支持整型及能转换成整型的类型。\n  在 Swift 中 break 并不是必须的。某个 case 匹配成功后，会在执行完代码后自动跳出；而 OC 以及 C/C++ 会继续匹配， —— 这种方式叫做 贯穿。在 Swift 中可以使用 fallthrough 关键词以支持这种特性。\n  Swift 中的 switch 支持 where 语句以添加额外的条件。\n  函数嵌套 #  Swift 支持在函数内部定义函数。  func testVariable () { var a : String? = \u0026#34;1\u0026#34; func _inerfunc() { print(\u0026#34;hello\u0026#34;, a ?? \u0026#34;2\u0026#34;) } _inerfunc() } 继承 #  Swift 继承自父类的方法，重写时，需要加 override 关键字。OC 不需要。  区间运算符 #   在 Swift 中 [a, b] 的区间可以用 a...b\n  [a, b) 可以表示成 a..\u0026lt;b\n  还有 [a...] 和 [..\u0026lt;b] 等\n  类型 #  Swift 是一个类型安全 (type safe) 的语言。\n typealias 类型别名 #  这个在 OC 中可以使用 typedef 实现。  隐式转换 #  Swift 有严格类型定义，不能隐式转换。  比如 if 语句中的条件，在 OC 中可以使用整数，但在 Swift 中只能是 Bool 型。\nlet a = 1 // Type \u0026#39;Int\u0026#39; cannot be used as a boolean; test for \u0026#39;!= 0\u0026#39; instead if (a) { } Optional 可选值 #  这是 OC 没有的特性，避免了很多判空的逻辑代码。在链式调用时，也更方便。  闭包与 block #   Swift 中的闭包与 OC 中的 block 类似，都是将一段代码封装起来，用于参数、返回值等，也都可以捕获外部变量。\n  但也有不同之处：\n  本质不同，闭包本质是个函数，但 block 是一个结构体。\n  闭包写起来更简洁、更灵活。有多种类型：自动闭包、尾随闭包、逃逸闭包 \u0026amp; 非逃逸闭包等。\n    enum 枚举 #  Swift 中的 enum 可以包含方法，而 OC 不行  Tuple 元组 #  这是 OC 没有的类型，用于返回一组数据，如 (404, \u0026ldquo;Not Found\u0026rdquo;)  nil #   Swift 中的 nil 表示可选值类型的值为空，不能用于确定的类型。而 OC 中，它是一个空指针的概念，只能对于对象。\n  可选值可以是整型，如 var a : Int? = nil\n  ?? 空合 #  是对一个可选类型解析，类型于 OC 中的 a ?: b  // if a == nil, return b a ?? b // is equal to  a == nil ? a! : b 高级特性 # 函数 #   Swift 中的函数，可以不指明返回值，默认返回的是 () —— 空元组。而不是 Void\n  Swift 可以给函数参数设置标签（别名），_ 表示不需要标签。\n  单行表达式的函数，可以直接省略 return；常用于 get 方法。\n  默认函数参数是不能修改的，需要使用 inout 标明需要修改的参数。\n  结构体与类 #   struct 在 OC 中并不是一等公民，但在 Swift 中，是与 class 同等地位的对象封装。\n  Swift 中的 struct 与 class 比较：\n struct 是值类型，而 class 是引用类型 (值类型存储变量本身，引用类型存储内存地址) struct 不支持继承，而 class 可以 struct 会给成员变量默认值，而 class 必须自行初始化 struct 不需要引用计数，所以没有 deinit 方法 使用 let声明的实例，class 可以修改它的属性，而 struct 不行 (需要借助 mutating 方法) struct 不支持类型转换 (typecasting)    ref: Choosing Between Structures and Classes\n值类型与引用类型 # 值类型 被赋值给另一个变量时，会进行 copy 操作，以确保新变量的修改不会影响原来的变量值。 而 引用类型 的赋值是一次指针赋值，新旧变量指向同一块内存。\n String, Array, Dictionary 都是 struct\n   Swift 中 enum, struct 是值类型，class 是引用类型。\n  OC 中仅有基本数据类型、基础 struct 是值类型。\n  属性包装器 #  Swift 中的新特性，关键词 @propertyWrapper  用于将某个属性的实际值隐藏起来，对外暴露封装过的值。\n类方法 #   static 和 class 在 func 前都表示类型方法，后者表示可被子类继承\n  Swift 中可以为类、结构体和枚举定义类型方法\n  extension 扩展 #   Swift 中的扩展与 OC 中的 category 类似，也有一些不同\n 扩展是没有名字的 扩展可以添加属性 扩展不能重写已有方法，但分类可以（覆盖） 扩展中的功能，可被扩展定义之前的实例使用；但分类方法必须被 import 后才可见    protocol 协议 #  Swift 中的协议支持指定属性 Swift 中的协议可以指定初始化方法，实现时需要使用 required 关键字 Swift 中的协议可以组合，使用 ProtocolA \u0026amp; ProtocolB 变成一个新的协议类型 Swift 中的协议，可以提供默认实现  泛型 #  类似 C++ 中的模板语法特性，OC 中没有。  actor 类型 #  Swift 中新增的类型   To be continued\u0026hellip;\n ","date":"April 10 2022","permalink":"/posts/2022/swift-vs-oc/","section":"碎语闲言","summary":"参考：swift.","title":"Swift 与 OC 有哪些不同"},{"content":"最近大搞减包运动，今天从同事那了解到一个神奇的减包策略：\n   把 @protocol 换成 NSProtocolFromString !     这是为啥呢？\n做个实验 #    添加一个 @protocol 调用：\n   可以看到生成的 lib 中 __DATA,__objc_const 段中少了多个 protocol 相关的符号。\n改成 NSProtocolFromString，也不会生成符号：\n   为啥呢 # 我们反编译一下 文件：\nclang -rewrite-objc BGStaticLib.m 在反编译后的 BGStaticLib.cpp 中可以看出：\n新增的几个符号，被指定放到了 __DATA 段，正是用 MachOView 看到新增的那几个符号：\n_OBJC_PROTOCOL_INSTANCE_METHODS_NSObject __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) _OBJC_PROTOCOL_OPT_INSTANCE_METHODS_NSObject __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) _OBJC_PROTOCOL_PROPERTIES_NSObject __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) _OBJC_PROTOCOL_REFS_BGProtocol __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) 能减多少 # 比较了下修改前后的 lib 文件，size xx.a\n// 修改前 __TEXT\t__DATA\t__OBJC\tothers\tdec\thex 703\t1256\t0\t6519\t8478\t211e\txx/libBGStaticLib.a(BGStaticLib.o) // 修改后 __TEXT\t__DATA\t__OBJC\tothers\tdec\thex 204\t320\t0\t6531\t7055\t1b8f\txx/libBGStaticLib.a(BGStaticLib.o) __TEXT 和 __DATA 段共减少了 499 + 936 = 1435，共 1.4 KB。\n通过 stat xx.a 命令获取整个 lib 字节数发现：\n共减少了 15504 - 11168 = 4336，共 4.3 KB。\n积小成多 # 看起来单个文件并不多，但实际上在巨型 app 中，使用 protocol 作为 bridge 跨工程调用其他模块的方法非常多。\n这次减包过程中，某模块经过这样改写之后，减少了 10M 的包体积。🤩\n","date":"April 8 2022","permalink":"/posts/2022/reduce_pkg_size_1/","section":"碎语闲言","summary":"最近大搞减包运动，今天从同事那了解到一个神奇的减包策略：","title":"一个神奇的减包方法"},{"content":" 查了下订单，这本书买了 4 年多，还没看完！\n     所谓 flag，永远也完不成 😢\n毕其功于一役，这次快速啃完这本书，吸收一些最佳实践。\n这本书完整的书名是 《Effective Objective-C 2.0：编写高质量 iOS 与 OS X 代码的 52 个有效方法》，第一版写作于 2014 年，2017 年重印，距今已经比较长的时间了，那么，\n 这 52 条规则是不是都还适用呢？\n 带着这个疑问，快速过一遍！\n基础概念 # 1. 起源 # OC 是 C 的超集，是 C + Object。\nOC 的消息发送机制与其他语言的函数调用的区别是：\n 前者由运行时决定，后者由编译器决定。\n 2. 减少头文件引用 # 这个应该所有语言 (严谨点，大部分) 都通用吧，减少模块间耦合，避免过多引用。\n3. 字面量语法糖与下标操作 # NSString, NSArray, NSNumber, NSDictionary 使用 @\u0026quot;\u0026quot;, @[], @(), @{} 语法创建。\n需要注意的是如果有空对象，字面量会抛异常而 crash，但是 arrayWithObjects: 会截断列表，只取 nil 前的元素。\n而对于 NSArry 和 NSDictionary 来说，下标操作比 objectAtIndex: 和 objectForKey: 要方便一点， 但是越界一样会抛异常。\n4. 用 const 常量代替 #define # // xx.m --\u0026gt; 尽量不要定义在 .h 中，如果是给别人使用，需要 extern static const NSTimeInterval kAnimationDuration = 0.3 // xx.h extern NSString *const XXStringConst; // xx.m NSString *const XXStringConst = @\u0026#34;VALUE\u0026#34;  const 常量带有类型信息，会被编译器检查；#define 是单纯的字符串替换，没有任何校验。 extern const 常量只能被定义一次 (可多次声明)，而 #define 没有限制，容易产生覆盖问题。 tip: static const 定义在 .m 文件中，不会出现在全局符号表中。  5. 使用枚举 # typedef NS_ENUM(NSInteger, XXState) { XXState1, XXState2, XXState3, }; typedef NS_OPTIONS(NSInteger, XXOPT) { XXOPT1 = 1 \u0026lt;\u0026lt; 0, XXOPT2 = 1 \u0026lt;\u0026lt; 1, XXOPT3 = 1 \u0026lt;\u0026lt; 2, };  switch 中的枚举，不要实现 default 分支，避免新加入枚举值时漏掉分支实现。\n 对象、消息与运行时 # 6. 属性 #  atomic 是原子性的，但并不是线程安全的。\n 如果在一个线程多次读取某个属性的时候，有另一个线程在写，即使声明为 atomic，也会读取到不同的值。\n iOS 中使用同步锁开销较大，一般不使用 atomic\n 7. 在对象中尽量直接访问实例变量 #   在读取时，使用 _val 而不是 self.val\n  在设置时，使用 self.val = xx\n  不要在 init 和 dealloc 中使用 self.val！\n如果子类重写了某个属性的 set 方法，\n 在 init 中，父类如果调用 set，其实是调用的子类实现，可能会出现不想要的结果 在 dealloc 中，子类先释放了实例，父类再去调用 set 方法，会导致 crash    8. 对象相等性 #  ==： 是地址比较 isEqual:： 默认也是比较指针，可以被重写。对于 NSString，等效于 isEqualToString: hash：如果对象相等，则 hash 必须相等；反之，不一定成立  9. 类族 # class cluster，看起来类似于工厂模式。\n系统库的集合类，如 NSArray、NSDictionary 都是类族的抽象基类。\n10. 关联对象 #  非必要不要用。\n 11. 消息发送 # objc_msgSend 是一个重要的概念。\nobjc_msgSend 在调用方法时，甚至使用了 \u0026ldquo;尾递归\u0026rdquo; 优化。\n12. 消息转发 # message forwarding 也是一个重要的概念。三步走：\n  + (BOOL)resolveInstanceMethod:(SEL)sel，可用于动态添加实现\n  - (id)forwardingTargetForSelector:(SEL)aSelector，转发给其他对象\n  - (void)forwardInvocation:(NSInvocation *)anInvocation，完整的消息转发\n第三步，需要配合\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n使用。\n  13. 黑魔法 # Method Swizzling 也是一个重要的概念。\n 不要滥用，难以调试\n 14. 类对象 # 参考：[Runtime] Class, Object 与 isa\n接口与 api # 15. 使用前缀命名 # 由于没有名字空间 (namespace) 机制，只能通过加前缀的方式避免符号冲突。\n 特别注意，要在分类方法名前加前缀\n 16. 使用指定初始化方法 #  指定初始化方法 (designated initializer, NS_DESIGNATED_INITIALIZER) 必须调用父类的指定初始化方法 本类的其他初始化方法 (便捷初始化方法，convenience initializer) 必须调用本类指定初始化方法，不能调用父类的 如果子类有指定初始化方法，则必须实现所有父类的指定初始化方法     17. 实现 description 方法 # 或者 debugDescription 方法，用于调试输出日志。\n18. 尽量使用不可变对象 # immutable 也是个重要的概念。\n 对外的容器属性尽量只读，并提供读写接口。\n 19. 命名 # 前缀 + 驼峰式，尽可能一眼看懂作用的命名。\n20. 私有方法加前缀 ️❓ # 作者建议私有方法使用 p_ 作为前缀，这点个人觉得存疑。\n实际开发中，没有必要区分 public 和 private 方法。不在头文件中的方法即为 private， 显然使用者有很多办法可以绕过这个限制。但这不重要。\n这里作者提了一点很重要，不要使用 _ 单下划线作为前缀，因为系统库也这样命名，容易无意中重载。\n21. 处理异常 #  少用异常，除非必须 crash 的场景。一般错误使用 NSError 替代。\n 这里我要说一句，有些人喜欢 NSAssert 滥用，真是非常影响调试！😒\n22. 理解 NSCopying # immutable 与 mutable 与 深浅拷贝 的概念不要混淆。\n copy -\u0026gt; immutable mutableCopy -\u0026gt; mutable [NSArray copy] -\u0026gt; 浅拷贝，即与原数组指针相同 [NSArray mutableCopy], [NSMutableArray copy], [NSMutableArray mutableCopy] 都是深拷贝，会生成新的地址。   对于集合类成员来说，默认都没有执行 copy 操作。\n  可以使用 -initWithXX:copyItems:YES 方法执行逐个 copy。\n 协议与分类 # 23. 委托 delegate # Cocoa 框架大量使用，约定俗成的设计模式。\n24. 分类 # 将一个大类，按功能拆成多个分类，是一种代码优化的方法。\n25. 分类名和方法 # 在为系统或第三方类添加分类时，要加上自己特有的名字前缀。\n与 #15 类似。\n26. 分类中不要定义属性 # 一般也定义不了。除非使用关联对象。\n27. 匿名类 # class-continuation\n可以用来\n 隐藏私有变量 隐藏私有方法 隐藏私有协议  28. 用协议提供匿名对象 # 指 id\u0026lt;XXProtocol\u0026gt; delegate 这种形式\n内存管理 #    内存管理对于 OC 来说很重要。  29. 引用计数 # 对象间引用构成一颗树，根结点是 NSApplication/UIApplication。\nautorelease 可以延长变量的生命期，通常用于方法返回。(MRC)\n30. 使用 ARC # ARC 很好用。但需要注意：\n 必要的时候需要借用 autoreleasePool 管理 CoreFoundation 对象不归 ARC 管，需要自行调用 CFRelease  31. dealloc 方法 #  MRC 中 dealloc 最后需要手动调用 [super dealloc]，ARC 中不再需要\n  不要在 dealloc 中调用异步操作 不要在 dealloc 中调用属性的读写操作  在对象处于 deallocating state 时，不要做修改对象内容的事情。\n32. 异常与内存管理 # try 块中创建的对象需要在 @finally 中释放。ARC 下需要开启 -fobjc-arc-exceptions 编译标志才可以正确释放。\n33. 弱引用 # weak 也是一个重要的概念。\n与 unsafe_unretained 区别在于，weak 会进行 autonilling。\n34. @autoreleasepool 的使用 # autorelasePool 也是一个重要的概念。\n降低内存峰值 (high-memeory waterline)\n35. 僵尸对象 # Zombie Object\nXcode 中有一个开关可以打开 Enable Zombie Objects = YES。\n这样系统会替换 NSObject 的 dealloc 实现。在原类的 dealloc 中，通过 objc_setClass，生成一个 _NSZombie_XXCls 类替换原类， 在后续再向原类发送消息时，就会被转发到僵尸类中，然后输出已经被释放的类名和错误信息。\n*** -[XXCls method]: message send to deallocated instance 0x7xxxx 36. 不要使用 retainCount #  ARC 下可用，MRC 下不准确。所以是无用的 存在自动释放池，延迟释放，所以这个值也不准 系统优化释放行为，可能对象引用计数不会为 0  block 与 GCD # 中文版译为 “块与大中枢派发”，无力吐嘈。\n   这两者都非常重要。  37. 理解块 block #  block 也是对象，有自己的引用计数和生命周期管理 block 是一种代替函数指针的语法结构，核心功能在 void (*)(void *,) invoke 函数指针 捕获的变量在 block 体内，invoke 将 block 本身传入以便于读取到捕获的变量 有栈 block、堆 block 和 全局 block，可以通过它的 Isa 指针区别  38. 使用 typedef 重命名 block # 常用的做法\n39. 使用 handler 块降低代码分散程度 #  就是将 block 作为参数传入，而不是使用 delegate   这个完全取决于实际情况，如果回调过多，还是 delegate 更好一点。\n   API 设计常用同一个 block 返回结果和错误\n  NSNotificationCenter 的设计值得学习，应该由调用者决定回调的线程\n  40. block 与 循环引用 # retain cycle 是个使用 block 时常见的问题\n某个类 retain 的 block 内部如果捕获了类本身，就会出现循环引用。此时需要及时释放 block。\n41. 用队列代替锁 #  使用串行队列代替 @synchronized(self) 串行队列，读同步 dispatch_sync；写异步 dispatch_async，执行速度快，但性能会比同步慢，因为需要 copy block 并发队列，读同步，写异步，此时避免竞争需要用 dispatch_barrier_async，栅栏   到底什么是线程安全，很难有个准确的定义。锁机制能保证一定程度的 thread safety，但不绝对。\n 两次读之间，有写操作。这两次读的结果就可能不一样。这样算不算线程不安全？\n42. 用 GCD 替代 performSelector #  performSelector 无法让编译器决定是否释放返回对象，容易内存泄露 使用 dispatch_after 代码 performSelector:withObject:afterDelay:  43. GCD 与 NSOperationQueue # NSOperationQueue 底层也是 GCD 实现的。但是相对来说，有一些优点：\n 更方便取消 可以指定依赖关系 可以用 KVO 了解运行状态 指定操作的优先级 代码可复用  44. dispatch_group # 掌握几个方法的使用\ndispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); // 成对出现 dispatch_group_enter(dispatch_group_t group); dispatch_group_leave(dispatch_group_t group); // 阻塞等结束或超时 dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); // 不阻塞等结束 dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); // 循环执行多次 dispatch_apply(size_t interations, dispatch_queue_t queue, void (^block)(size_t)); 45. dispatch_once #  dispatch_one 性能是 @synchronized 的两倍以上\n 46. 不要使用 dispatch_get_current_queue # API_DEPRECATED(\u0026#34;unsupported interface\u0026#34;, macos(10.6,10.9), ios(4.0,6.0)) DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NOTHROW dispatch_queue_t dispatch_get_current_queue(void); 这个 API 已经被弃用，不过理解其不可用的原因还是有用的。\n 返回值通常与预期不符，队列按层级组织，无法用单个队列描述当前队列。如在全局队列中 async 执行某个队列，当前队列可能是全局队列 可以使用 dispatch_queue_set_specific() 方法存储队列特有数据，类似于 TLS (Thread Local Storage)  系统框架 # 47. 熟悉系统框架 #  Foundation 与 CoreFoundation 存在 “无缝桥接”，如 NString \u0026lt;-\u0026gt; CFString 常用系统库  CFNetwork CoreAudio AVFoundation CoreData CoreText QuartzCore/CoreAnimation CoreGraphics    48. 使用块遍历代替 for #  for\u0026hellip;in 语法 enumerateObjectsUsingBlock:  49. 使用 CoreFoundation 中的 collection 类 # 这一节感觉不是太常用。\n NSArray -\u0026gt; CFArrayRef: 使用 (__bridge CFArrayRef) 转换 反之使用 (__bridge_transfer NSMutableDictionary *)(CFMutableDictionaryRef xx)  50. 使用 NSCache # 相比于 NSDictionary 的优势在于：\n 键不需要支持 copy 低内存时自动清理 线程安全 配合 NSPurgeableData 使用，实现自动清除数据  51. 精简 initialize 和 load 代码 #   load 方法在启动时调用，先调用本类的，再调用分类的。先调用父类的，再调用子类的。子类不实现，父类不会调用。\n  load 中使用其他类是不安全的\n  尽量在 initialize 方法中做初始化操作，与 load 的区别：\n 惰性调用，使用时才调用 比 load 更可靠，此时使用其他类是线程安全的 遵循继承规则，子类没有实现，会调用父类的    也尽量不要在 initialize 中添加太多代码\n  52. NSTimer 会 retain 它的 Target #  NSTimer 也是一个重要的对象\n 有多种方法可以打破循环引用 。\n   终于看完了！这是一本不错的书，但由于年代久远，一些概念和用法需要更新。  OC 这个古老的语言，如今在大厂的 屎山 项目中还在发挥着作用。\n但是作为开发者，我们要拥抱未来！\n To Learn Swift, right now !!\n ","date":"April 7 2022","permalink":"/posts/2022/effective-oc-2.0/","section":"碎语闲言","summary":"查了下订单，这本书买了 4 年多，还没看完！","title":"一文学完《Effective Objective-C 2.0》"},{"content":"Git 操作是程序员必须掌握的基本技能。刚毕业那会，大家还都使用 svn 作为版本管理工具。\n但近些年大家基本都改用 git 了，甚至在我们项目内部 UI 切图都开始使用 git 管理了。\n 感谢 Linus Torvalds 的伟大发明！\n 一般情况下，我们常用的命令无非是：\n$ git init $ git checkout $ git add $ git pull $ git push $ git merge 在说 rebase 前，先重点强调一下 黄金法则：\n   永远不要在公共分支上使用 rebase !!  rebase 作为一个进阶命令，常常与 merge 放在一起比较。\nrebase 与 merge # $ git checkout feature $ git merge main // or $ git merge feature main 将 main 分支合并到 feature：\n   这样在 feature 分支上会产生一个新的 commit，这是一个 merge commit。\n而对于 rebase:\n$ git checkout feature $ git rebase main    可以看到 feature 分支所有 commit 都被放到了 main 前面，整个 history 形成了一条直线。\n值得注意的是，feature 的所有 commit 都被重建了，它们的 hash 已经不是原来的那个了！\n所以，rebase 相对于 merge 来说，优点是：\n 时间线更漂亮，符号强迫症和整洁癖的喜好  为了做到这个，它对 安全性 (safety) 和 可追溯性 (traceability) 做了折衷1，如果不遵循 rebase 黄金法则，将带来灾难！\nrebase 的缺点很明显：\n 不当的使用容易造成严重后果 难以追溯历史，比如上面的 feature 分支在 rebase 之后，无法知道是什么时候从 main 切出进行的修改。无法知道什么时候合入的 main 分支。  git pull # 首先，git pull 是两个动作的合并，即 git fetch + git merge FETCH_HEAD\n比如 git pull origin master，首先拉取 origin/master，再将本地分支与 origin/master 执行 merge 操作。\n如果你本地有一个 commit，但是没有提交到远程；同时你的同事在同一个分支上提交了代码。你进行 fetch 的时候会发现，本地分支既 ahead 又 behind：\n    如果这个时候执行 merge 操作：   Merge made by the \u0026lsquo;recursive\u0026rsquo; strategy.\n    会产生一个 merge 节点！\n 如果执行的是 rebase 呢？        会将本地的 commit 重建，并放到最上面。（可以看到 commit id 不一样了）\n然后 push 之后，时间线就成了一条直线！\n   所以，git pull 这个操作，大部分情况来说，使用 \u0026ndash;rebase 更合适！\n我们可以设置 git pull 默认使用 rebase 选项：\n# 仅设置 master 分支生效 git config branch.master.rebase true # 对所有 tracking 的 branch 生效 git config branch.autosetuprebase always # 对所有 pull 操作生效 git config pull.rebase true  以上仅对当前目录的 git 生效，如果要全局生效，记得加上 --global 选项。\n # 手动编辑更方便！ git config --global --edit rebase 的禁忌 # 再次复习一下 黄金法则：\n   永远不要在公共分支上使用 rebase !!  如果你和同事公用了一个 feature 分支，而你使用 rebase 同步主干。很有可能弄丢同事的代码！\n我们来看下是怎么出现的：\n 首先我们从 master 切出一个 feature 分支：     这个时候有两个同事同时在这个分支上开发，相安无事。\n某天，有个同事说，主干上有一些更新，我们要不要同步一下到 feature 分支：     “好啊，好啊”，那么怎么同步呢？要不要试试新学的 rebase 命令 ?!     3.1. 你的同事一边说“好啊”，一边在自己本地的 feature 上提交了好几次，并 push 到了远程！\n   你并不知道，这样你本地的 feature 分支并没有完全包含同事的提交，与此同时，你开始了可怕的 rebase 操作：\n这时，你发现提交不上去：\n   于是，头脑一热，你决定大力出奇迹，--force 一把：     这时，你同事更新一下代码，发现！“我的代码怎么没了？？！！”\n怎么办？ # 有办法补救嘛？有！\n让你的同事使用 git reflog：\n   找到丢失的 commit，通过 git cherry-pick [commit-id] 提交到 feature 分支即可！\n但是！我们还是不要随便使用 --force 来制造这种凶险事件了。\n看下面这个场景：\n   前面介绍过，超前是本地分支有三个变更，落后是远程分支有四个变更没有同步过来。\n如果我们强行 push 就会丢失远程的 commit，所以我们试一下 --force-with-lease 参数：\n没有区别，还是提交上去了！\n   在这种明知道本地落后，仍然强行提交的情况下，--force-with-lease 的作用与 --force 是一样的！\n正常的做法是：\n git pull \u0026ndash;rebase 更新本地分支\n 而 git push --force-with-lease 能够解决的是，在 rebase-push 过程中，有其他人提交到该分支时的，这次提交操作会被拒绝。相对来说更安全一点。\n所以，总得来说，还是黄金法则：\n   永远不要在公共分支上使用 rebase !!   多人协作分支，同步主干，请使用 merge !!\n   https://www.atlassian.com/git/tutorials/merging-vs-rebasing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"March 19 2022","permalink":"/posts/2022/git-rebase/","section":"碎语闲言","summary":"\u003cp\u003eGit 操作是程序员必须掌握的基本技能。刚毕业那会，大家还都使用 svn 作为版本管理工具。\u003c/p\u003e\n\u003cp\u003e但近些年大家基本都改用 git 了，甚至在我们项目内部 UI 切图都开始使用 git 管理了。\u003c/p\u003e","title":"关于 Rebase 容易被坑的那些事"},{"content":"   “二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 O(log n)，空间复杂度 O(1)，相比线性搜索优秀太多。\n但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本1能准确写对“二分”查找。\n 尽管二分查找的基本思想相对简单，但细节可以令人难以招架 \u0026hellip; — 高德纳\n 二分查找的前提是待查找的序列是有序的。\n本身算法逻辑非常简单2：\nfunction binary_search(A, n, T) is L := 0 R := n − 1 while L ≤ R do m := floor((L + R) / 2) if A[m] \u0026lt; T then L := m + 1 else if A[m] \u0026gt; T then R := m − 1 else: return m return unsuccessful 减少一次判断 # 上述伪代码每次循环都会比较 mid 与 target 是否相等，如果去掉这个比较，将之放到循环退出时，就可以在每次循环中减少一次比较，总得循环次数仅比上面的算法多一次。\nfunction binary_search_alternative(A, n, T) is L := 0 R := n − 1 while L != R do m := ceil((L + R) / 2) if A[m] \u0026gt; T then R := m − 1 else: L := m if A[L] = T then return L return unsuccessful 关于 cell 和 floor # 可以看出来，上面两个实现中在取 mid 时使用了不同的方法，一个是 floor()，一个是 ceil()，\nfloor((0 + 1) / 2) = 0\nceil((0 + 1) / 2) = 1\n为什么会有这个不同呢？在 StackOverflow 上有很好的解释：\n 如果更新二元组 (l, r) -\u0026gt; (m + 1, m - 1) 时，这两种方法都可以，结果是一样的。 如果是 (l, r) -\u0026gt; (m, m - 1) 时，必须要使用 ceil，否则循环无法退出。比如 l = 0, r = 1, A = [1, 2]， target = 2 时，floor 会导致 l 一直被更新为 0，无法退出。 如果是 (l, r) -\u0026gt; (m + 1, m) 时，必须要使用 floor，否则同时循环无法退出。比如 l = 0, r = 1, A = [1, 2]，target = 1 时，ceil 会导致 r 一直被更新成 1。   总之，就是更新下边界更多时，使用 floor，更新上边界更多时，使用 ceil。\n 关于溢出 # 上述算法中还有一个问题，计算 mid = floor((L + R) / 2) 存在可能的溢出错误，这在 C++ 中比较常见，比如 l = r = 2^31-1，相加就会溢出整数范围！\n正常的写法是：\nmid = l + (r - l) // 2 如果有重复元素 # 如果序列中存在重复元素，比如 [1, 2, 3, 3, 3, 4, 5]，要查找 T = 3，可能会有多个结果。\n如果只是判断 target 是否存在，上述的算法都没有问题。但是如果想找到 index 最小或最大的 target 位置，算法就需要做一些修改。\n参考 C++ 标准库中的 std::binary_search 的实现3：\ntemplate \u0026lt;class ForwardIterator, class T\u0026gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { first = std::lower_bound(first,last,val); return (first!=last \u0026amp;\u0026amp; !(val\u0026lt;*first)); } 调用了 std::lower_bound() 方法，这个方法就是在一个序列中找值为 val 的最小 index 位置，同理还有一个找最大 index 方法的函数 std::upper_bound()\ntemplate \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { ForwardIterator it; iterator_traits\u0026lt;ForwardIterator\u0026gt;::difference_type count, step; count = distance(first,last); while (count\u0026gt;0) { it = first; step=count/2; advance (it,step); if (*it\u0026lt;val) { // or: if (comp(*it,val)), for version (2)  first=++it; count-=step+1; } else count=step; } return first; } template \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { ForwardIterator it; iterator_traits\u0026lt;ForwardIterator\u0026gt;::difference_type count, step; count = std::distance(first,last); while (count\u0026gt;0) { it = first; step=count/2; std::advance (it,step); if (!(val\u0026lt;*it)) // or: if (!comp(val,*it)), for version (2)  { first=++it; count-=step+1; } else count=step; } return first; } 区别就是在更新 left = mid + 1 时，如果想取左边界，条件是 mid \u0026lt; val；如果想取右边界，条件是 mid \u0026lt;= val。\n处处是坑 # 知乎有一篇专栏文章：\u0026lt;聊聊一看就会一写就跪的二分查找\u0026gt;讲了二分中的各个坑点，我们逐一看一下：\nfunc FirstGreaterOrEqual(array []int, target int) int { // 初始化区间左端点： -1 || 0 || 1 ？  l := 0 // 初始化区间右端点： len(array) - 1 || len(array) || len(array) + 1 ?  r := len(array) // 当区间不为空时循环： l + 1 \u0026lt; r || l \u0026lt; r || l \u0026lt;= r || l \u0026lt;= r + 1 ?  for l \u0026lt; r { // 计算区间中点： l + (r - l) / 2 || l + (r - l + 1) / 2 ?  m := l + (r - l) / 2 // 将中点对应的元素同target比较： \u0026gt; || \u0026gt;= || \u0026lt; || \u0026lt;= ?  if array[m] \u0026lt; target { // 继续查找右侧这一半： m - 1 || m || m + 1 ?  l = m + 1 } else { // 继续查找左侧这一半： m - 1 || m || m + 1 ?  r = m } } // 这里应该是 l - 1 || l || l + 1 ?  // 这里应该是 r - 1 || r || r + 1 ?  return l } 这是一段 go 语言代码，不过不影响理解它的逻辑，其实它就是在 array 中找 target 的左边界。\n来一一解释作者提出的这些坑：\n  区间左端点 l = 0 或者其他？\n  区间右端点 r = len(array) 还是 len(array) - 1？\n  这两个是一个问题，整个区间有四种状态 (l, r) [l, r] (l, r] [l, r]\n对于数组从 0 开始的语言，左闭区间是合适的。\n右开右闭都是可行的，只需要在循环判断时做一下调整\n [l, r] -\u0026gt; l \u0026lt; r + 1 [l, r) -\u0026gt; l \u0026lt; r  一般来说，我们都会选择 l = 0 \u0026amp; [l, r) 这种组合。\n循环结束条件是 \u0026lt; 还是 \u0026lt;= 还是 !=  \u0026lt; 和 != 都可以，对于非递减序列来说，一般用 \u0026lt;。\n如果 l = r 时，仍然进入循环，同时如果 array[l] \u0026gt;= target，会导致循环无法退出。\n区间中间计算  l + (r - l + 1) / 2 这就属于是 ceil 操作。这个在前面也解释过，不再赘述。\n判断条件  同样的，取决于问题是取最左边的位置还是最右边的，上一节也解释过。\n返回值  结束条件是 l == r，所以返回 l 没有问题。但是这个位置并不一定能满足 array[l] == target，甚至于可能越界。\n返回值 l 表示：[0, l) 位置都是小于 target 的，而 [l, len) 则是大于等于 target 的。这里 l 可能等于 len (越界)。\n 所以在使用二分查找，来判断 target 是否存在时，要注意判断是否越界。\n 作者最后给了一种通用解决方案，将判断逻辑变成一个闭包方法作为参数传入，这样就可以得出多个二分变种问题的解法。\n总之，记模板 # 可见，想写对二分不容易，那么我们只记一种正确的写法，归纳成模板即可\n# template def _bsearch(a: List[int], x: int, l: int = 0, r: int = None) -\u0026gt; int: r = r or len(a) while l \u0026lt; r: m = l + (r - l) // 2 if a[m] \u0026lt; x: l = m + 1 else: r = m return l   Wikipedia\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Binary_search_algorithm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://www.cplusplus.com/reference/algorithm/binary_search/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"March 8 2022","permalink":"/leetcode/base/binary-search/","section":"算法专栏","summary":"\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-search.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e“二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 \u003ccode\u003eO(log n)\u003c/code\u003e，空间复杂度 \u003ccode\u003eO(1)\u003c/code\u003e，相比线性搜索优秀太多。\u003c/p\u003e\n\u003cp\u003e但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e能准确写对“二分”查找。\u003c/p\u003e","title":"很难写⌜正确⌟的二分查找"},{"content":"获取 Class 对象的方法有很多，本文主要是收集整理它们的区别以及探究具体的实现。\nclass 方法 # 有两种 class 方法，一个是实例方法，一个是类方法：\n@interface NSObject \u0026lt;NSObject\u0026gt; - (Class)class OBJC_SWIFT_UNAVAILABLE(\u0026#34;use \u0026#39;type(of: anObject)\u0026#39; instead\u0026#34;); + (Class)class OBJC_SWIFT_UNAVAILABLE(\u0026#34;use \u0026#39;aClass.self\u0026#39; instead\u0026#34;); @end 查看 runtime 的源码：NSObject.mm\n可以看到它们的实现：\n+ (id)self { return (id)self; } - (id)self { return self; } + (Class)class { return self; } - (Class)class { return object_getClass(self); } 所以，说给类对象发 class 消息，得到的是类本身 self，也就是\n [NSObject class] == [NSObject self]\n 给实例对象发 class 消息，相当于调用了 object_getClass\nobject_getClass # 那么这个方法的实现是怎么样的呢？\n同样查看 runtime 源码：objc-class.mm\nClass _Nullable object_getClass(id _Nullable obj)\nClass object_getClass(id obj) { if (obj) return obj-\u0026gt;getIsa(); else return Nil; } 调用了 类的 getIsa() 方法\n// objc-object.h\ninline Class objc_object::getIsa() { if (!isTaggedPointer()) return ISA(); uintptr_t ptr = (uintptr_t)this; if (isExtTaggedPointer()) { uintptr_t slot = (ptr \u0026gt;\u0026gt; _OBJC_TAG_EXT_SLOT_SHIFT) \u0026amp; _OBJC_TAG_EXT_SLOT_MASK; return objc_tag_ext_classes[slot]; } else { uintptr_t slot = (ptr \u0026gt;\u0026gt; _OBJC_TAG_SLOT_SHIFT) \u0026amp; _OBJC_TAG_SLOT_MASK; return objc_tag_classes[slot]; } } objc_getClass # 这个方法和上面的 object_getClass 长得很像，但还是有一些区别：\n  参数不一样，一个是 id，一个是 const char *，也就是一个传入是个类对象，一个是类名\n  实现不一样，一个调用的是 obj-\u0026gt;getIsa()，一个调用的是 loop_up_class()\n  // objc-runtime.mm\nClass objc_getClass(const char *aClassName) { if (!aClassName) return Nil; // NO unconnected, YES class handler  return look_up_class(aClassName, NO, YES); } 调用了 look_up_class:\n// objc-runtime-new.mm\nClass look_up_class(const char *name, bool includeUnconnected __attribute__((unused)), bool includeClassHandler __attribute__((unused))) { if (!name) return nil; Class result; bool unrealized; { runtimeLock.lock(); result = getClassExceptSomeSwift(name); unrealized = result \u0026amp;\u0026amp; !result-\u0026gt;isRealized(); if (unrealized) { result = realizeClassMaybeSwiftAndUnlock(result, runtimeLock); // runtimeLock is now unlocked  } else { runtimeLock.unlock(); } } if (!result) { // Ask Swift about its un-instantiated classes.  // We use thread-local storage to prevent infinite recursion  // if the hook function provokes another lookup of the same name  // (for example, if the hook calls objc_allocateClassPair)  auto *tls = _objc_fetch_pthread_data(true); // Stop if this thread is already looking up this name.  for (unsigned i = 0; i \u0026lt; tls-\u0026gt;classNameLookupsUsed; i++) { if (0 == strcmp(name, tls-\u0026gt;classNameLookups[i])) { return nil; } } // Save this lookup in tls.  if (tls-\u0026gt;classNameLookupsUsed == tls-\u0026gt;classNameLookupsAllocated) { tls-\u0026gt;classNameLookupsAllocated = (tls-\u0026gt;classNameLookupsAllocated * 2 ?: 1); size_t size = tls-\u0026gt;classNameLookupsAllocated * sizeof(tls-\u0026gt;classNameLookups[0]); tls-\u0026gt;classNameLookups = (const char **) realloc(tls-\u0026gt;classNameLookups, size); } tls-\u0026gt;classNameLookups[tls-\u0026gt;classNameLookupsUsed++] = name; // Call the hook.  Class swiftcls = nil; if (GetClassHook.get()(name, \u0026amp;swiftcls)) { ASSERT(swiftcls-\u0026gt;isRealized()); result = swiftcls; } // Erase the name from tls.  unsigned slot = --tls-\u0026gt;classNameLookupsUsed; ASSERT(slot \u0026gt;= 0 \u0026amp;\u0026amp; slot \u0026lt; tls-\u0026gt;classNameLookupsAllocated); ASSERT(name == tls-\u0026gt;classNameLookups[slot]); tls-\u0026gt;classNameLookups[slot] = nil; } return result; } NSClassFromString # 这个在 Foundation.framework 中的实现，并没有开源，\n函数原型是\nFOUNDATION_EXPORT Class _Nullable NSClassFromString(NSString *aClassName); 与 objc_getClass 参数一样，传入 Class 的名字，返回 Class 地址。\n有大佬通过研究汇编分析出它的具体实现：从汇编代码探究 NSClassFromString 实现\n最后 # 验证一下：\nStudent *stu = [Student new]; Class cls = [stu class]; NSLog(@\u0026#34;%p %p %p %p %p\u0026#34;, cls, [Student class], objc_getClass(\u0026#34;Student\u0026#34;), object_getClass(stu), NSClassFromString(@\u0026#34;Student\u0026#34;)); 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 可以看出来，这几种方法拿到的结果是一样的。\n","date":"February 23 2022","permalink":"/posts/2022/get-class/","section":"碎语闲言","summary":"\u003cp\u003e获取 \u003ccode\u003eClass\u003c/code\u003e 对象的方法有很多，本文主要是收集整理它们的区别以及探究具体的实现。\u003c/p\u003e","title":"[Runtime] 获取 OC Class 对象"},{"content":"   Meta 这个词在 2021 年下半年开始火爆，而后 Facebook 改名 Meta 引发各大科技公司跟风押注。似乎全球资本都在追逐“元宇宙”的概念，但什么是“元宇宙”，各家有各家的说法，没有一个统一的标准。\n 我个人感觉，元宇宙就是个伪概念。除了一堆跟风炒概念准备割韭菜的老庄家和引颈待收割的韭菜外，各个公司在做的与“元宇宙”相关的事，似乎都是一些“复古网络游戏”。\n 历史是一个轮回，唯有资本逐利是永恒的。个人断言，不出三年，这个概念应该就不会有人提了，一如 VR 的喧嚣与沉寂。\nMeta 的起源 # 以上只是个引子，与本文无关 (生硬的转折 😅\n本文继续讨论 Runtime，聚焦 OC 中的 MetaClass。\n一图胜千言，引用 Runtime 工程师 Greg Parker 在其博客中给出的经典图\n   为什么要这么设计 # 由于 OC 是 Smalltalk 语言哲学的一种实践，“在 Smalltalk 中，所有的值都是对象”。因此一个实例是对象，它的类也是一个对象。\n实例中的 isa 指针指向了它的类对象，那么类对象的 isa 指针指向谁呢？—— 指向它的元类对象 MetaClass！\n Since a class is an object, it must be an instance of some other class: a metaclass. 1\n 那么能不能不这么设计呢？\n当然能，但是这样就不那么 “Smalltalk” 了。非 Smalltalk 语言如 C++，与 OC 的一个重要区别是：\n C++ 支持多重继承\n Meta 与 继承关系 # 定义一对父类与子类：\n@interface Person : NSObject @end @interface Student : Person @end isa 链 # 定义一个子类的实例 Student *stu，根据之前的文章 class-object-isa，实例本质上是一个 objc_object 结构体，内部存在一个 isa 指针，指向的是 Student 这个类对象。\n而类对象 Student 本质上是一个 objc_class 结构体，继承自 objc_object，所以内部也有一个 isa 指针，类对象的 isa 指针指向的是它的元类对象。\n所以，这条链，也就是上图中最下面一行虚线所示：\n 实例 \u0026ndash;\u0026gt; 类 \u0026ndash;\u0026gt; 元类\n 那么元类的 isa 又指向谁呢，图中显示的是 根元类，通过代码来获取一下这条链：\nStudent *stu = [Student new]; NSLog(@\u0026#34;Student instance addr: %p\u0026#34;, stu); Class cls = [stu class]; NSLog(@\u0026#34;Student class addr: %p\u0026#34;, cls); id rootMetaClass = nil; while (cls) { NSLog(@\u0026#34;isa: %s addr: %p\u0026#34;, object_getClassName(cls), cls); Class tmp = object_getClass(cls); if (tmp == cls) { rootMetaClass = cls; break; } cls = tmp; } NSLog(@\u0026#34;root MetaClass: %p\u0026#34;, rootMetaClass); \u0026ndash;\u0026gt;\nStudent instance addr: 0x100668810 Student class addr: 0x10000e7b8 isa: Student addr: 0x10000e7b8 isa: NSObject addr: 0x10000e790 isa: NSObject addr: 0x7fff806e7060 root MetaClass: 0x7fff806e7060 可以看出来，元类对象最终指向的是根元类对象，但它的名字也叫 NSObject，同时根元类的 isa 是指向自身的，所以最终形成了闭环。\n 实例 \u0026ndash;\u0026gt; 类 \u0026ndash;\u0026gt; 元类 \u0026ndash;\u0026gt; 根元类 ↩️\n    继承链 # 再来看一下继承关系，\nClass cls = [stu class]; id rootClass = nil; while (cls) { NSLog(@\u0026#34;class: %s addr: %p\u0026#34;, object_getClassName(cls), cls); if (!class_getSuperclass(cls)) { rootClass = cls; } cls = class_getSuperclass(cls); } NSLog(@\u0026#34;rootClass: %p\u0026#34;, rootClass); \u0026ndash;\u0026gt;\nclass: Student addr: 0x10000e7b8 class: Person addr: 0x10000e768 class: NSObject addr: 0x7fff806e7088 rootClass: 0x7fff806e7088 继承链比较简单：\n 子类 -\u0026gt; 父类 -\u0026gt; 根类 -\u0026gt; nil\n    可以看出来根类没有父类，顺便我们看一下根类的 isa 指向哪里？\nNSLog(@\u0026#34;rootClass\u0026#39;isa: %p\u0026#34;, object_getClass(rootClass)); // rootClass\u0026#39;isa: 0x7fff806e7060 地址 0x7fff806e7060 与前面根元类 rootMetaClass 一样，这也证实了 根类 --\u0026gt; 根元类。\n  objc_explain_Classes_and_metaclasses\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"February 14 2022","permalink":"/posts/2022/meta-class/","section":"碎语闲言","summary":"\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-meta.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMeta 这个词在 2021 年下半年开始火爆，而后 Facebook 改名 Meta 引发各大科技公司跟风押注。似乎全球资本都在追逐“元宇宙”的概念，但什么是“元宇宙”，各家有各家的说法，没有一个统一的标准。\u003c/p\u003e","title":"[Runtime] 从 Meta 说起"},{"content":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。\n参考 OC 编译过程 我们可以借助 clang 工具将 OC 源码预处理成 CPP 来窥探 OC 的内部实现。\n定义一个简单的类：\n@interface Foo : NSObject @property (nonatomic, assign) BOOL ppty1; @property (nonatomic, copy) NSString *ppty2; - (BOOL)iMethod1; - (void)iMethod2:(NSString *)p1; + (void)cMethod1; @end 通过命令 clang -rewrite-objc xx.m 得到一个 9 万多行的 cpp 文件 😱\nhttps://gist.github.com/ryderfang/75a852f1ae0961aeea97127f7d9ca6c5\nTL;DR # 太长不看版：\n 🧸 objc_object 是所有实例对象的底层结构，内部只有一个 isa\n  🎁 objc_class 是所有类/元类对象的底层结构，它也有一个 isa 指针，指向自己的元类\n     OC 1.0 OC 2.0     id 实例 typedef struct objc_object *id; typedef struct objc_object *id;   objc_object struct objc_object {} struct objc_object {}   Class 类 typedef struct objc_class *Class; typedef struct objc_class *Class;   objc_class struct objc_class {} struct objc_class : objc_object {}     Class 是什么 # Class 1.0 # 在 \u0026lt;objc/objc.h\u0026gt; 中有这样一行：\ntypedef struct objc_class *Class;\n在 iOS 15 之前 \u0026lt;objc/runtime.h\u0026gt; 中曾经有 objc_class 的定义：\nhttps://opensource.apple.com/source/objc4/objc4-750/runtime/runtime.h.auto.html\n/* Types */ #if !OBJC_TYPES_DEFINED  struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__  Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif  } OBJC2_UNAVAILABLE; /* Use `Class` instead of `struct objc_class *` */ #endif 目前我使用的 Xcode 13.2.1 中已经找不到这个定义，也就是说在 macOS 12.1 / iOS 15.2 中，OBJC1 已经被完全废弃。\n Hint: 按照官方文档 Runtime Version 的解释, legacy 版本 (OC 1.0) 在 2007 年就完全废弃了，所有 iPhone 和 OSX 10.5 以后的 Mac 上使用的都是 modern 版本 (OC 2.0)!\n  根据 wiki 的说明，OC 2.0 于 2006 年发布，而 iPhone 第一代 是在 2007 年发布的，Mac OS X 10.5 Leopard 也是在 2007 年上市。\n 从这个宏 OBJC2_UNAVAILABLE 可以看出来 OBJC2 这种定义会失效。那么 OBJC2 是什么？\nClass 2.0 # 在 objc-runtime-new.h 中定义了 objc_class 的 2.0 版本：\nstruct objc_class : objc_object { // Class ISA;  Class superclass; cache_t cache; // formerly cache pointer and vtable  class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags  class_rw_t *data() { return bits.data(); } ... } 参考 1 和 2\n了解到，苹果在 2006 年重写了 runtime，发布了新的 Runtime 2.0，那么 __OBJC2__ 这个宏是什么时候生效的呢？\n通过查找苹果公开的 runtime 源码：https://opensource.apple.com/source/objc4/ 发现：\n从 objc4-750 这个版本开始，在 objc-config.h 中开始有了 __OBJC2__ 的定义！\n// Define __OBJC2__ for the benefit of our asm files. #ifndef __OBJC2__ # if TARGET_OS_OSX \u0026amp;\u0026amp; !TARGET_OS_IOSMAC \u0026amp;\u0026amp; __i386__  // old ABI # else # define __OBJC2__ 1 # endif #endif 来自 apple 的 commit：\n   https://github.com/apple-oss-distributions/objc4/commit/26c7408b94ead1f04a0b5976e354a03966ce61ea\n在 objc-api.h 中定义了 OBJC_ISA_AVAILABILITY:\n/* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable * in the future */ #if !defined(OBJC_ISA_AVAILABILITY) # if __OBJC2__ # define OBJC_ISA_AVAILABILITY __attribute__((deprecated)) # else # define OBJC_ISA_AVAILABILITY /* still available */# endif #endif 在 objc-private.h 中同时定义了 OBJC_TYPES_DEFINED:\n/* Isolate ourselves from the definitions of id and Class in the compiler * and public headers. */ #ifdef _OBJC_OBJC_H_ #error include objc-private.h before other headers #endif  #define OBJC_TYPES_DEFINED 1 同时也定义了 Class 和 id\ntypedef struct objc_class *Class; typedef struct objc_object *id; 所以，不管 OC 1.0 还是 2.0，\n Class 都是一个叫 objc_class 的结构体指针。\n Object 与 id # 在 \u0026lt;objc/objc.h\u0026gt; 中，定义\nhttps://opensource.apple.com/source/objc4/objc4-750/runtime/objc.h.auto.html\nObject 1.0 # #if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; #endif 同样被包在 OBJC_TYPES_DEFINED 宏中，也就是 OC 2.0 并不生效。\n那么，OC 2.0 的 objc_object 是什么样的呢，在 objc-private.h 中定义了：\nObject 2.0 # struct objc_object { private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object  Class ISA(); // initIsa() should be used to init the isa of new objects only.  // If this object already has an isa, use changeIsa() for correctness.  // initInstanceIsa(): objects with no custom RR/AWZ  // initClassIsa(): class objects  // initProtocolIsa(): protocol objects  // initIsa(): other objects  void initIsa(Class cls /*nonpointer=false*/); void initClassIsa(Class cls /*nonpointer=maybe*/); void initProtocolIsa(Class cls /*nonpointer=maybe*/); void initInstanceIsa(Class cls, bool hasCxxDtor); // 省略大量方法  private: void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor); // 省略大量方法` }; 可以看出来不管 OC 1.0 还是 2.0,\n objc_object 都是一个包含着一个叫 isa 指针/变量 的对象。\n isa 又是什么 # 在 1.0 版本中 isa 就是一个 Class 对象，也就是一个指向 objc_class 的指针，而在 2.0 时，isa 是一个叫 isa_t 的结构体变量。\n那么 isa_t 是什么呢？\n同样在 objc-private.h 中有定义：\nunion isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } uintptr_t bits; private: // Accessing the class requires custom ptrauth operations, so  // force clients to go through setClass/getClass by making this  // private.  Class cls; public: #if defined(ISA_BITFIELD)  struct { ISA_BITFIELD; // defined in isa.h  }; bool isDeallocating() { return extra_rc == 0 \u0026amp;\u0026amp; has_sidetable_rc == 0; } void setDeallocating() { extra_rc = 0; has_sidetable_rc = 0; } #endif  void setClass(Class cls, objc_object *obj); Class getClass(bool authenticated); Class getDecodedClass(bool authenticated); }; 参考 1 的图：\n   作为一个 union 结构，与 struct 区别在于，成员之间会互相覆盖，union 的总内存占用等于最大的成员占用的内存大小，而 struct 大小至少是成员内存占用之和，如果需要字节对齐则会更大。\n所以采用 union 结构可以节省内存。\n在 objc-object.h 中，有 objc_object::initIsa() 的实现：\ninline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { ASSERT(!isTaggedPointer()); if (!nonpointer) { isa = isa_t((uintptr_t)cls); } else { ASSERT(!DisableNonpointerIsa); ASSERT(!cls-\u0026gt;instancesRequireRawIsa()); isa_t newisa(0); #if SUPPORT_INDEXED_ISA  ASSERT(cls-\u0026gt;classArrayIndex() \u0026gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE  // isa.nonpointer is part of ISA_MAGIC_VALUE  newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-\u0026gt;classArrayIndex(); #else  newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE  // isa.nonpointer is part of ISA_MAGIC_VALUE  newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls \u0026gt;\u0026gt; 3; #endif  // This write must be performed in a single store in some cases  // (for example when realizing a class because other threads  // may simultaneously try to use the class).  // fixme use atomics here to guarantee single-store and to  // guarantee memory order w.r.t. the class index table  // ...but not too atomic because we don\u0026#39;t want to hurt instantiation  isa = newisa; } } 可以看出 isa_t 中的 Class 与 bits 是互斥的，避免了互相覆盖的问题。\n  https://halfrost.com/objc_runtime_isa_class/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://kangzubin.com/objc1.0-class-object/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"January 4 2022","permalink":"/posts/2022/class-object-isa/","section":"碎语闲言","summary":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。","title":"[Runtime] Class, Object 与 isa"},{"content":"   本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章：\nResponding to the Launch of Your App\n有个主要的流程图：\n  ref: About the App Launch Sequence\n 另外，还有一篇介绍如何优化启动速度的文章: Reducing Your App’s Launch Time ，毕竟只有准确了解了启动中做了哪些事，才能更针对地进行优化。\n这里还参考了以下几篇文章：\n[1]: iOS App 启动优化\n[2]: iOS App 从点击到启动\n[3]: 深入了解 App 启动过程\n总结一下，整个启动过程分成四步：\n1. 系统内核加载 #  应用程序由系统内核 XNU 加载，与此同时会加载一个叫 dyld的程序。\n 内核主要做了这几件事：\n  创建进程\n  加载解析可执行文件 (exec_activate_image)1: 主要工作是对 Mach-O 进行检查，并将文件复制到内存中。\n  接下来会根据 Mach-O 的 load commands 中指定的信息来加载启动 dyld\n  更加详细深入的信息可以参加滴滴技术公众号上的两篇：\nXNU、dyld 源码分析，Mach-O 和动态库的加载过程 (上)\nXNU、dyld 源码分析，Mach-O 和动态库的加载过程 (下)\nMach-O 格式2：\n Mac 与 iOS 仅在应用层实现上有一些差别，可执行文件的格式也都是 Mach-O 的。所以，Mac App 与 iOS App 启动流程是差不多的。\ngraph TD A(Cocoa) -- | Mac | B(Media) E(Cocoa Touch) -- | iOS | B B -- C(Core Services) C -- D(Core OS)  2. pre-main 阶段 # 这里指 main 函数之前，内核加载 app 之后的一些事。主要是 dyld 的工作：\n 加载程序所需的动态库  包括分析依赖、验证有效性 (是否符号当前系统架构)，使用 ImageLoader 加载进内存\n rebase/rebind  为了安全性，苹果采用了 ASLR (Address space layout randomization)3 技术，这样 app 实际加载地址会有偏移。\n需要通过 rebase 对所有指向进程内的符号进行地址调整，同时使用 bind 处理 dylib 外部的符号。\n ObjC setup  Runtime 的初始化，ObjC 类的注册，selector 唯一性检查，Category 注册，Protocol 读取等。\n Initializers  这一阶段会调用所有类的 load 方法，执行带 attribute((constructor)) 修饰的 C++ 方法，非基本类型 C++ 静态变量创建\n可以在 iOS 任一对象的 load 方法处打断点，获得如下堆栈信息4：\n0 +[AppDelegate load] 1 call_load_methods 2 load_images ... 3 dyld::notifySingle(dyld_image_states, ImageLoader const*) 4 ImageLoader::recursiveInitialization(...) 5 ImageLoader::processInitializers(...) 6 ImageLoader::runInitializers(...) 7 dyld::_main(...) 8 dyldbootstrap::start(...) 9 _dyld_start 3. main 方法 # 这个阶段是指从 main 函数开始到 -[UIApplicationDelegate application:didFinishLaunchingWithOptions:] 中首屏渲染完成之前的事。\n  初始化各种配置，如 info.plist，UserDefaults 等等\n  各种 sdk、日志系统初始化\n  用于首屏数据展示的网络请求\n  首屏渲染计算\n  4. 首屏渲染后 # 这里用户已经感知到 app 启动了，一般来说，会初始化一些非首屏功能的模块。\n后记 # 了解了启动流程，就必须要继续研究如何加快 app 启动速度。一般来说，我们只能在上述第 2，3 两步尽可能做一些优化。\n参考下一篇：\n还能更快吗之启动优化\n  https://juejin.cn/post/6844903511612899336\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/aidansteele/osx-abi-macho-file-format-reference\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Address_space_layout_randomization\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.jianshu.com/p/c0a1a3ad9336\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"December 28 2021","permalink":"/posts/2021/app-launch-process/","section":"碎语闲言","summary":"本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章：","title":"发生在用户点击 App Icon 之后"},{"content":"概述 # Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。\n当我们在讲 Runtime 的时候，我们在说什么？\n根据官方文档的定义，\nObjective-C Runtime\nObjective-C Runtime Programming Guide\nRuntime 是一个动态库 (/usr/lib/libobjc.A.dylib)，用于实现 OC 语言的动态性。\n这个动态性主要体现在三个方面 ref:\n 动态类型 (Dynamic Typing): 运行时才能决定对象的类型，也就是说编译器不检查类型合法性 动态绑定 (Dynamic Binding): 运行时才能知道方法被如何执行，也就是消息机制 (messaging) 动态加载 (Dynamic Loading): 允许动态添加类、方法等  起源 # 孙源大佬在 博客 中说过，OC1 其实是 C 语言与 SmallTalk2 思想结合的产物。\n与同属 SmallTalk 学派的语言 Java, Python 和 Ruby 一样，OC 具有面向对象、动态类型和反射式等特点。\n Objective-C = C + Preprocessor + Runtime\n SmallTalk 领先了时代 20 年，至今 OC 仍然没有实现它的全部特性。\nRuntime Version # 存在两个版本的 Runtime，modern 和 legacy：\ndeveloper.apple.com/ObjCRuntimeGuide/ocrtVersionsPlatforms\n按照官方的说明，所有 iPhone 和 10.5 版本之后的 Mac OSX 64 位程序都使用的 OC 2.0。\nRuntime 源码: https://opensource.apple.com/source/objc4/\n下载 tarballs: https://opensource.apple.com/tarballs/objc4/\n可调试项目: https://github.com/RetVal/objc-runtime\nRuntime 里有什么 # Runtime 的源码可以在 RetVal/objc-runtime 这里找到，甚至可以 Debug。\n主要包含如下几个方面，后续会逐个总结。\nClass/Object 与 isa # 参考：Class Object 与 isa\nMetaClass #   元类指向链: 实例 -\u0026gt; 类 -\u0026gt; 元类 -\u0026gt; 根元类 -\u0026gt; 根元类 (isa 指向自己) 类的继承链: 子类 -\u0026gt; 父类 -\u0026gt; NSObject -\u0026gt; nil 元类的继承链: 子类元类 -\u0026gt; 父类元类 -\u0026gt; 根元类 -\u0026gt; NSObject -\u0026gt; nil   参考：从 Meta 说起\nMethod/IMP/SEL # Category # Messaging # Swizzling # 其它常用方法 # ++++++\n  https://zh.wikipedia.org/wiki/Objective-C\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://zh.wikipedia.org/zh-hans/Smalltalk\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"December 28 2021","permalink":"/posts/2021/what-is-runtime/","section":"碎语闲言","summary":"概述 # Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。","title":"ObjC 之 Runtime 是个啥"},{"content":" 本文可以作为面试八股的准备指南\n  很早之前看过一个 前端 Roadmap，图做的非常漂亮。最近发现有人做了类似的 移动端 Roadmap，\n其中 iOS 是这样的：\n   还有 Swift 的，暂时先不关注了。这里综合一下形成文字版，方面查缺补漏。\n   iOS 的体系结构如下图：\n    Ref: iOS abstraction layers\n 需要重点关注的有下面几个方面：\n   demo 工程：https://github.com/ryderfang/iosBagu  Foundation # ARC/MRC 与 内存管理 # ARC is supported in Xcode 4.2 for OS X v10.6 and v10.7 (64-bit applications) and for iOS 4 and iOS 5.\n现在除了一些老项目，基本没有 MRC 为主的代码了，所以只需要简单了解下 MRC 与 ARC 的区别即可\n  MRC 需要手动写 dealloc，并且一定要最后再调用父类的 dealloc； ARC 一般不需要写 dealloc，也不需要调用 [super dealloc]。移除 NSNotification Observer 和 KVC Observer 例外。\n  在 ARC 的工程中使用 MRC，需要在工程中设置源文件的编译选项 -fno-objc-arc\n    Tagged Pointer\n  OC 对象与 CF 对象转换\n __bridge, __bridge_retained, __bridge_transfer    AutoReleasePool #   AutoReleasePool 的数据结构\n  AutoReleasePool 与 @autoreleasepool\n  Block 🔥 #   __weak 与 __block\n  block 的结构体类型\n  block 如何捕获外部变量\n  循环引用 与 Weak-Strong Dance\n  Category 🔥 #   load 加载时机\n  load 与 initialze\n  方法加载时机\n  如何添加属性 - 关联对象\n  category 与 class-extension\n  category 覆盖原类方法的原理\n  category 同名方法调用顺序\n  HotPatch #  JSPatch 的原理  KVC 与 KVO #   KVC 是如何实现的\n  KVO 的原理\n  如何对 NSMutableArray 进行 KVO\n mutableArrayValueForKey    KVC 与 KVO 有什么联系与区别\n  MultiThread 多线程 🔥 #   哪些多线程方法\n  GCD 与 NSThread, NSOperationQueue\n  互斥锁与自旋锁\n  Network 🔥 #   NSURLSession 与 NSURLConnection\n  常用网络库\n  AFNetworking (ObjC)\n  Alamofire (Swift)\n    NSTimer 🔥 #   timer 与 Runloop\n  timer 导致循环引用的产生与解决\n  Property 🔥 #   不指定任何关键字时，默认的类型：\n OC 对象：atomic, readwrite, strong 数值对象：atomic, readwrite, assign    不同属性的区别\n    atomic/nonatomic readonly/readwrite (retain, MRC)/assign/weak/strong/unsafe_unretained/copy     copy 与 assign\n  weak 与 copy\n  weak 与 __unsafe_unretained\n  atomic 并不是线程安全的\n  如何实现一个弱引用容器\n + [NSPointerArray weakObjectsPointerArray] 弱引用数组 + [NSMapTable weakToWeakObjectsMapTable] 弱引用表 + [NSHashTable weakObjectsHashTable] 弱引用 hash 表 + [NSValue valueWithNonretainedObject:] 弱引用对象    Runloop 🔥 #   Runloop 与线程的关系\n  mode\n  source0 \u0026amp; source1\n  如何实现一个常驻线程\n  用 runloop 监听主线程卡顿\n  Runtime 🔥 # 系列文章：Runtime 是个啥？\n  Method Swizzling\n  从 Meta 说起\n  Class, Object 与 isa\n  运行时，动态添加一个类\n  消息转发\n  NSObject 与 \u0026lt;NSObject\u0026gt;\n  其他知识 #   NSNotification 原理\n  id 与 instancetype\n  nil, Nil, NULL, NSNull\n  NSPredicate 谓词\n  APNS (Apple Push Notification Service) 原理\n  UIKit # UIView 与 CALayer #   bounds 与 frame\n  setNeedsDisplay 与 layoutIfNeeded\n  常用 UI 组件 #   UIScrollView\n  UITableView\n cell 复用原理    UICollectionView\n  AutoLayout #   Masonary 原理\n  VFL 语法\n  约束 Constraints\n  UIResponder #   touch events\n  hitTest / pointsInside\n  事件传递与响应链\n  离屏渲染 #  layoutSubview 与 drawRect  性能优化 #   图片渲染过程\n  卡顿优化\n  Core 系列 # Core Graphics #  高效绘制圆角  Core Data # AVFoundation # 架构能力 # 设计模式 # 架构模式 #   MVC\n  MVP\n  MVVM\n  响应式编程 # 重构与解耦 # 组件化 #  更多面试题：\n https://github.com/LGBamboo/iOS-Advanced https://www.jianshu.com/p/e709fde38de3 https://www.jianshu.com/p/d9a39ab1d526     ","date":"December 23 2021","permalink":"/posts/2021/objc-roadmap/","section":"碎语闲言","summary":"\u003cdiv class=\"!mb-9 text-xl lead\"\u003e\n  \u003cblockquote\u003e\n\u003cp\u003e本文可以作为面试八股的准备指南\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e很早之前看过一个 \u003ca href=\"https://github.com/kamranahmedse/developer-roadmap\"\u003e前端 Roadmap\u003c/a\u003e，图做的非常漂亮。最近发现有人做了类似的 \u003ca href=\"https://github.com/godrm/mobile-developer-roadmap\"\u003e移动端 Roadmap\u003c/a\u003e，\u003c/p\u003e\n\u003cp\u003e其中 iOS 是这样的：\u003c/p\u003e","title":"ObjC 之 技术路线图"},{"content":"时隔两年，再次拾起博客。\n我完全不是一个有恒心的人，而且做什么事都是三分钟热度。包括博客，从 Jekyll 到 Hexo，再到现在 Hugo。\n有新鲜玩意都想把玩一下，折腾完了又觉得索然无味。注重形式大于内容，纠结字体字号、各种样式的事情，反而没什么内容沉淀下来。\n关于博客 # 在腾讯云买了域名 ryderfang.com，然后折腾备案、SSL 证书部署、nginx 配置静态页面等等， 目前源文件拖管在 Github 上，每次 push 自动触发 Actions， 完成编译并推送到 gh-pages 分支的操作。站内搜索使用 algolia，使用手动 Actions 的方式，需要时触发更新。\n同样在腾讯云买了一个轻应用服务器，托管一下这个静态博客，不打算再折腾自动化了，需要同步的时候 ssh 登录一下，手动拉一下 repo 就好。\n 哈哈，总是在打脸，还是把自动同步服务器做成了一个 Action\n - name: remote ssh command uses: appleboy/ssh-action@master with: host: ${{ secrets.TENCENT_CLOUD_HOST }} username: ubuntu key: ${{ secrets.TENCENT_CLOUD_KEY }} port: 22 script: | whoami cd blog \u0026amp;\u0026amp; git pull echo \u0026#39;Done!\u0026#39; 再把之前的博客内容整理到新的博客上，发现并没多少值得保留的，真是有点惭愧。\n技术目标 # 常常想起小时候爸爸告诫我的话：\n 有志之人立常志，无志之人常立志。\n 但是，这么多年的工作经历，让我认识到自己只是个普通人。普通的技术、普通的能力和普通的志向，甚至于在 “内卷” 与 “躺平” 的浪潮中，已经逐渐想要躺平。\n最近又看到一句话：\n 到底什么样的终点，才配得上这一路的颠沛流离 ?!\n 是啊，或许，我们只是想去码头整点薯条，人生本无太多意义。\n   扯远了，总之，普通人就定几个能完成的普通目标。也不要过分自责，因为你就是一粒宇宙的尘埃。\n写文章 # 到年底还有一个多月，输出 2-3 篇技术博客。\n UPDATE: 算完成 80% 吧，内容还需要补充\n iOS 技术栈 # 继续完善 iOS 八股技术栈: https://github.com/ryderfang/iOSBagu，尽可能去了解一些犄角旮旯的知识点。\n UPDATE: 没有完成，需要尽快补齐\n 读书 # 读一点其他领域的书，随便看一点。\n UPDATE: 没有完成，多读书是 2022 重点目标\n 生活目标 # 健康 # 身体 NO.1，换季的时候，一家人都得了咽炎，去医院太折腾了。希望全家都健康，宝宝也快点长大，少让姥姥和大家操点心吧。\n UPDATE: 安安越来越大了，前段时间脸上又被虫咬了一大块，最近快长好了。\n  平安、健康、快乐，足矣。没有别的希冀。\n 早起 # 每天送老婆上班，虽然累，但还是挺好的，早到公司一小时，可以做很多事了。困的问题就中午多午睡一会儿吧。\n能睡说明自己还年轻吧，至少没有失眠的困扰，感觉至少要睡十个小时才能满足，也只能周末才有这个机会了。\n UPDATE: 本来年底想面试一下来年换个工作，但老婆可能也要换，准备还是继续苟一段时间。\n  总的来说，鹅厂的人文关怀还是可以的。但不同项目组也差异很大，PCG 确实是个天坑。\n 结语 # 就这些吧，我感觉能完成 80% 就已经很不错了。元旦的时候再来 check 一下 🚀\n","date":"November 16 2021","permalink":"/posts/2021/2021-personal-challeng/","section":"碎语闲言","summary":"\u003cp\u003e时隔两年，再次拾起博客。\u003c/p\u003e","title":"2021 个人目标 🎯"},{"content":"G’day, I’m Ryder! 👋 # 互联网游荡者，历经 \u0026lsquo;BAT\u0026rsquo; 三家公司，现任鹅厂废柴搬砖工。\nI worked at Bilibili, Alibaba and now Tencent, still too vegetable to be a senior coder.\nNow I\u0026rsquo;m living with my wife and little son in Shanghai, China.\n Life is too short, Just enjoy it.\n 经历 # 🐧 腾讯科技（上海）有限公司  客户端开发 2019.11 - Now 手 Q 开发  相机渲染，道具特效等 图片、视频编辑 AI 端智能    🚼 口碑（上海）信息技术有限公司 | 阿里巴巴  高级无线开发工程师 2017.10 - 2019.11 口碑掌柜  业务开发、投放体系建设 Lottie 接入 阿里云语音SDK   技术专项  端 AI 智能算法 H5 容器相关    🏝 上海哔哩哔哩科技有限公司 | 幻电信息科技  iOS 开发工程师 2016.04 - 2017.10 iOS 客户端  C++ 转 iOS 开发 业务开发，视频收藏夹 图片治理，webP 接入等   UGC 投稿助手  QT \u0026amp; C++ 开发 多线程视频文件上传 稿件管理功能等    📟 上海二三四五网络科技有限公司  2013.12 - 2016.04 2345 单核/双核 浏览器  浏览器业务开发 逆向技术、Flash 兼容 广告拦截技术   看图王、好压  DirectUI C++ 多线程开发    +++\n","date":"November 11 2021","permalink":"/about/","section":"","summary":"G’day, I’m Ryder!","title":"About"},{"content":"   年代久远，内容不再保正。  之前用的 bangwagon 突然连不上了，找到现在可用的官网 (https://bwh88.net/clientarea.php?action=products) 看了下，服务虽然到期了，但整个 Service 被停用了。\n   发了个 Ticket 问了下，倒是很快回复了。结论就是我之前买的那种 10G 的产品是 OpenVZ v6 架构，已经不再维护，下架了。 看了下，现在最便宜的就是 20G 这款，一年 50 美金，差不多也是行情价。\n   考虑到 bandwagon 配置并不是特别方便，经同事推荐改用 Vlutr，现在优惠还不错 (重点)：\n1、充 $10 送 $25。 点击注册\n2、充 $25 送 $50。 点击注册\n最关键的是，支持 支付宝 付款！\n注册 # 注册非常简单，点击上面的链接，用邮箱注册即可。都不用激活，方便的一比。\n充值 # 登录之后，在 https://my.vultr.com/billing/ 页面，选择 Alipay (支付宝)，充 $25，搞定！\n $25 足够用 5 个月了！\n    买机器 # 进入 https://my.vultr.com/deploy/\n 地区 选欧洲或者美国的，相对快一点。 操作系统 选 Ubuntu, 版本 18.04 x64。(因为这是 LTS 版本，相对稳定点) 机器类型选最便宜的 $5/月 的。  其他不用管，直接 Deploy 吧。\n配置 # 等机器准备好，在 Products 页面中找到你的机器 IP 地址、密码等信息。打开本地终端， ssh root@ip -p 22 输入密码，登录远程机器。\n通过脚本一键安装 SS 服务端即可。\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2\u0026gt;\u0026amp;1 | tee shadowsocks.log 设置端口号、密码等，等脚本执行完。 这里有个坑，脚本里 shadowsocks.json 里配置的服务器地址是 0.0.0.0，有 Vlutr 环境里好像不通，我之前用 bandwagon 不用改，但是 Vlutr 不行。\nvim /etc/shadowsocks.json // 把里面的 \u0026#34;server\u0026#34; 字段修改为服务器的 IP 址。 在本地，用 SS 服务端，设置好同样的 IP 地址、端口号和密码即可。\n至此，就可以去浪了！🌊🌊🌊\n","date":"September 10 2019","permalink":"/posts/2019/shadowsocks-with-vlutr/","section":"碎语闲言","summary":"年代久远，内容不再保正。  之前用的 bangwagon 突然连不上了，找到现在可用的官网 (https://bwh88.","title":"从搬瓦工到 Vlutr 继续冲浪"},{"content":"这是干啥的 # 敏感你懂的，不多谈。🌝\n   年代久远，内容不再保正。  怎么用 #  下载 ShadowsocksX-NG，  https://github.com/shadowsocks/ShadowsocksX-NG/releases/\n  配置自己的 VPS，比如我自己使用的 Bandwagon VPS，或者使用其他 SS server 地址\n  在 ShadowsocksX-NG 中添加服务器，配置好可以 FQ 了。\n  搬瓦工 # 目前可用的主页地址是\nhttps://bwh1.net/clientarea.php?action=products\n我买的最便宜的一个 10G VZ - PROMO，一个月 $2.99，但年付才 $19.99 (130 软妹币) 而已。\n每月流量 550GB 根本用不完\n有需要的朋友，如果不想自己配置，可以给我转 ￥10 (一个月)，我把我的 VPS 共享给你。\n配置项 # 在 ShadowsocksX-NG 的服务器配置中，导入如下配置即可\n{ \u0026#34;random\u0026#34; : false, \u0026#34;authPass\u0026#34; : null, \u0026#34;useOnlinePac\u0026#34; : false, \u0026#34;TTL\u0026#34; : 0, \u0026#34;global\u0026#34; : false, \u0026#34;reconnectTimes\u0026#34; : 3, \u0026#34;index\u0026#34; : 0, \u0026#34;proxyType\u0026#34; : 0, \u0026#34;proxyHost\u0026#34; : null, \u0026#34;authUser\u0026#34; : null, \u0026#34;proxyAuthPass\u0026#34; : null, \u0026#34;isDefault\u0026#34; : false, \u0026#34;pacUrl\u0026#34; : null, \u0026#34;configs\u0026#34; : [ { \u0026#34;enable\u0026#34; : true, \u0026#34;password\u0026#34; : \u0026#34;****\u0026#34;, \u0026#34;method\u0026#34; : \u0026#34;aes-256-cfb\u0026#34;, \u0026#34;remarks\u0026#34; : \u0026#34;Bandwangon\u0026#34;, \u0026#34;server\u0026#34; : \u0026#34;**.**.**.**\u0026#34;, \u0026#34;kcptun\u0026#34; : { \u0026#34;nocomp\u0026#34; : false, \u0026#34;key\u0026#34; : \u0026#34;****\u0026#34;, \u0026#34;crypt\u0026#34; : \u0026#34;salsa20\u0026#34;, \u0026#34;datashard\u0026#34; : 70, \u0026#34;mtu\u0026#34; : 1350, \u0026#34;mode\u0026#34; : \u0026#34;fast2\u0026#34;, \u0026#34;parityshard\u0026#34; : 30, \u0026#34;arguments\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;enabled_kcptun\u0026#34; : true, \u0026#34;server_port\u0026#34; : 29900, \u0026#34;remarks_base64\u0026#34; : \u0026#34;QmFuZHdhbmdvbg==\u0026#34; } ], \u0026#34;proxyPort\u0026#34; : 0, \u0026#34;randomAlgorithm\u0026#34; : 0, \u0026#34;proxyEnable\u0026#34; : false, \u0026#34;enabled\u0026#34; : true, \u0026#34;autoban\u0026#34; : false, \u0026#34;proxyAuthUser\u0026#34; : null, \u0026#34;shareOverLan\u0026#34; : false, \u0026#34;localPort\u0026#34; : 1080 }  附录 #  一些命令\n $ /usr/bin/python /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start # /etc/shadowsocks.json { \u0026#34;server\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, \u0026#34;server_port\u0026#34;:8989, \u0026#34;local_address\u0026#34;:\u0026#34;127.0.0.1\u0026#34;, \u0026#34;local_port\u0026#34;:1080, \u0026#34;password\u0026#34;:\u0026#34;****\u0026#34;, \u0026#34;timeout\u0026#34;:300, \u0026#34;method\u0026#34;:\u0026#34;aes-256-cfb\u0026#34;, \u0026#34;fast_open\u0026#34;:false }  kcp config\n { \u0026#34;listen\u0026#34;: \u0026#34;:29900\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;127.0.0.1:8989\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;****\u0026#34;, \u0026#34;crypt\u0026#34;: \u0026#34;salsa20\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;fast2\u0026#34;, \u0026#34;mtu\u0026#34;: 1350, \u0026#34;sndwnd\u0026#34;: 1024, \u0026#34;rcvwnd\u0026#34;: 1024, \u0026#34;datashard\u0026#34;: 70, \u0026#34;parityshard\u0026#34;: 30, \u0026#34;dscp\u0026#34;: 46, \u0026#34;nocomp\u0026#34;: false, \u0026#34;acknodelay\u0026#34;: false, \u0026#34;nodelay\u0026#34;: 0, \u0026#34;interval\u0026#34;: 40, \u0026#34;resend\u0026#34;: 0, \u0026#34;nc\u0026#34;: 0, \u0026#34;sockbuf\u0026#34;: 4194304, \u0026#34;keepalive\u0026#34;: 10 }  数据流\n    ","date":"June 21 2018","permalink":"/posts/2018/shadow-socks-and-bandwagon/","section":"碎语闲言","summary":"这是干啥的 # 敏感你懂的，不多谈。🌝","title":"关于科学冲浪"},{"content":"Mark Zuckerberg 每年都会发布自己的年度挑战 Personal Challenge\n   So，我也要给自己立一些 Flag\u0026hellip;\n技术目标 # //\u0026lt;!-- --\u0026gt; console.log(\u0026#39;达到中初级前端工程师水平\u0026#39;) //\u0026lt;!-- --\u0026gt;  UPDATE: 并没有达到 😢\n 这将是技术广度拓宽的一年。\n最近几年，随着中年危机的提前到来，90年码农越来越焦虑，在知乎上的各种问题:\n35 岁以上的互联网 / 科技行业从业者面临裁员时，应如何规划职业发展？\n新时代的中年危机长啥样？\n30岁程序员的出路\n知乎圆桌 - 30 岁人生攻略\n等等\n很多人表达了这样一个观点，要想维持职场生命力，必须要努力掌握更深更广地技能。\n成为所谓的斜杠 (Slash) 青年，不再满足于单一职业，而是多元化发展。\n生活目标 # 早点睡觉 # 常年处于缺觉的状态，整个人都不好了\n TODO: 最好 11:30 pm 前睡觉\n 锻炼身体 # 小肚子减减减呀！\n家里收拾好 # 养了点花花草草，买了一只小龟龟，希望它明年还在\n UPDATE: 小龟龟被我养死了 😭\n 结婚吧 # 在一起快一年了，喜欢她的性格，也觉得该修成正果，安定下来了。\n UPDATE: 2018.12.01 相识 520 天，我们结婚啦！👫 💕💕\n","date":"January 29 2018","permalink":"/posts/2018/2018-personal-challenge/","section":"碎语闲言","summary":"\u003cp\u003eMark Zuckerberg 每年都会发布自己的年度挑战 \u003ca href=\"https://www.facebook.com/zuck/posts/10104380170714571\"\u003ePersonal Challenge\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-2018-Zuckerberg.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003eSo，我也要给自己立一些 Flag\u0026hellip;\u003c/p\u003e","title":"2018 个人目标 🎯"},{"content":"Chromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏\n   当然是因为好 zhuāng 用 bī 了 😅  废话少说，下载地址： https://download-chromium.appspot.com/\n如果下载不了，可以试下：\n  Windows https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/\n  Mac https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Mac/\n  打不开之类的需要翻墙的问题自行解决吧。\n问题 # 打开 Chromium 会提示 缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用 😒\n由于 Chromium 使用的 API 都需要自行申请密钥才能使用。\n所以 在 https://console.cloud.google.com/ 上创建密钥。\n相关文档：http://www.chromium.org/developers/how-tos/api-keys\n最后密钥有三个，位置在 https://console.cloud.google.com/apis/credentials\n GOOGLE_API_KEY GOOGLE_DEFAULT_CLIENT_ID GOOGLE_DEFAULT_CLIENT_SECRET  解决 # 官方的解决方法是：\n将下面三行写到 ~/.bash_profile 中，然后重启浏览器即可\nexport GOOGLE_API_KEY=\u0026#34;****\u0026#34; export GOOGLE_DEFAULT_CLIENT_ID=\u0026#34;**** export GOOGLE_DEFAULT_CLIENT_SECRET=\u0026#34;****\u0026#34; $source ~/.bash_profile 这样，有时是管用的。特别是在 Windows上，使用类似的在命令行输入：\nsetx GOOGLE_API_KEY your_key_goes_here setx GOOGLE_DEFAULT_CLIENT_ID your_client_id_goes_here setx GOOGLE_DEFAULT_CLIENT_SECRET your_client_secret_goes_here 但是 Mac 上有时不管用，参考:\nhttps://gist.github.com/cvan/44a6d60457b20133191bd7b104f9dcc4\n在文档最后，发现有个哥们写了一个 Python 脚本，试了下，很好用！\n我 Fork 了一下，修复了一个 bug，给他提了 PR (https://github.com/ezeeyahoo/ChromiumSyncEnabler/pull/1)\nhttps://github.com/ryderfang/ChromiumSyncEnabler\n跑下来重启 Chromium 就 OK 了！\n","date":"January 26 2018","permalink":"/posts/2018/chromium-api-keys/","section":"碎语闲言","summary":"\u003cp\u003eChromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏\u003c/p\u003e","title":"Chromium 缺少 Google API 密钥解决办法"},{"content":"Visual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。\n其中 社区版 Community Version 是永久免费的。\n唯一不足的是在导出图表为图片时，右下角会有一个水印。\n   本文就是要使用 Python 去除这个水印，输出 png 图片。\n 该方法参考了网络上手动去除的方法，需要有一些操作\n 导出 # 首先需要将完成的图表导出为 svg 格式的图片：\n   选择 svg 格式保存：\n   这样我们就得到了一个带水印的 svg 图片:\n   去除水印 #  处理 svg 图片   Svg（Scalable Vector Graphics，可缩放矢量图形） 是一种矢量图片格式，可以使用文本编辑器直接打开，可以看得到在最后几行有水印的内容，所以我们可以用代码自动把他们去掉（当然也可以手动删除）。\n 水印内容在 Svg 文件中：\n\u0026lt;text x=\u0026#34;68\u0026#34; xml:space=\u0026#34;preserve\u0026#34; y=\u0026#34;276\u0026#34; stroke=\u0026#34;none\u0026#34; \u0026gt;Powered ByVisual Paradigm Community Edition\u0026lt;/text \u0026gt;\u0026lt;image font-size=\u0026#34;12\u0026#34; x=\u0026#34;303\u0026#34; y=\u0026#34;264\u0026#34; fill=\u0026#34;white\u0026#34; width=\u0026#34;16\u0026#34; xlink:href=\u0026#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABvklEQVR42o1TPUgC YRi+z1PSzWrSc6ho6W/xNIhEoZoCl/a2fqaGoJKwyHIp16ZyCyIolwpq6c8lIz0h h6ACa/KWOHGz4byezz7lkNM8eHjf7/ve53l/vu84rsWXEcVo2uOJtYrhW5A3YCKE 48YXnE7zoSzfty3AyFHdln/R4bBA5O5fgQbyiUbIK6oY5gjxG1XCtyAngFl7qXT+ Y7UOwR+glTSK8EZkomlJMZsNCrKs7iuKOuXzJboUJYAqemrtHEBkGwsTIy/pe0bZ /Rmvd6K27svnx7Q/cu08LIliiPpmlvEGJo0DL4sRSKVyBuEZledznKpeYs+u6/YF nKt6C+jpe14QPjCsQUpmQVYgaNK0R9hPYJLtZ5Eo5JGkVF0AmUZAvoBLM5WBXhZs A6YB+pi+AAudD+zOnMuVjBcKheoMbOXyG0wcWKGtAPr77gauKyYTFU8g+xrsUWex mKu2r79Gye3eQkAE7i4wCtQG+YTMKZwt0zOUv274DjCLJGZBoEqv9JRtyyDfgrwK f09PNnyJ6OuBiYSxPAbecf9UMNZIbvovUBE8FjRINrEMNJbd1t9I28Gz7YD7DHKo WdwvFl2vGaThOSEAAAAASUVORK5CYII=\u0026#34; height=\u0026#34;16\u0026#34; stroke=\u0026#34;white\u0026#34; preserveAspectRatio=\u0026#34;none\u0026#34; /\u0026gt; 用 Python 读取文件内容，去除这一段内容即可。\n 转换成 png 图片  然后将 Svg 格式转换成 png格式，这里有现成的库 cairosvg 来实现。\n完整的代码可以在 我的 Github 上找到。\n使用方法 #  需要先安装 cairosvg:  $ pip3 install cairosvg 可能会报错，Pillow 安装失败，提示： The headers or library files could not be found for zlib.\n可以尝试一下:\n$ xcode-select —-install $ brew install libtiff libjpeg webp little-cms2 $ pip3 install Pillow 安装 cairosvg 成功后，使用 Python3 import cairosvg 发现还是报错:\n\u0026gt;\u0026gt;\u0026gt; import cairosvg Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/__init__.py\u0026#34;, line 29, in \u0026lt;module\u0026gt; from . import surface File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/surface.py\u0026#34;, line 24, in \u0026lt;module\u0026gt; import cairocffi as cairo File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\u0026#34;, line 41, in \u0026lt;module\u0026gt; cairo = dlopen(ffi, \u0026#39;cairo\u0026#39;, \u0026#39;cairo-2\u0026#39;) File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\u0026#34;, line 38, in dlopen raise OSError(\u0026#34;dlopen() failed to load a library: %s\u0026#34; % \u0026#39; / \u0026#39;.join(names)) OSError: dlopen() failed to load a library: cairo / cairo-2 经过搜索，发现还需要安装 cairo 和 libffi：\n$ brew install cairo pango gdk-pixbuf libffi  终于弄完了     源文件： vp_remove_watermark.py\n 核心代码如下：  import cairosvg svg_content = \u0026#39;\u0026#39; with open(src_name, \u0026#39;r\u0026#39;) as f: svg_content = f.read() end = svg_content.rfind(\u0026#39;\u0026lt;/g\u0026#39;) beg = svg_content.rfind(\u0026#39;\u0026lt;g\u0026#39;, 0, end) svg_content = svg_content[:beg] + svg_content[end:] with open(\u0026#39;./vp_test_out.svg\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(svg_content) cairosvg.svg2png(url=\u0026#39;./vp_test_out.svg\u0026#39;, write_to=dst_name)  赶紧跑起来  $ python vp_remove_watermark test.svg -o out.png ","date":"January 25 2018","permalink":"/posts/2018/visual-paradigm-remove-watermark/","section":"碎语闲言","summary":"\u003cp\u003eVisual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。\u003c/p\u003e\n\u003cp\u003e其中 \u003ca href=\"https://www.visual-paradigm.com/cn/download/community.jsp\"\u003e社区版 Community Version\u003c/a\u003e 是永久免费的。\u003c/p\u003e","title":"移除 Visual Paradigm 流程图的水印"},{"content":"最近开始学习 Vue.js, 一脸懵逼地进入前端世界。\n不使用 vue-cli 和 webpack 这些构建工具，使用单个 html 引入 Vue。\nhtml 内容是这样的:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Vue\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#39;app\u0026#39;\u0026gt; \u0026lt;span v-bind:title=\u0026#34;message\u0026#34;\u0026gt;鼠标悬停\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;页面加载于 \u0026#39; + new Date().toLocaleString() } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用浏览器打开这个 html 就可以看到效果（鼠标悬停显示『页面加载于yyyy-MM-dd hh:mm:ss』）\n安装 Vue-Devtools，但是插件栏显示\nVue.js not detected\n    由于访问的路径是 file:// 文件路径，Chrome 扩展默认是不能访问的。\n Vue.js not detected # 打开右上角 ... -\u0026gt; 更多工具 -\u0026gt; 扩展程序，找到 Vue.js devtools，选中 允许访问文件网址:\n   OK，然后 devtools 仍然不可用，提示\nVue.js is detected on this page. Devtools inspection is not available because it's in production mode or explicitly disabled by the author.\n 由于我们使用的 vue.js https://cdn.jsdelivr.net/npm/vue 是生产版本，所以不能访问。\n Production mode # 下载开发版本的vue.js，放到本地，修改src路径为本地即可。\n  开发版本: https://vuejs.org/js/vue.js\n  生产版本: https://vuejs.org/js/vue.min.js (或者 https://cdn.jsdelivr.net/npm/vue)\n  Vue-Devtools # 这样，打开开发者工具 (option + command + i || F12)\n可以看到多了一个Vue的Tab:\n   ","date":"January 24 2018","permalink":"/posts/2018/vue-devtools/","section":"碎语闲言","summary":"\u003cp\u003e最近开始学习 \u003ca href=\"https://cn.vuejs.org/\"\u003eVue.js\u003c/a\u003e, 一脸懵逼地进入前端世界。\u003c/p\u003e\n\u003cp\u003e不使用 \u003ccode\u003evue-cli\u003c/code\u003e 和 \u003ccode\u003ewebpack\u003c/code\u003e 这些构建工具，使用单个 html 引入 Vue。\u003c/p\u003e","title":"Vue 调试工具 Devtools"},{"content":"速查手册 # *斜体* ~\u0026gt; 斜体\n**粗体** ~\u0026gt; 粗体\n***粗斜体*** ~\u0026gt; 粗斜体\n~~删除线~~ ~\u0026gt; 删除线\n*** ~\u0026gt; 分割线\n# 一级标题\n###### 六级标题\n[超链接](http://fangr.cc/) ~\u0026gt; 超链接\n[超链接][1] [1]:http://fangr.cc ~\u0026gt;\n超链接\n\u0026lt;http://fangr.cc/\u0026gt; ~\u0026gt; http://fangr.cc/\n*/+/- 无序列表 ~\u0026gt;\n 无序列表 无序列表  1. 有序列表 ~\u0026gt;\n 有序列表 有序列表  \u0026gt;\u0026gt;\u0026gt; 引用 ~\u0026gt;\n  多层引用\n   多层引用\n ![图片alt](图片url \u0026quot;图片title\u0026quot;)\n锚点: [速查手册](#速查手册) -\u0026gt; 速查手册\n  整理版 # 原作者: HaoqiangChen, LeaNote\n目录 # 有些编辑器使用`[TOC]`可以直接生成目录, 但原生并不支持。  0. 目录 1. 分级标题 2. 斜体和粗体 3. 超链接\n 3.1 行内式 3.2 参考式 3.3 自动链接\n   4. 锚点 5. 列表\n 5.1 无序列表 5.2 有序列表 5.3 定义型列表 5.4 列表缩进 5.5 包含段落的列表 5.6 包含引用的列表 5.7 包含代码区块的引用 5.8 一个特殊情况\n   6. 引用\n 6.1 引用的多层嵌套 6.2 引用其它要素\n   7. 插入图像\n 7.1 行内式 7.2 参考式\n   8. 分隔线和预格式化\n 8.1 分隔线 8.2 预格式化\n   9. 表格 10. 注脚 11. LaTeX公式\n 11.1 $表示行内公式 11.2 $$表示整行公式\n   12. 流程图 13. 代码\n 13.1 行内式 13.2 缩进式多行代码 13.3 包裹多行代码 13.4 HTML原始码\n   分级标题 # 第一种写法:\n这是一个一级标题 ============================ 这是一个二级标题 -------------------------------------------------- 第二种写法:\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题字号最大, 依级递减。 显示效果: \u0026lt;!- ignore -\u0026gt;\n 斜体和粗体 # 代码:\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号, 被 * 或 _ 包围的字词会被转成用 \u0026lt;em\u0026gt; 标签包围, 用两个 * 或 _ 包起来的话, 则会被转成 \u0026lt;strong\u0026gt;, 例如: *斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~ 但是目前MarkdownPad2和GitHub的Markdown并不支持~~删除线~~这个语法功能, 可以用html的\u0026lt;del\u0026gt;\u0026lt;/del\u0026gt;或\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt;代替。 显示效果:\n 这是一段斜体 这是一段粗体 这是一段加粗斜体 这是一段删除线   超链接 # Markdown 支持两种形式的链接语法: 行内式和参考式两种形式, 行内式一般使用较多。\n行内式 # 语法说明:\n []里写链接文字, ()里写链接地址, ()里面\u0026quot; \u0026ldquo;中的内容可以为链接指定title属性, title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 \u0026ldquo;链接标题\u0026rdquo;)这样的形式。链接地址与链接标题前有一个空格。  代码:\n欢迎来到[Markdown语法篇](https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown) 欢迎来到[Markdown语法篇](https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown \u0026#34;Markdown语法篇\u0026#34;) 显示效果:\n欢迎来到Markdown语法篇\n欢迎来到Markdown语法篇\n参考式 # 参考式超链接一般用在学术论文上面, 或者另一种情况, 如果某一个链接在文章中多处使用, 那么使用引用 的方式创建链接将非常好, 它可以让你对链接进行统一的管理。\n语法说明:\n 参考式链接分为两部分, 文中的写法 [链接文字][链接标记], 在文本的任意位置添加[链接标记]:链接地址 \u0026quot;链接标题\u0026quot;, 链接地址与链接标题前有一个空格。  如果链接文字本身可以做为链接标记, 你也可以写成[链接文字][] [链接文字]:链接地址的形式, 见代码的最后一行。\n代码:\n欢迎阅读本[Markdown语法篇][1], 还有这几篇高手总结的也不错:[入门篇][2]、 [简明版][3]、[完整版][4], 我就喜欢把百家汇成[自己一家][]^_^。 [1]:https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown \u0026#34;Markdown语法篇\u0026#34; [2]:https://sspai.com/post/25137 \u0026#34;入门篇\u0026#34; [3]:http://wowubuntu.com/Markdown/index.html \u0026#34;简明版\u0026#34; [4]:http://blog.leanote.com/post/freewalk/Markdown-语法手册 \u0026#34;完整版\u0026#34; [自己一家]:https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown 显示效果:\n欢迎阅读本Markdown语法篇, 还有这几篇高手总结的也不错:入门篇、 简明版、完整版, 我就喜欢把百家汇成自己一家^_^。\n自动链接 # 语法说明: Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱, 只要是用\u0026lt;\u0026gt;包起来,Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样, 例如:\n代码:\n\u0026lt;http://example.com/\u0026gt; \u0026lt;address@example.com\u0026gt; 显示效果:\nhttp://example.com/ address@example.com\n 锚点 # 网页中, 锚点其实就是页内超链接, 也就是链接本文档内部的某些元素, 实现当前页面中的跳转。比如我这里写下一个锚点, 点击回到目录, 就能跳转到目录。 在目录中点击这一节, 就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。\n注意:\n Markdown Extra 只支持在标题后插入锚点, 其它地方无效。 Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转, 所以点来点去发现没有跳转不必惊慌, 但是你发布成笔记或博文后是支持跳转的。 非常遗憾的是, 目前MarkdownPad2和GitHub的Markdown并不支持[TOC]目录和锚点这个功能, 暂时只能用HTML的标签id来使用页内跳转。  语法描述:\n 使用[TOC]标记编辑器会把所有标题写到目录大纲中。 在你准备跳转到的指定标题后插入锚点{\\#标记}, 然后在文档的其它地方写上连接到锚点的链接。 直接HTML语法锚点功能。 而说到这个就有一个值得一提的地方了, 就是如何在GitHub上也能实现页面跳转, 原先我用的是HTML的a标签锚点, 并且自己给每个标题套上个span#id, 但是发现在gitbook可以有效果, 但是在GitHub上不行, 后面发现这个原生Markdown会自动帮你处理, 自动转成 HTML 实体, 然后我就去看是怎么转化的, 发现它转化每个标题的同时都会赋予一个ID, 那么我们完全直接拿这个ID来做锚点, 至于怎么拿到这个ID, 这个应该就不用我说了吧, 会点编程都知道, 直接打开chrome或者Firefox等调试工具就可以看到了。  代码:\n## 0. 目录{#index} [TOC] 上面这两种方法原生Markdown都不支持, 但是第一种在gitbook居然有效果, 可惜在GitHub还是没有效果 \u0026lt;span id=\u0026#34;#index\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 跳转到[目录](#目录) 显示效果:\n跳转到目录\n 列表 # 无序列表 # 使用 *, +, - 表示无序列表, 三个都显示为实心圆点。\n代码:\n- 无序列表项 一 - 无序列表项 二 - 无序列表项 三 显示效果:\n 无序列表项 一 无序列表项 二 无序列表项 三  有序列表 # 有序列表则使用数字接着一个英文句点再加个空格。\n代码:\n1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 显示效果:\n 有序列表项 一 有序列表项 二 有序列表项 三  定义型列表 # 语法说明:\n定义型列表由名词和解释组成。一行写上定义, 紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\n代码:\nMarkdown :轻量级文本标记语言, 可以转换成html, pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 :这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 显示效果:\nMarkdown :轻量级文本标记语言, 可以转换成html, pdf等格式(没效果, 可能又是不支持吧)\n 代码块 2 这是代码块的定义(没效果, 可能又是不支持吧)  代码块（左侧有八个不可见的空格）\n注:方法一和二在马克飞象编辑器是有效果的, 但是gitbook没有, 可能又是不支持, 至于有没有什么方法可以实现我也不知道- -！\n列表缩进 # 语法说明:\n列表项目标记通常是放在最左边, 但是其实也可以缩进, 最多 3 个空格, 项目标记后面则一定要接着至少一个空格或制表符。\n要让列表看起来更漂亮, 你可以把内容用固定的缩进整理好（显示效果与代码一致）:但是可能又是不支持缘故, gitbook需要每一行末尾空两空格换行才行。\n*轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ *那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 但是如果你懒, 那也行: 代码:\n* 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ * 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 显示效果:\n 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。  包含段落的列表 # 语法说明:\n列表项目可以包含多个段落, 每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）:但是可能又是不支持缘故, gitbook需要每一行末尾空两空格换行才行。\n* 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ * 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 如果你每行都有缩进, 看起来会看好很多, 当然, 再次地, 如果你很懒惰, Markdown 也允许:\n代码:\n* 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ * 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 显示效果:\n 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！  那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！\n 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。  包含引用的列表 # 语法说明:\n如果要在列表项目内放进引用, 那在 \u0026gt; 前面需要缩进:\n代码:\n* 阅读的方法: \u0026gt; 打开书本。 \u0026gt; 打开电灯。 显示效果:\n 阅读的方法:   打开书本。 打开电灯。\n 包含代码区块的引用 # 语法说明: 如果要放代码区块的话, 该区块就需要缩进两次, 也就是 8 个空格或是 2 个制表符:\n 一列表项包含一个列表区块:   \u0026lt;代码写在这\u0026gt;\n 一个特殊情况 # 在特殊情况下, 项目列表很可能会不小心产生, 像是下面这样的写法:\n1986. What a great season. 会显示成:\nWhat a great season.  换句话说, 也就是在行首出现数字-句点-空白, 要避免这样的状况, 你可以在句点前面加上反斜杠:\n1986\\. What a great season. 会显示成:\n1986. What a great season.\n 引用 # 语法说明:\n引用需要在被引用的文本前加上\u0026gt;符号。\n代码:\n\u0026gt; 这是一个有两段文字的引用, \u0026gt; 无意义的占行文字1. \u0026gt; 无意义的占行文字2. \u0026gt; \u0026gt; 无意义的占行文字3. \u0026gt; 无意义的占行文字4. 显示效果:\n 这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2.\n无意义的占行文字3. 无意义的占行文字4.\n Markdown 也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt; :\n代码:\n\u0026gt; 这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2. \u0026gt; 无意义的占行文字3. 无意义的占行文字4. 显示效果:\n 这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2.\n  无意义的占行文字3. 无意义的占行文字4.\n 引用的多层嵌套 # 区块引用可以嵌套（例如:引用内的引用）, 只要根据层次加上不同数量的 \u0026gt; :\n代码:\n\u0026gt;\u0026gt;\u0026gt; 请问 Markdwon 怎么用？ - 小白 \u0026gt;\u0026gt; 自己看教程！ - 愤青 \u0026gt; 教程在哪？ - 小白 显示效果:\n   请问 Markdwon 怎么用？ - 小白\n     自己看教程！ - 愤青\n   教程在哪？ - 小白\n 引用其它要素 # 引用的区块内也可以使用其他的 Markdown 语法, 包括标题、列表、代码区块等:\n代码:\n\u0026gt; 1. 这是第一行列表项。 \u0026gt; 2. 这是第二行列表项。 \u0026gt; \u0026gt; 给出一些例子代码: \u0026gt; \u0026gt; return shell_exec(\u0026#34;echo $input | $Markdown_script\u0026#34;); 显示效果:\n  这是第一行列表项。 这是第二行列表项。  给出一些例子代码:\nreturn shell_exec(\u0026ldquo;echo $input | $Markdown_script\u0026rdquo;);\n  插入图像 # 图片的创建方式与超链接相似, 而且和超链接一样也有两种写法, 行内式和参考式写法。\n语法中图片Alt的意思是如果图片因为某些原因不能显示, 就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样, 表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的, 可以省略, 但建议写上。\n行内式 # 语法说明:![图片Alt](图片地址 \u0026ldquo;图片Title\u0026rdquo;)\n代码:\n美丽花儿: ![美丽花儿](https://raw.githubusercontent.com/HaoqiangChen/Hq-note/master/asset/Markdown/img/flower.jpg \u0026#34;美丽花儿\u0026#34;) 显示效果:\n美丽花儿:  美丽花儿  参考式 # 语法说明:\n在文档要插入图片的地方写![图片Alt][标记]\n在文档的最后写上[标记]:图片地址 \u0026ldquo;Title\u0026rdquo;\n代码:\n美丽花儿: ![美丽花儿][flower] [flower]:https://raw.githubusercontent.com/HaoqiangChen/Hq-note/master/asset/Markdown/img/flower.jpg \u0026#34;美丽花儿\u0026#34; 显示效果:\n美丽花儿:  美丽花儿   分隔线和预格式化 # 分隔线 # 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线, 行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线:\n代码:\n* * * *** ***** - - - --------------------------------------- 显示效果都一样:\n  预格式化 # 用```+中间你所想注释的内容或代码+```包裹:预格式化, 可用于Markdown里面的注释, 解释说明什么的 Markdown的预格式化 相当于HTML的\u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt;预格式化, 不过Markdown这个除了预格式化之外还会添加了一个背景色与其他内容区分开, 相当好用。\n 表格 # 语法说明:\n 不管是哪种方式, 第一行为表头, 第二行分隔表头和主体部分, 第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐, 在-符号右边加上冒号: 就会右对齐。  代码:\n简单方式写表格:\n学号|姓名|分数 -|-|- 小明|男|75 小红|女|79 小陆|男|92 原生方式写表格:\n|学号|姓名|分数| |-|-|-| |小明|男|75| |小红|女|79| |小陆|男|92| 为表格第二列指定方向:\n产品|价格 -|-: Leanote 高级账号|60元/年 Leanote 超级账号|120元/年 显示效果: 简单方式写表格:\n   学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92    原生方式写表格:\n   学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92    为表格第二列指定方向:\n   产品 价格     Leanote 高级账号 60元/年   Leanote 超级账号 120元/年     注脚 # 语法说明:\n在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注, 脚注前必须有对应的脚注名字。\n注意:经测试注脚与注脚之间必须空一行, 不然会失效。成功后会发现, 即使你没有把注脚写在文末, 经Markdown转换后, 也会自动归类到文章的最后。\n代码:\n使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台, 支持Markdown和笔记直接发为博文 **注:脚注自动被搬运到最后面, 请到文章末尾查看, 并且脚注后方的链接可以直接跳转回到加注的地方。** 显示效果:\n注:因为Markdown是没有一个所谓的规范的(Markdown官网都不支持这么做), 因此导致gitbook没有目录[TOC]和注脚功能, 所以某些特性功能需要写作工具自己支持才可以, 像马克飞象和Leanote就可以。\n LaTeX公式 # $表示行内公式 # 代码:\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 显示效果：\n质能守恒方程可以用一个很简洁的方程式 E=mc2\" role=\"presentation\" style=\"position: relative;\"E=mc2来表达。\n注: 原生不支持LaTeX公式。可以用codecogs的云服务, 在线LaTeX数学公式编辑工具, api+一大串LaTex, 比如:  当然这么强大的在线公式编辑器肯定提供了在线GUI给大家, 打开网址:\n  http://www.codecogs.com/latex/eqneditor.php,\n  你就可以随心所欲的编辑公式了, 它同样想Mathtype一样提供了不少模板, 直接编辑, 也很方便。编辑完成之后, 页面上就会实时得到编辑的Latex格式公式图片。\n  或者:http://latex.codecogs.com/\n  这个网址的使用方法:![](http://latex.codecogs.com/gif.latex?\\frac{1}{1+sin(x)})\n -\u0026gt;\n 所以, 上面的例子可以修改为\n  质能守恒方程可以用一个很简洁的方程式 ![](http://latex.codecogs.com/gif.latex?E=mc^2) 来表达。\n 显示效果:\n质能守恒方程可以用一个很简洁的方程式   来表达。\n$$表示整行公式 # 代码:\n$$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$ 同上, 原生不支持, 使用上面的网站即可。\n显示效果:\n  \\sum_{i=1}^n a_i=0    \\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}  访问 MathJax 参考更多使用方法。\n 流程图 # 代码:\nflow st=\u0026gt;start: Start:\u0026gt;https://www.zybuluo.com io=\u0026gt;inputoutput: verification op=\u0026gt;operation: Your Operation cond=\u0026gt;condition: Yes or No? sub=\u0026gt;subroutine: Your Subroutine e=\u0026gt;end st-\u0026gt;io-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;sub-\u0026gt;io 显示效果:\nCreated with Raphaël 2.1.0https://www.zybuluo.comStarthttps://www.zybuluo.comverificationYour OperationYes or No?EndYour Subroutineyesno 从上面的例子可以看出原生对流程图同样也是不支持, 所以只能采取迂回取巧方法了, 就是用一些支持流程图的编辑器先画出来, 然后截图放到这个不支持的页面上\n 更多语法参考:流程图语法参考\n 代码 # 对于程序员来说这个功能是必不可少的, 插入程序代码的方式有两种, 一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。\n语法说明:\n 插入行内代码, 即插入一个单词或者一句代码的情况, 使用`code`这样的形式插入。 插入多行代码, 可以使用缩进或者“` code “`,具体看示例。  注意: 缩进式插入前方必须有空行\n行内式 # 代码:\nC语言里的函数 `scanf()` 怎么使用？ 显示效果:\nC语言里的函数 scanf() 怎么使用？\n缩进式多行代码 # 缩进 4 个空格或是 1 个制表符\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n代码:\n # 空一行 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } 显示效果:\n#include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026quot;Hello world\\n\u0026quot;); }  包裹多行代码 # 代码:\n#include \u0026lt;stdio.h\u0026gt;; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } 显示效果:\n#include \u0026lt;stdio.h\u0026gt;; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } HTML原始码 # 在代码区块里面,\u0026amp; 、 \u0026lt; 和 \u0026gt; 会自动转成 HTML 实体, 这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码, 只需要复制贴上, 剩下的 Markdown 都会帮你处理, 例如:\nTip: 值得注意的是，Markdown对空格、空行很敏感，在解析成HTML时会自动添加一些\u0026lt;br\u0026gt;标签导致出现大段空白，所以HTML块要尽量紧凑。\n代码:\n第一个例子:\n\u0026lt;div\u0026gt;\u0026amp;copy; 2007 Foo Corporation\u0026lt;/div\u0026gt; 第二个例子:\n\u0026lt;table\u0026gt;\u0026lt;tbody\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;值班人员\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;星期一\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;星期二\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;星期三\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;李强\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;张明\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;王平\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; 显示效果:\n第一个例子:\n\u0026copy; 2007 Foo Corporation 第二个例子:\n值班人员星期一星期二星期三李强张明王平 ","date":"October 12 2017","permalink":"/posts/2017/markdown-tutorial/","section":"碎语闲言","summary":"速查手册 # *斜体* ~\u0026gt; 斜体","title":"Markdown 完全手册"},{"content":"关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是:\n$ npm install -g hexo $ hexo init $ hexo generate (hexo g) $ hexo server (hexo s) $ hexo new [name] - 新建文章 $ hexo new page [name] - 新建页面 正常情况下，这样就会启动本地的服务:http://localhost:4000，但现实总是残酷的，\n由于国内XXX的网络环境，总会遇到各种各样的问题，\n下面总结一下本博客迁移到Hexo过程中遇到的一些问题。\nNPM 源 # node的包管理工具npm，默认使用国外的源，访问比较慢，建议换成国内源，比如 淘宝npm:\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用cnpm代替npm进行模块安装了:\n$ cnpm install [name] 或者，使用nrm (npm的源管理工具):\n$ npm install nrm $ nrm ls * npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ $ nrm use taobao $ nrm test taobao Hexo 安装 # hexo-server # hexo server执行失败:\nERROR Plugin load filed: hexo-server 需要单独安装hexo-server:\n$ npm install hexo-server --save node-sass # $ npm install node-sass --save 如果出现如下情况:\n$ node scripts/install.js Cannot download \u0026#34;https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node\u0026#34;: read ECONNRESET Hint: If github.com is not accessible in your location try setting a proxy via HTTP_PROXY, e.g. export HTTP_PROXY=http://example.com:1234 or configure npm proxy via npm config set proxy http://example.com:8080 $ node-sass@4.5.3 postinstall /private/tmp/node_modules/node-sass $ node scripts/build.js 说明 github 访问比较慢，两种方法：\n 修改 host:  http://tool.chinaz.com/dns?type=1\u0026amp;host=github.com\u0026amp;ip=\n找一个TTL比较小的host，如:\n192.30.255.112 github.com  直接去github下载  https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node\n然后将该文件放到目录:~/.npm/node-sass/4.5.3/darwin-x64-51_binding.node\n再执行安装命令\n$ npm intall node-sass --save hexo-renderer-scss # 有些主题需要安装hexo-renderer-scss:\n$ npm install hexo-renderer-scss --save 会出现错误:\nERROR Plugin load failed: hexo-renderer-scss Error: ENOENT: no such file or directory, scandir \u0026#39;xxx/node_modules/node-sass/vendor\u0026#39; at Object.fs.readdirSync (fs.js:914:18) ... 提示这个目录找不到，那我们手动创建好了:\n$ mkdir xxx/node_modules/node-sass/vendor $ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor 接下来还是报错:\nERROR Plugin load failed: hexo-renderer-scss Error: Missing binding xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 7.x Found bindings for the following environments: 到这个目录下，把刚刚下载的darwin-x64-51_binding.node重命名复制进去好了:\n$ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/ $ cp darwin-x64-51_binding.node xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node 页面空白 # 有时执行hexo s后显示服务启动，但页面打开空白，显示Cannot GET /，这种情况有很多原因，\n可以尝试:\n$ npm install $ hexo cl $ hexo g $ hexo s 如果还有问题，查看一下npm插件是否安装正常:\n$ npm ls --depth 0 hexo-site@0.0.0 xxx ├── hexo@3.3.9 ├── hexo-deployer-git@0.3.1 ├── hexo-generator-archive@0.1.4 ├── hexo-generator-baidu-sitemap@0.1.2 ├── hexo-generator-category@0.1.3 ├── hexo-generator-feed@1.2.2 ├── hexo-generator-index@0.2.1 ├── hexo-generator-sitemap@1.2.0 ├── hexo-generator-tag@0.2.0 ├── hexo-renderer-ejs@0.3.1 ├── hexo-renderer-marked@0.3.0 ├── hexo-renderer-scss@1.0.3 ├── hexo-renderer-stylus@0.3.3 ├── hexo-server@0.2.2 └── node-sass@4.5.3 npm ERR! invalid: hexo-generator-baidu-sitemap@0.0.8 xxx/node_modules/hexo-generator-baidu-sitemap/node_modules/hexo-generator-baidu-sitemap 可以看到hexo-generator-baidu-sitemap这个插件安装失败了，尝试重新安装或者删除它:\n$ npm install hexo-generator-baidu-sitemap --save $ npm uninstall hexo-generator-baidu-sitemap 或者在package.json中将它删除掉。\n","date":"September 27 2017","permalink":"/posts/2017/hexo-workflow/","section":"碎语闲言","summary":"\u003cp\u003e关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ npm install -g hexo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo init\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo generate \u003cspan class=\"o\"\u003e(\u003c/span\u003ehexo g\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo server \u003cspan class=\"o\"\u003e(\u003c/span\u003ehexo s\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo new \u003cspan class=\"o\"\u003e[\u003c/span\u003ename\u003cspan class=\"o\"\u003e]\u003c/span\u003e - 新建文章\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo new page \u003cspan class=\"o\"\u003e[\u003c/span\u003ename\u003cspan class=\"o\"\u003e]\u003c/span\u003e - 新建页面\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"使用 Hexo 遇到的一些问题"},{"content":"   来自一个神奇的域名: http://fuckingblocksyntax.com/\n使用方法 # 局部变量 # returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; 属性 property # @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); 方法参数 # - (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; 参数调用 # [someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; typedef 定义 # typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; Hint #  block 在 ARC 下是否声明为 copy 属性  It is still a good idea to declare block properties as having copy semantics since a block assigned to a strong property will in fact be copied.\nApple recommends this as well:\n You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior.\n ","date":"May 31 2017","permalink":"/posts/2017/how-to-declare-block-in-oc/","section":"碎语闲言","summary":"来自一个神奇的域名: http://fuckingblocksyntax.","title":"在 ObjC 中如何定义 Block"},{"content":"最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。\n   我自己在虚拟机中试了下，确实这样！\n在用户机器中获取了 DUMP，只看到有几个线程一直在跑，调用堆栈中也看不到太多信息（主要是没有线程 CPU 占用信息），一时没有方法。\n今天突然想到 VS2013，新版本增加了一些功能，貌似有性能分析相关的。\n找了一下，果然在调试菜单下发现了性能与诊断：\n   选择 CPU使用率，就开始分析啦！\n很快就给出了分析结果：\n   哈哈！瞬间定位 CPU 占用元凶，原来是一个后台线程一直在跑（空转），设计不合理。这个线程最早设计成自驱动的，找到原因就好办了，改成被驱动式就行了！\n","date":"August 8 2016","permalink":"/posts/2016/detect-cpu-usage-with-vs2013/","section":"碎语闲言","summary":"\u003cp\u003e最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。\u003c/p\u003e","title":"VS2013 检测 CPU 占用率"},{"content":"   安装 Ruby 和 Ruby DevKit\n Ruby 2.2.4 Ruby DevKit  切换到安装目录：\n$ cd C:\\RubyDevKit $ ruby dk.rb init $ ruby dk.rb install 安装Jekyll\n$ gem install jekyll $ gem install wdm 切换到博客目录运行\n$ jekyll build [--watch/-w] $ jekyll serve [--watch/-w] 用浏览器打开http://127.0.0.1:4000，即可看到效果，而且在修改文件的同时刷新页面即可实时更新。\n可以通过\u0026ndash;port 888指定端口号，更多命令行参数参考[官方手册]1\n安装有问题，可以参考更多文档：\n  [Running Jekyll on Windows]2\n  [Jekyll Windows]3\n  [Setup Jekyll on Windows]4\n    http://jekyll.bootcss.com/docs/configuration/ \u0026ldquo;配置\u0026rdquo;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://jekyll-windows.juthilo.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://yizeng.me/2013/05/10/setup-jekyll-on-windows/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"June 5 2016","permalink":"/posts/2016/install-jekyll-locally/","section":"碎语闲言","summary":"\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-jekyll.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e安装 Ruby 和 Ruby DevKit\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-2.2.4.exe\"\u003eRuby 2.2.4\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://dl.bintray.com/oneclick/rubyinstaller/DevKit-mingw64-32-4.7.2-20130224-1151-sfx.exe\"\u003eRuby DevKit\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Jekyll 本地安装"}]