[{"categories":[],"content":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。 参考 OC 编译过程 我们可以借助 clang 工具将 OC 源码预处理成 CPP 来窥探 OC 的内部实现。 定义一个简单的类： @interface Foo : NSObject @property (nonatomic, assign) BOOL ppty1; @property (nonatomic, copy) NSString *ppty2; - (BOOL)iMethod1; - (void)iMethod2:(NSString *)p1; + (void)cMethod1; @end 通过命令 clang -rewrite-objc xx.m 得到一个 9 万多行的 cpp 文件 😱 https://gist.github.com/ryderfang/75a852f1ae0961aeea97127f7d9ca6c5 ","date":"2022-01-04","objectID":"/class-object-isa/:0:0","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"TL;DR太长不看版： 🧸 objc_object 是所有实例对象的底层结构，内部只有一个 isa 🎁 objc_class 是所有类/元类对象的底层结构，它也有一个 isa 指针，指向自己的元类 OC 1.0 OC 2.0 id 实例 typedef struct objc_object *id; typedef struct objc_object *id; objc_object struct objc_object {} struct objc_object {} Class 类 typedef struct objc_class *Class; typedef struct objc_class *Class; objc_class struct objc_class {} struct objc_class : objc_object {} ","date":"2022-01-04","objectID":"/class-object-isa/:1:0","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"Class 是什么","date":"2022-01-04","objectID":"/class-object-isa/:2:0","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"Class 1.0在 \u003cobjc/objc.h\u003e 中有这样一行： typedef struct objc_class *Class; 在 iOS 15 之前 \u003cobjc/runtime.h\u003e 中曾经有 objc_class 的定义： https://opensource.apple.com/source/objc4/objc4-750/runtime/runtime.h.auto.html /* Types */#if !OBJC_TYPES_DEFINED structobjc_class{Class_NonnullisaOBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class_Nullablesuper_classOBJC2_UNAVAILABLE;constchar*_NonnullnameOBJC2_UNAVAILABLE;longversionOBJC2_UNAVAILABLE;longinfoOBJC2_UNAVAILABLE;longinstance_sizeOBJC2_UNAVAILABLE;structobjc_ivar_list*_NullableivarsOBJC2_UNAVAILABLE;structobjc_method_list*_Nullable*_NullablemethodListsOBJC2_UNAVAILABLE;structobjc_cache*_NonnullcacheOBJC2_UNAVAILABLE;structobjc_protocol_list*_NullableprotocolsOBJC2_UNAVAILABLE;#endif }OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */#endif 目前我使用的 Xcode 13.2.1 中已经找不到这个定义，也就是说在 macOS 12.1 / iOS 15.2 中，OBJC1 已经被完全废弃。 Hint: 按照官方文档 Runtime Version 的解释, legacy 版本 (OC 1.0) 在 2007 年就完全废弃了，所有 iPhone 和 OSX 10.5 以后的 Mac 上使用的都是 modern 版本 (OC 2.0)! 技巧 根据 wiki 的说明，OC 2.0 于 2006 年发布，而 iPhone 第一代 是在 2007 年发布的，Mac OS X 10.5 Leopard 也是在 2007 年上市。 从这个宏 OBJC2_UNAVAILABLE 可以看出来 OBJC2 这种定义会失效。那么 OBJC2 是什么？ ","date":"2022-01-04","objectID":"/class-object-isa/:2:1","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"Class 2.0在 objc-runtime-new.h 中定义了 objc_class 的 2.0 版本： struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... } 参考 1 和 2 了解到，苹果在 2006 年重写了 runtime，发布了新的 Runtime 2.0，那么 __OBJC2__ 这个宏是什么时候生效的呢？ 通过查找苹果公开的 runtime 源码：https://opensource.apple.com/source/objc4/ 发现： 从 objc4-750 这个版本开始，在 objc-config.h 中开始有了 __OBJC2__ 的定义！ // Define __OBJC2__ for the benefit of our asm files. #ifndef __OBJC2__ # if TARGET_OS_OSX \u0026\u0026 !TARGET_OS_IOSMAC \u0026\u0026 __i386__ // old ABI # else # define __OBJC2__ 1 # endif #endif 来自 apple 的 commit： https://github.com/apple-oss-distributions/objc4/commit/26c7408b94ead1f04a0b5976e354a03966ce61ea 在 objc-api.h 中定义了 OBJC_ISA_AVAILABILITY: /* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable * in the future */#if !defined(OBJC_ISA_AVAILABILITY) # if __OBJC2__ # define OBJC_ISA_AVAILABILITY __attribute__((deprecated)) # else # define OBJC_ISA_AVAILABILITY /* still available */ # endif #endif 在 objc-private.h 中同时定义了 OBJC_TYPES_DEFINED: /* Isolate ourselves from the definitions of id and Class in the compiler * and public headers. */ #ifdef _OBJC_OBJC_H_ #error include objc-private.h before other headers #endif #define OBJC_TYPES_DEFINED 1 同时也定义了 Class 和 id typedef struct objc_class *Class; typedef struct objc_object *id; 所以，不管 OC 1.0 还是 2.0， Class 都是一个叫 objc_class 的结构体指针。 ","date":"2022-01-04","objectID":"/class-object-isa/:2:2","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"Object 与 id在 \u003cobjc/objc.h\u003e 中，定义 https://opensource.apple.com/source/objc4/objc4-750/runtime/objc.h.auto.html ","date":"2022-01-04","objectID":"/class-object-isa/:3:0","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"Object 1.0#if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; #endif 同样被包在 OBJC_TYPES_DEFINED 宏中，也就是 OC 2.0 并不生效。 那么，OC 2.0 的 objc_object 是什么样的呢，在 objc-private.h 中定义了： ","date":"2022-01-04","objectID":"/class-object-isa/:3:1","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"Object 2.0struct objc_object { private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // 省略大量方法 private: void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor); // 省略大量方法 }; 可以看出来不管 OC 1.0 还是 2.0, objc_object 都是一个包含着一个叫 isa 指针/变量 的对象。 ","date":"2022-01-04","objectID":"/class-object-isa/:3:2","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":[],"content":"isa 又是什么在 1.0 版本中 isa 就是一个 Class 对象，也就是一个指向 objc_class 的指针，而在 2.0 时，isa 是一个叫 isa_t 的结构体变量。 那么 isa_t 是什么呢？ 同样在 objc-private.h 中有定义： union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; #if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h }; #endif }; // TODO https://halfrost.com/objc_runtime_isa_class/ ↩︎ https://kangzubin.com/objc1.0-class-object/ ↩︎ ","date":"2022-01-04","objectID":"/class-object-isa/:4:0","tags":[],"title":"Class, Object 与 isa","uri":"/class-object-isa/"},{"categories":["Optimize"],"content":"本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章： Responding to the Launch of Your App 有个主要的流程图： 另外，还有一篇介绍如何优化启动速度的文章，毕竟只有准确了解了启动中做了哪些事，才能更针对地进行优化。 Reducing Your App’s Launch Time 这里还参考了以下几篇文章： [1]: iOS App 启动优化 [2]: iOS App 从点击到启动 [3]: 深入了解 App 启动过程 总结一下： ","date":"2021-12-28","objectID":"/app-launch-process/:0:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"系统层","date":"2021-12-28","objectID":"/app-launch-process/:1:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"pre-main 阶段","date":"2021-12-28","objectID":"/app-launch-process/:2:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"main 方法","date":"2021-12-28","objectID":"/app-launch-process/:3:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["Optimize"],"content":"首屏渲染后","date":"2021-12-28","objectID":"/app-launch-process/:4:0","tags":["Launch","App"],"title":"发生在用户点击 icon 之后","uri":"/app-launch-process/"},{"categories":["ObjC"],"content":"概述Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。 当我们在讲 Runtime 的时候，我们在说什么？ 根据官方文档的定义， Objective-C Runtime Objective-C Runtime Programming Guide Runtime 是一个动态库 (/usr/lib/libobjc.A.dylib)，用于实现 OC 语言的动态性。 这个动态性主要体现在三个方面： Dynamic Typing 运行时才能决定对象的类型，也就是说编译器不检查类型合法性 Dynamic Binding 运行时才能知道方法被如何执行，也就是消息机制 (messaging) Dynamic Loading 允许动态添加类、方法等 ","date":"2021-12-28","objectID":"/what-is-runtime/:1:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"起源孙源大佬在 博客 中说过，OC1 其实是 C 语言与 SmallTalk2 思想结合的产物。 与同属 SmallTalk 学派的语言 Java, Python 和 Ruby 一样，OC 具有面向对象、动态类型和反射式等特点。 Objective-C = C + Preprocessor + Runtime SmallTalk 领先了时代 20 年，至今 OC 仍然没有实现它的全部特性。 ","date":"2021-12-28","objectID":"/what-is-runtime/:2:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Runtime Version存在两个版本的 Runtime，modern 和 legacy： https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html#//apple_ref/doc/uid/TP40008048-CH106-SW1 按照官方的说明，iPhone 和 10.5 版本之后的 64 位程序都使用的 OC 2.0。 Runtime 源码: https://opensource.apple.com/source/objc4/ 下载 tarballs: https://opensource.apple.com/tarballs/objc4/ 可调试项目: https://github.com/RetVal/objc-runtime ","date":"2021-12-28","objectID":"/what-is-runtime/:3:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Runtime 里有什么Runtime 的源码可以在 RetVal/objc-runtime 这里找到，甚至可以 Debug。 主要包含如下几个方面，后续会逐个总结。 ","date":"2021-12-28","objectID":"/what-is-runtime/:4:0","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Class/Object 与 isa参考：Class Object 与 isa ","date":"2021-12-28","objectID":"/what-is-runtime/:4:1","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"MetaClass 元类指向链: 实例 -\u003e 类 -\u003e 元类 -\u003e 根元类 -\u003e 根元类 (isa 指向自己) 类的继承链: 子类 -\u003e 父类 -\u003e NSObject 元类的继承链: 子类元类 -\u003e 父类元类 -\u003e 根元类 -\u003e NSObject -\u003e nil 经典图再次镇楼： ","date":"2021-12-28","objectID":"/what-is-runtime/:4:2","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Method/IMP/SEL","date":"2021-12-28","objectID":"/what-is-runtime/:4:3","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Category","date":"2021-12-28","objectID":"/what-is-runtime/:4:4","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Messaging","date":"2021-12-28","objectID":"/what-is-runtime/:4:5","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"Swizzling","date":"2021-12-28","objectID":"/what-is-runtime/:4:6","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"其它常用方法++++++ https://zh.wikipedia.org/wiki/Objective-C ↩︎ https://zh.wikipedia.org/zh-hans/Smalltalk ↩︎ ","date":"2021-12-28","objectID":"/what-is-runtime/:4:7","tags":["ObjC","Runtime"],"title":"ObjC 之 Runtime 是个啥","uri":"/what-is-runtime/"},{"categories":["ObjC"],"content":"很早之前看过一个 前端 Roadmap，图做的非常漂亮。最近发现有人做了类似的 移动端 Roadmap， 其中 iOS 是这样的： 还有 Swift 的，暂时先不关注了。这里综合一下形成文字版，方面查缺补漏。 iOS 的体系结构如下图： Ref: iOS abstraction layers 需要重点关注的有下面几个方面： ","date":"2021-12-23","objectID":"/objc-roadmap/:0:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Foundation","date":"2021-12-23","objectID":"/objc-roadmap/:1:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"I. ARC/MRC 3️⃣ARC is supported in Xcode 4.2 for OS X v10.6 and v10.7 (64-bit applications) and for iOS 4 and iOS 5. 现在除了一些老项目，基本没有 MRC 为主的代码了，所以只需要简单了解下 MRC 与 ARC 的区别即可 MRC 需要手动写 dealloc，并且一定要最后再调用父类的 dealloc； ARC 一般不需要写 dealloc，也不需要调用 [super dealloc]。移除 NSNotification Observer 和 KVC Observer 例外。 在 ARC 的工程中使用 MRC，需要在工程中设置源文件的编译选项 -fno-objc-arc ","date":"2021-12-23","objectID":"/objc-roadmap/:1:1","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"II. AutoReleasePool 4️⃣ AutoReleasePool 的数据结构 AutoReleasePool 与 @autoreleasepool ","date":"2021-12-23","objectID":"/objc-roadmap/:1:2","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"III. Block 5️⃣ block 的结构体类型 block 如何捕获外部变量 循环引用 与 Weak-Strong Dance ","date":"2021-12-23","objectID":"/objc-roadmap/:1:3","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"IV. Category 5️⃣ load 加载时机 load 与 initialze category 覆盖原类方法的原理 category 同名方法调用顺序 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:4","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"V. HotPatch 1️⃣ JSPatch 的原理 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:5","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"VI. KVC 2️⃣ KVC 是如何实现的 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:6","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"VII. KVO 4️⃣ KVO 的原理 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:7","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"VIII. MultiThread 4️⃣ 哪些多线程方法 互斥锁与自旋锁 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:8","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"IX. Network 3️⃣ NSURLSession 与 NSURLConnection ","date":"2021-12-23","objectID":"/objc-roadmap/:1:9","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"X. NSTimer 5️⃣ timer 与 Runloop timer 导致循环引用的产生与解决 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:10","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"XI. Property 5️⃣ 不同属性的区别 weak 与 copy atomic 并不是线程安全的 如何实现一个弱引用容器 + [NSPointerArray weakObjectsPointerArray] 弱引用数组 + [NSMapTable weakToWeakObjectsMapTable] 弱引用表 + [NSHashTable weakObjectsHashTable] 弱引用 hash 表 + [NSValue valueWithNonretainedObject:] 弱引用对象 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:11","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"XII. Runloop 4️⃣ Runloop 与线程的关系 如何实现一个常驻线程 ","date":"2021-12-23","objectID":"/objc-roadmap/:1:12","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"XIII. Runtime 5️⃣一图胜千言，引用 Runtime 工程师 Greg Parker 在其博客中给出的经典图 系列文章：Runtime 是个啥？ ","date":"2021-12-23","objectID":"/objc-roadmap/:1:13","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"UIKit","date":"2021-12-23","objectID":"/objc-roadmap/:2:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"UIView 与 CALayer bounds 与 frame setNeedsDisplay 与 layoutIfNeeded ","date":"2021-12-23","objectID":"/objc-roadmap/:2:1","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"常用 UI 组件 UIScrollView UITableView UICollectionView ","date":"2021-12-23","objectID":"/objc-roadmap/:2:2","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"AutoLayout Masonary 原理 ","date":"2021-12-23","objectID":"/objc-roadmap/:2:3","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"UIResponder touch events hitTest ","date":"2021-12-23","objectID":"/objc-roadmap/:2:4","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"离屏渲染 layoutSubview 与 drawRect ","date":"2021-12-23","objectID":"/objc-roadmap/:2:5","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Core 系列","date":"2021-12-23","objectID":"/objc-roadmap/:3:0","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Core Graphics 高效绘制圆角 ","date":"2021-12-23","objectID":"/objc-roadmap/:3:1","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"Core Data","date":"2021-12-23","objectID":"/objc-roadmap/:3:2","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["ObjC"],"content":"AVFoundation","date":"2021-12-23","objectID":"/objc-roadmap/:3:3","tags":["Roadmap","ObjC"],"title":"ObjC 之 技术路线图","uri":"/objc-roadmap/"},{"categories":["Challenge"],"content":"时隔两年，再次拾起博客。 我完全不是一个有恒心的人，而且做什么事都是三分钟热度。包括博客，从 Jekyll 到 Hexo，再到现在 Hugo。 有新鲜玩意都想把玩一下，折腾完了又觉得索然无味。注重形式大于内容，纠结字体字号、各种样式的事情，反而没什么内容沉淀下来。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:0:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"关于博客在腾讯云买了域名 ryderfang.com，然后折腾备案、SSL 证书部署、nginx 配置静态页面等等， 目前源文件拖管在 Github 上，每次 push 自动触发 Actions， 完成编译并推送到 gh-pages 分支的操作。站内搜索使用 algolia，使用手动 Actions 的方式，需要时触发更新。 同样在腾讯云买了一个轻应用服务器，托管一下这个静态博客，不打算再折腾自动化了，需要同步的时候 ssh 登录一下，手动拉一下 repo 就好。 技巧 哈哈，总是在打脸，还是把自动同步服务器做成了一个 Action - name: remote ssh command uses: appleboy/ssh-action@master with: host: ${{ secrets.TENCENT_CLOUD_HOST }} username: ubuntu key: ${{ secrets.TENCENT_CLOUD_KEY }} port: 22 script: | whoami cd blog \u0026\u0026 git pull echo 'Done!' 再把之前的博客内容整理到新的博客上，发现并没多少值得保留的，真是有点惭愧。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:1:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"技术目标常常想起小时候爸爸告诫我的话： 有志之人立常志，无志之人常立志。 但是，这么多年的工作经历，让我认识到自己只是个普通人。普通的技术、普通的能力和普通的志向，甚至于在 “内卷” 与 “躺平” 的浪潮中，已经逐渐想要躺平。 最近又看到一句话： 到底什么样的终点，才配得上这一路的颠沛流离 ?! 是啊，或许，我们只是想去码头整点薯条，人生本无太多意义。 扯远了，总之，普通人就定几个能完成的普通目标。也不要过分自责，因为你就是一粒宇宙的尘埃。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"写文章到年底还有一个多月，输出 2-3 篇技术博客。 UPDATE: 算完成 80% 吧，内容还需要补充 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:1","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"iOS 技术栈继续完善 iOS 八股技术栈: https://github.com/ryderfang/iOSBagu，尽可能去了解一些犄角旮旯的知识点。 UPDATE: 没有完成，需要尽快补齐 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:2","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"读书读一点其他领域的书，随便看一点。 UPDATE: 没有完成，多读书是 2022 重点目标 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:2:3","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"生活目标","date":"2021-11-16","objectID":"/2021-personal-challeng/:3:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"健康身体 NO.1，换季的时候，一家人都得了咽炎，去医院太折腾了。希望全家都健康，宝宝也快点长大，少让姥姥和大家操点心吧。 成功 UPDATE: 安安越来越大了，前段时间脸上又被虫咬了一大块，最近快长好了。 平安、健康、快乐，足矣。没有别的希冀。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:3:1","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"早起每天送老婆上班，虽然累，但还是挺好的，早到公司一小时，可以做很多事了。困的问题就中午多午睡一会儿吧。 能睡说明自己还年轻吧，至少没有失眠的困扰，感觉至少要睡十个小时才能满足，也只能周末才有这个机会了。 UPDATE: 本来年底想面试一下来年换个工作，但老婆可能也要换，准备还是继续苟一段时间。 总的来说，鹅厂的人文关怀还是可以的。但不同项目组也差异很大，PCG 确实是个天坑。 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:3:2","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":["Challenge"],"content":"结语就这些吧，我感觉能完成 80% 就已经很不错了。元旦的时候再来 check 一下 🚀 ","date":"2021-11-16","objectID":"/2021-personal-challeng/:4:0","tags":["Flag"],"title":"2021 个人目标 🎯","uri":"/2021-personal-challeng/"},{"categories":null,"content":"我是谁互联网游荡者，历经 ‘BAT’ 三家公司，现任鹅厂废柴搬砖工。 I worked from B (Bilibili) A (Alibaba) T (Tencent), still too vegetable as a primary coder. Now I’m living with my wife and little son in Shanghai, China. Life is too short, Just enjoy it. ","date":"2021-11-11","objectID":"/about/:1:0","tags":null,"title":"$whoami","uri":"/about/"},{"categories":null,"content":"经历🐧 腾讯科技（上海）有限公司 客户端开发 2019.11 - INF 手 Q 开发 相机渲染，道具特效等 图片、视频编辑 AI 端智能 🚼 口碑（上海）信息技术有限公司 | 阿里巴巴 高级无线开发工程师 2017.10 - 2019.11 口碑掌柜 业务开发、投放体系建设 Lottie 接入 阿里云语音SDK 技术专项 端 AI 智能算法 H5 容器相关 🏝 上海哔哩哔哩科技有限公司 | 幻电信息科技 iOS 开发工程师 2016.04 - 2017.10 iOS 客户端 C++ 转 iOS 开发 业务开发，视频收藏夹 图片治理，webP 接入等 UGC 投稿助手 QT \u0026 C++ 开发 多线程视频文件上传 稿件管理功能等 📟 上海二三四五网络科技有限公司 2013.12 - 2016.04 2345 单核/双核 浏览器 浏览器业务开发 逆向技术、Flash 兼容 广告拦截技术 看图王、好压 DirectUI C++ 多线程开发 +++ ","date":"2021-11-11","objectID":"/about/:2:0","tags":null,"title":"$whoami","uri":"/about/"},{"categories":["Challenge"],"content":"信息 Mark Zuckerberg 每年都会发布自己的年度挑战 Personal Challenge So，我也要给自己立一些 Flag… ","date":"2018-01-29","objectID":"/2018-personal-challenge/:0:0","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"技术目标//\u003c!-- --\u003e console.log('达到中初级前端工程师水平') //\u003c!-- --\u003e UPDATE: 并没有达到 😢 这将是技术广度拓宽的一年。 最近几年，随着中年危机的提前到来，90年码农越来越焦虑，在知乎上的各种问题: 35 岁以上的互联网 / 科技行业从业者面临裁员时，应如何规划职业发展？ 新时代的中年危机长啥样？ 30岁程序员的出路 知乎圆桌 - 30 岁人生攻略 等等 很多人表达了这样一个观点，要想维持职场生命力，必须要努力掌握更深更广地技能。 成为所谓的斜杠 (Slash) 青年，不再满足于单一职业，而是多元化发展。 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:1:0","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"生活目标","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:0","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"早点睡觉常年处于缺觉的状态，整个人都不好了 TODO: 最好 11:30 pm 前睡觉 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:1","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"锻炼身体小肚子减减减呀！ ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:2","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"家里收拾好养了点花花草草，买了一只小龟龟，希望它明年还在 UPDATE: 小龟龟被我养死了 😭 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:3","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["Challenge"],"content":"结婚吧在一起快一年了，喜欢她的性格，也觉得该修成正果，安定下来了。 成功 UPDATE: 2018.12.01 相识 520 天，我们结婚啦！👫 💕💕 ","date":"2018-01-29","objectID":"/2018-personal-challenge/:2:4","tags":["Flag"],"title":"2018 个人目标 🎯","uri":"/2018-personal-challenge/"},{"categories":["RTFM"],"content":"Chromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏 当然是因为好用(zhuāng bī) 了 😅 废话少说，下载地址： https://download-chromium.appspot.com/ 如果下载不了，可以试下： Windows https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/ Mac https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Mac/ 打不开之类的需要翻墙的问题自行解决吧。 ","date":"2018-01-26","objectID":"/chromium-api-keys/:0:0","tags":["Chrome"],"title":"Chromium 缺少 Google API 密钥解决办法","uri":"/chromium-api-keys/"},{"categories":["RTFM"],"content":"问题打开 Chromium 会提示 缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用 😒 由于 Chromium 使用的 API 都需要自行申请密钥才能使用。 所以 在 https://console.cloud.google.com/ 上创建密钥。 相关文档：http://www.chromium.org/developers/how-tos/api-keys 最后密钥有三个，位置在 https://console.cloud.google.com/apis/credentials GOOGLE_API_KEY GOOGLE_DEFAULT_CLIENT_ID GOOGLE_DEFAULT_CLIENT_SECRET ","date":"2018-01-26","objectID":"/chromium-api-keys/:1:0","tags":["Chrome"],"title":"Chromium 缺少 Google API 密钥解决办法","uri":"/chromium-api-keys/"},{"categories":["RTFM"],"content":"解决官方的解决方法是： 将下面三行写到 ~/.bash_profile 中，然后重启浏览器即可 export GOOGLE_API_KEY=\"****\" export GOOGLE_DEFAULT_CLIENT_ID=\"**** export GOOGLE_DEFAULT_CLIENT_SECRET=\"****\" $source ~/.bash_profile 这样，有时是管用的。特别是在 Windows上，使用类似的在命令行输入： setx GOOGLE_API_KEY your_key_goes_here setx GOOGLE_DEFAULT_CLIENT_ID your_client_id_goes_here setx GOOGLE_DEFAULT_CLIENT_SECRET your_client_secret_goes_here 但是 Mac 上有时不管用，参考: https://gist.github.com/cvan/44a6d60457b20133191bd7b104f9dcc4 在文档最后，发现有个哥们写了一个 Python 脚本，试了下，很好用！ 我 Fork 了一下，修复了一个 bug，给他提了 PR (https://github.com/ezeeyahoo/ChromiumSyncEnabler/pull/1) https://github.com/ryderfang/ChromiumSyncEnabler 跑下来重启 Chromium 就 OK 了！ ","date":"2018-01-26","objectID":"/chromium-api-keys/:2:0","tags":["Chrome"],"title":"Chromium 缺少 Google API 密钥解决办法","uri":"/chromium-api-keys/"},{"categories":["RTFM"],"content":"Visual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。 其中 社区版 Community Version 是永久免费的。 唯一不足的是在导出图表为图片时，右下角会有一个水印。 本文就是要使用 Python 去除这个水印，输出 png 图片。 该方法参考了网络上手动去除的方法，需要有一些操作 ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:0:0","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"导出首先需要将完成的图表导出为 svg 格式的图片： 选择 svg 格式保存： 这样我们就得到了一个带水印的 svg 图片: ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:1:0","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"去除水印 处理 svg 图片 Svg（Scalable Vector Graphics，可缩放矢量图形） 是一种矢量图片格式，可以使用文本编辑器直接打开，可以看得到在最后几行有水印的内容，所以我们可以用代码自动把他们去掉（当然也可以手动删除）。 水印内容在 Svg 文件中： \u003ctext x=\"68\" xml:space=\"preserve\" y=\"276\" stroke=\"none\" \u003ePowered ByVisual Paradigm Community Edition\u003c/text \u003e\u003cimage font-size=\"12\" x=\"303\" y=\"264\" fill=\"white\" width=\"16\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABvklEQVR42o1TPUgC YRi+z1PSzWrSc6ho6W/xNIhEoZoCl/a2fqaGoJKwyHIp16ZyCyIolwpq6c8lIz0h h6ACa/KWOHGz4byezz7lkNM8eHjf7/ve53l/vu84rsWXEcVo2uOJtYrhW5A3YCKE 48YXnE7zoSzfty3AyFHdln/R4bBA5O5fgQbyiUbIK6oY5gjxG1XCtyAngFl7qXT+ Y7UOwR+glTSK8EZkomlJMZsNCrKs7iuKOuXzJboUJYAqemrtHEBkGwsTIy/pe0bZ /Rmvd6K27svnx7Q/cu08LIliiPpmlvEGJo0DL4sRSKVyBuEZledznKpeYs+u6/YF nKt6C+jpe14QPjCsQUpmQVYgaNK0R9hPYJLtZ5Eo5JGkVF0AmUZAvoBLM5WBXhZs A6YB+pi+AAudD+zOnMuVjBcKheoMbOXyG0wcWKGtAPr77gauKyYTFU8g+xrsUWex mKu2r79Gye3eQkAE7i4wCtQG+YTMKZwt0zOUv274DjCLJGZBoEqv9JRtyyDfgrwK f09PNnyJ6OuBiYSxPAbecf9UMNZIbvovUBE8FjRINrEMNJbd1t9I28Gz7YD7DHKo WdwvFl2vGaThOSEAAAAASUVORK5CYII=\" height=\"16\" stroke=\"white\" preserveAspectRatio=\"none\" /\u003e 用 Python 读取文件内容，去除这一段内容即可。 转换成 png 图片 然后将 Svg 格式转换成 png格式，这里有现成的库 cairosvg 来实现。 完整的代码可以在 我的 Github 上找到。 ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:1:1","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"使用方法 需要先安装 cairosvg: $ pip3 install cairosvg 可能会报错，Pillow 安装失败，提示： The headers or library files could not be found for zlib. 可以尝试一下: $ xcode-select —-install $ brew install libtiff libjpeg webp little-cms2 $ pip3 install Pillow 安装 cairosvg 成功后，使用 Python3 import cairosvg 发现还是报错: \u003e\u003e\u003e import cairosvg Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/__init__.py\", line 29, in \u003cmodule\u003e from . import surface File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/surface.py\", line 24, in \u003cmodule\u003e import cairocffi as cairo File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\", line 41, in \u003cmodule\u003e cairo = dlopen(ffi, 'cairo', 'cairo-2') File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\", line 38, in dlopen raise OSError(\"dlopen() failed to load a library: %s\" % ' / '.join(names)) OSError: dlopen() failed to load a library: cairo / cairo-2 经过搜索，发现还需要安装 cairo 和 libffi： $ brew install cairo pango gdk-pixbuf libffi 终于弄完了 源文件： vp_remove_watermark.py 核心代码如下： import cairosvg svg_content = '' with open(src_name, 'r') as f: svg_content = f.read() end = svg_content.rfind('\u003c/g') beg = svg_content.rfind('\u003cg', 0, end) svg_content = svg_content[:beg] + svg_content[end:] with open('./vp_test_out.svg', 'w') as f: f.write(svg_content) cairosvg.svg2png(url='./vp_test_out.svg', write_to=dst_name) 赶紧跑起来 $ python vp_remove_watermark test.svg -o out.png ","date":"2018-01-25","objectID":"/visual-paradigm-remove-watermark/:1:2","tags":["WaterMark"],"title":"移除 Visual Paradigm 流程图的水印","uri":"/visual-paradigm-remove-watermark/"},{"categories":["RTFM"],"content":"最近开始学习 Vue.js, 一脸懵逼地进入前端世界。 不使用 vue-cli 和 webpack 这些构建工具，使用单个 html 引入 Vue。 html 内容是这样的: \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eHello, Vue\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003cspan v-bind:title=\"message\"\u003e鼠标悬停\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: '#app', data: { message: '页面加载于 ' + new Date().toLocaleString() } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 用浏览器打开这个 html 就可以看到效果（鼠标悬停显示『页面加载于yyyy-MM-dd hh:mm:ss』） 安装 Vue-Devtools，但是插件栏显示 Vue.js not detected 由于访问的路径是 file:// 文件路径，Chrome 扩展默认是不能访问的。 ","date":"2018-01-24","objectID":"/vue-devtools/:0:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"Vue.js not detected打开右上角 ... -\u003e 更多工具 -\u003e 扩展程序，找到 Vue.js devtools，选中 允许访问文件网址: OK，然后 devtools 仍然不可用，提示 Vue.js is detected on this page. Devtools inspection is not available because it's in production mode or explicitly disabled by the author. 由于我们使用的 vue.js https://cdn.jsdelivr.net/npm/vue 是生产版本，所以不能访问。 ","date":"2018-01-24","objectID":"/vue-devtools/:1:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"Production mode下载开发版本的vue.js，放到本地，修改src路径为本地即可。 开发版本: https://vuejs.org/js/vue.js 生产版本: https://vuejs.org/js/vue.min.js (或者 https://cdn.jsdelivr.net/npm/vue) ","date":"2018-01-24","objectID":"/vue-devtools/:2:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"Vue-Devtools这样，打开开发者工具 (option + command + i || F12) 可以看到多了一个Vue的Tab: ","date":"2018-01-24","objectID":"/vue-devtools/:3:0","tags":["Vue","Front-End"],"title":"Vue 调试工具 Devtools","uri":"/vue-devtools/"},{"categories":["RTFM"],"content":"关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是: $ npm install -g hexo $ hexo init $ hexo generate (hexo g) $ hexo server (hexo s) $ hexo new [name] - 新建文章 $ hexo new page [name] - 新建页面 正常情况下，这样就会启动本地的服务:http://localhost:4000，但现实总是残酷的， 由于国内XXX的网络环境，总会遇到各种各样的问题， 下面总结一下本博客迁移到Hexo过程中遇到的一些问题。 ","date":"2017-09-27","objectID":"/hexo-workflow/:0:0","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"NPM 源node的包管理工具npm，默认使用国外的源，访问比较慢，建议换成国内源，一般是淘宝npm: $ npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用cnpm代替npm进行模块安装了: $ cnpm install [name] 或者，使用nrm (npm的源管理工具): $ npm install nrm $ nrm ls * npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ $ nrm use taobao $ nrm test taobao ","date":"2017-09-27","objectID":"/hexo-workflow/:1:0","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"Hexo 安装","date":"2017-09-27","objectID":"/hexo-workflow/:2:0","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"hexo-serverhexo server执行失败: ERROR Plugin load filed: hexo-server 需要单独安装hexo-server: $ npm install hexo-server --save ","date":"2017-09-27","objectID":"/hexo-workflow/:2:1","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"node-sass$ npm install node-sass --save 如果出现如下情况: $ node scripts/install.js Cannot download \"https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node\": read ECONNRESET Hint: If github.com is not accessible in your location try setting a proxy via HTTP_PROXY, e.g. export HTTP_PROXY=http://example.com:1234 or configure npm proxy via npm config set proxy http://example.com:8080 $ node-sass@4.5.3 postinstall /private/tmp/node_modules/node-sass $ node scripts/build.js 说明github访问比较慢，两种方法： 修改host: http://tool.chinaz.com/dns?type=1\u0026host=github.com\u0026ip= 找一个TTL比较小的host，如: 192.30.255.112 github.com 直接去github下载 https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node 然后将该文件放到目录:~/.npm/node-sass/4.5.3/darwin-x64-51_binding.node 再执行安装命令 $ npm intall node-sass --save ","date":"2017-09-27","objectID":"/hexo-workflow/:2:2","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"hexo-renderer-scss有些主题需要安装hexo-renderer-scss: $ npm install hexo-renderer-scss --save 会出现错误: ERROR Plugin load failed: hexo-renderer-scss Error: ENOENT: no such file or directory, scandir 'xxx/node_modules/node-sass/vendor' at Object.fs.readdirSync (fs.js:914:18) ... 提示这个目录找不到，那我们手动创建好了: $ mkdir xxx/node_modules/node-sass/vendor $ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor 接下来还是报错: ERROR Plugin load failed: hexo-renderer-scss Error: Missing binding xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 7.x Found bindings for the following environments: 到这个目录下，把刚刚下载的darwin-x64-51_binding.node重命名复制进去好了: $ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/ $ cp darwin-x64-51_binding.node xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node ","date":"2017-09-27","objectID":"/hexo-workflow/:2:3","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["RTFM"],"content":"页面空白有时执行hexo s后显示服务启动，但页面打开空白，显示Cannot GET /，这种情况有很多原因， 可以尝试: $ npm install $ hexo cl $ hexo g $ hexo s 如果还有问题，查看一下npm插件是否安装正常: $ npm ls --depth 0 hexo-site@0.0.0 xxx ├── hexo@3.3.9 ├── hexo-deployer-git@0.3.1 ├── hexo-generator-archive@0.1.4 ├── hexo-generator-baidu-sitemap@0.1.2 ├── hexo-generator-category@0.1.3 ├── hexo-generator-feed@1.2.2 ├── hexo-generator-index@0.2.1 ├── hexo-generator-sitemap@1.2.0 ├── hexo-generator-tag@0.2.0 ├── hexo-renderer-ejs@0.3.1 ├── hexo-renderer-marked@0.3.0 ├── hexo-renderer-scss@1.0.3 ├── hexo-renderer-stylus@0.3.3 ├── hexo-server@0.2.2 └── node-sass@4.5.3 npm ERR! invalid: hexo-generator-baidu-sitemap@0.0.8 xxx/node_modules/hexo-generator-baidu-sitemap/node_modules/hexo-generator-baidu-sitemap 可以看到hexo-generator-baidu-sitemap这个插件安装失败了，尝试重新安装或者删除它: $ npm install hexo-generator-baidu-sitemap --save $ npm uninstall hexo-generator-baidu-sitemap 或者在package.json中将它删除掉。 ","date":"2017-09-27","objectID":"/hexo-workflow/:2:4","tags":["Hexo","Blog"],"title":"使用 Hexo 遇到的一些问题","uri":"/hexo-workflow/"},{"categories":["ObjC"],"content":"来自一个神奇的域名 http://fuckingblocksyntax.com/ ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:0:0","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"Declaration","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:0","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"local variablereturnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:1","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"property@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:2","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"method parameter- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:3","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"argument to a method call[someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:4","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"typedeftypedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:1:5","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["ObjC"],"content":"Hint block 在 ARC 下是否声明为 copy 属性 It is still a good idea to declare block properties as having copy semantics since a block assigned to a strong property will in fact be copied. Apple recommends this as well: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. ","date":"2017-05-31","objectID":"/how-to-declare-block-in-oc/:2:0","tags":["Block"],"title":"在 ObjC 中如何定义 Block","uri":"/how-to-declare-block-in-oc/"},{"categories":["Windows"],"content":"最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。 我自己在虚拟机中试了下，确实这样！ 在用户机器中获取了 DUMP，只看到有几个线程一直在跑，调用堆栈中也看不到太多信息（主要是没有线程 CPU 占用信息），一时没有方法。 今天突然想到 VS2013，新版本增加了一些功能，貌似有性能分析相关的。 找了一下，果然在调试菜单下发现了性能与诊断： 选择 CPU使用率，就开始分析啦！ 很快就给出了分析结果： 哈哈！瞬间定位 CPU 占用元凶，原来是一个后台线程一直在跑（空转），设计不合理。这个线程最早设计成自驱动的，找到原因就好办了，改成被驱动式就行了！ ","date":"2016-08-08","objectID":"/detect-cpu-usage-with-vs2013/:0:0","tags":["CPU"],"title":"VS2013 检测 CPU 占用率","uri":"/detect-cpu-usage-with-vs2013/"},{"categories":["RTFM"],"content":"安装 Ruby 和 Ruby DevKit Ruby 2.2.4 Ruby DevKit 切换到安装目录： $ cd C:\\RubyDevKit $ ruby dk.rb init $ ruby dk.rb install 安装Jekyll $ gem install jekyll $ gem install wdm 切换到博客目录运行 bash $ jekyll build [--watch/-w] $ jekyll serve [--watch/-w] 用浏览器打开http://127.0.0.1:4000，即可看到效果，而且在修改文件的同时刷新页面即可实时更新。 可以通过–port 888指定端口号，更多命令行参数参考[官方手册]1 安装有问题，可以参考更多文档： [Running Jekyll on Windows]2 [Jekyll Windows]3 [Setup Jekyll on Windows]4 http://jekyll.bootcss.com/docs/configuration/ “配置” ↩︎ http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html ↩︎ http://jekyll-windows.juthilo.com/ ↩︎ http://yizeng.me/2013/05/10/setup-jekyll-on-windows/ ↩︎ ","date":"2016-06-05","objectID":"/install-jekyll-locally/:0:0","tags":["Jekyll","Blog"],"title":"Jekyll 本地安装","uri":"/install-jekyll-locally/"}]