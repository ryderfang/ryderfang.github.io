[{"content":"Git 操作是程序员必须掌握的基本技能。刚毕业那会，大家还都使用 svn 作为版本管理工具。\n但近些年大家基本都改用 git 了，甚至在我们项目内部 UI 切图都开始使用 git 管理了。\n 感谢 Linus Torvalds 的伟大发明！\n 一般情况下，我们常用的命令无非是：\n$ git init $ git checkout $ git add $ git pull $ git push $ git merge 在说 rebase 前，先重点强调一下 黄金法则：\n !!! 永远不要在公共分支上使用 rebase !!!\n rebase 作为一个进阶命令，常常与 merge 放在一起比较。\nrebase 与 merge # $ git checkout feature $ git merge main // or $ git merge feature main 将 main 分支合并到 feature：\n   这样在 feature 分支上会产生一个新的 commit，这是一个 merge commit。\n而对于 rebase:\n$ git checkout feature $ git rebase main    可以看到 feature 分支所有 commit 都被放到了 main 前面，整个 history 形成了一条直线。\n值得注意的是，feature 的所有 commit 都被重建了，它们的 hash 已经不是原来的那个了！\n所以，rebase 相对于 merge 来说，优点是：\n 时间线更漂亮，符号强迫症和整洁癖的喜好  为了做到这个，它对 安全性 (safety) 和 可追溯性 (traceability) 做了折衷1，如果不遵循 rebase 黄金法则，将带来灾难！\nrebase 的缺点很明显：\n 不当的使用容易造成严重后果 难以追溯历史，比如上面的 feature 分支在 rebase 之后，无法知道是什么时候从 main 切出进行的修改。无法知道什么时候合入的 main 分支。  git pull # 首先，git pull 是两个动作的合并，即 git fetch + git merge FETCH_HEAD\n比如 git pull origin master，首先拉取 origin/master，再将本地分支与 origin/master 执行 merge 操作。\n如果你本地有一个 commit，但是没有提交到远程；同时你的同事在同一个分支上提交了代码。你进行 fetch 的时候会发现，本地分支既 ahead 又 behind：\n    如果这个时候执行 merge 操作：   Merge made by the \u0026lsquo;recursive\u0026rsquo; strategy.\n    会产生一个 merge 节点！\n 如果执行的是 rebase 呢？        会将本地的 commit 重建，并放到最上面。（可以看到 commit id 不一样了）\n然后 push 之后，时间线就成了一条直线！\n   所以，git pull 这个操作，大部分情况来说，使用 \u0026ndash;rebase 更合适！\n我们可以设置 git pull 默认使用 rebase 选项：\n# 仅设置 master 分支生效 git config branch.master.rebase true # 对所有 tracking 的 branch 生效 git config branch.autosetuprebase always # 对所有 pull 操作生效 git config pull.rebase true  以上仅对当前目录的 git 生效，如果要全局生效，记得加上 --global 选项。\n # 手动编辑更方便！ git config --global --edit rebase 的禁忌 # 再次复习一下 黄金法则：\n !!! 永远不要在公共分支上使用 rebase !!!\n 如果你和同事公用了一个 feature 分支，而你使用 rebase 同步主干。很有可能弄丢同事的代码！\n我们来看下是怎么出现的：\n 首先我们从 master 切出一个 feature 分支：     这个时候有两个同事同时在这个分支上开发，相安无事。\n某天，有个同事说，主干上有一些更新，我们要不要同步一下到 feature 分支：     “好啊，好啊”，那么怎么同步呢？要不要试试新学的 rebase 命令 ?!     3.1. 你的同事一边说“好啊”，一边在自己本地的 feature 上提交了好几次，并 push 到了远程！\n   你并不知道，这样你本地的 feature 分支并没有完全包含同事的提交，与此同时，你开始了可怕的 rebase 操作：\n这时，你发现提交不上去：\n   于是，头脑一热，你决定大力出奇迹，--force 一把：     这时，你同事更新一下代码，发现！“我的代码怎么没了？？！！”\n怎么办？ # 有办法补救嘛？有！\n让你的同事使用 git reflog：\n   找到丢失的 commit，通过 git cherry-pick [commit-id] 提交到 feature 分支即可！\n但是！我们还是不要随便使用 --force 来制造这种凶险事件了。\n看下面这个场景：\n   前面介绍过，超前是本地分支有三个变更，落后是远程分支有四个变更没有同步过来。\n如果我们强行 push 就会丢失远程的 commit，所以我们试一下 --force-with-lease 参数：\n没有区别，还是提交上去了！\n   在这种明知道本地落后，仍然强行提交的情况下，--force-with-lease 的作用与 --force 是一样的！\n正常的做法是：\n git pull \u0026ndash;rebase 更新本地分支\n 而 git push --force-with-lease 能够解决的是，在 rebase-push 过程中，有其他人提交到该分支时的，这次提交操作会被拒绝。相对来说更安全一点。\n所以，总得来说，还是黄金法则：\n !!! 永远不要在公共分支上使用 rebase !!!\n  多人协作分支，同步主干，请使用 merge !!\n   https://www.atlassian.com/git/tutorials/merging-vs-rebasing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"March 19 2022","permalink":"/posts/git-rebase/","section":"碎語閑言","summary":"\u003cp\u003eGit 操作是程序员必须掌握的基本技能。刚毕业那会，大家还都使用 svn 作为版本管理工具。\u003c/p\u003e\n\u003cp\u003e但近些年大家基本都改用 git 了，甚至在我们项目内部 UI 切图都开始使用 git 管理了。\u003c/p\u003e","title":"关于 Rebase 容易被坑的那些事"},{"content":"“二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 O(log n)，空间复杂度 O(1)，相比线性搜索优秀太多。\n但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本1能准确写对“二分”查找。\n 尽管二分查找的基本思想相对简单，但细节可以令人难以招架 \u0026hellip; — 高德纳\n 二分查找的前提是待查找的序列是有序的。\n本身算法逻辑非常简单2：\nfunction binary_search(A, n, T) is L := 0 R := n − 1 while L ≤ R do m := floor((L + R) / 2) if A[m] \u0026lt; T then L := m + 1 else if A[m] \u0026gt; T then R := m − 1 else: return m return unsuccessful 减少一次判断 # 上述伪代码每次循环都会比较 mid 与 target 是否相等，如果去掉这个比较，将之放到循环退出时，就可以在每次循环中减少一次比较，总得循环次数仅比上面的算法多一次。\nfunction binary_search_alternative(A, n, T) is L := 0 R := n − 1 while L != R do m := ceil((L + R) / 2) if A[m] \u0026gt; T then R := m − 1 else: L := m if A[L] = T then return L return unsuccessful 关于 cell 和 floor # 可以看出来，上面两个实现中在取 mid 时使用了不同的方法，一个是 floor()，一个是 ceil()，\nfloor((0 + 1) / 2) = 0\nceil((0 + 1) / 2) = 1\n为什么会有这个不同呢？在 StackOverflow 上有很好的解释：\n 如果更新二元组 (l, r) -\u0026gt; (m + 1, m - 1) 时，这两种方法都可以，结果是一样的。 如果是 (l, r) -\u0026gt; (m, m - 1) 时，必须要使用 ceil，否则循环无法退出。比如 l = 0, r = 1, A = [1, 2]， target = 2 时，floor 会导致 l 一直被更新为 0，无法退出。 如果是 (l, r) -\u0026gt; (m + 1, m) 时，必须要使用 floor，否则同时循环无法退出。比如 l = 0, r = 1, A = [1, 2]，target = 1 时，ceil 会导致 r 一直被更新成 1。   总之，就是更新下边界更多时，使用 floor，更新上边界更多时，使用 ceil。\n 关于溢出 # 上述算法中还有一个问题，计算 mid = floor((L + R) / 2) 存在可能的溢出错误，这在 C++ 中比较常见，比如 l = r = 2^31-1，相加就会溢出整数范围！\n正常的写法是：\nmid = l + (r - l) // 2 如果有重复元素 # 如果序列中存在重复元素，比如 [1, 2, 3, 3, 3, 4, 5]，要查找 T = 3，可能会有多个结果。\n如果只是判断 target 是否存在，上述的算法都没有问题。但是如果想找到 index 最小或最大的 target 位置，算法就需要做一些修改。\n参考 C++ 标准库中的 std::binary_search 的实现3：\ntemplate \u0026lt;class ForwardIterator, class T\u0026gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { first = std::lower_bound(first,last,val); return (first!=last \u0026amp;\u0026amp; !(val\u0026lt;*first)); } 调用了 std::lower_bound() 方法，这个方法就是在一个序列中找值为 val 的最小 index 位置，同理还有一个找最大 index 方法的函数 std::upper_bound()\ntemplate \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { ForwardIterator it; iterator_traits\u0026lt;ForwardIterator\u0026gt;::difference_type count, step; count = distance(first,last); while (count\u0026gt;0) { it = first; step=count/2; advance (it,step); if (*it\u0026lt;val) { // or: if (comp(*it,val)), for version (2)  first=++it; count-=step+1; } else count=step; } return first; } template \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { ForwardIterator it; iterator_traits\u0026lt;ForwardIterator\u0026gt;::difference_type count, step; count = std::distance(first,last); while (count\u0026gt;0) { it = first; step=count/2; std::advance (it,step); if (!(val\u0026lt;*it)) // or: if (!comp(val,*it)), for version (2)  { first=++it; count-=step+1; } else count=step; } return first; } 区别就是在更新 left = mid + 1 时，如果想取左边界，条件是 mid \u0026lt; val；如果想取右边界，条件是 mid \u0026lt;= val。\n处处是坑 # 知乎有一篇专栏文章：\u0026lt;聊聊一看就会一写就跪的二分查找\u0026gt;讲了二分中的各个坑点，我们逐一看一下：\nfunc FirstGreaterOrEqual(array []int, target int) int { // 初始化区间左端点： -1 || 0 || 1 ？  l := 0 // 初始化区间右端点： len(array) - 1 || len(array) || len(array) + 1 ?  r := len(array) // 当区间不为空时循环： l + 1 \u0026lt; r || l \u0026lt; r || l \u0026lt;= r || l \u0026lt;= r + 1 ?  for l \u0026lt; r { // 计算区间中点： l + (r - l) / 2 || l + (r - l + 1) / 2 ?  m := l + (r - l) / 2 // 将中点对应的元素同target比较： \u0026gt; || \u0026gt;= || \u0026lt; || \u0026lt;= ?  if array[m] \u0026lt; target { // 继续查找右侧这一半： m - 1 || m || m + 1 ?  l = m + 1 } else { // 继续查找左侧这一半： m - 1 || m || m + 1 ?  r = m } } // 这里应该是 l - 1 || l || l + 1 ?  // 这里应该是 r - 1 || r || r + 1 ?  return l } 这是一段 go 语言代码，不过不影响理解它的逻辑，其实它就是在 array 中找 target 的左边界。\n来一一解释作者提出的这些坑：\n  区间左端点 l = 0 或者其他？\n  区间右端点 r = len(array) 还是 len(array) - 1？\n  这两个是一个问题，整个区间有四种状态 (l, r) [l, r] (l, r] [l, r]\n对于数组从 0 开始的语言，左闭区间是合适的。\n右开右闭都是可行的，只需要在循环判断时做一下调整\n [l, r] -\u0026gt; l \u0026lt; r + 1 [l, r) -\u0026gt; l \u0026lt; r  一般来说，我们都会选择 l = 0 \u0026amp; [l, r) 这种组合。\n循环结束条件是 \u0026lt; 还是 \u0026lt;= 还是 !=  \u0026lt; 和 != 都可以，对于非递减序列来说，一般用 \u0026lt;。\n如果 l = r 时，仍然进入循环，同时如果 array[l] \u0026gt;= target，会导致循环无法退出。\n区间中间计算  l + (r - l + 1) / 2 这就属于是 ceil 操作。这个在前面也解释过，不再赘述。\n判断条件  同样的，取决于问题是取最左边的位置还是最右边的，上一节也解释过。\n返回值  结束条件是 l == r，所以返回 l 没有问题。但是这个位置并不一定能满足 array[l] == target，甚至于可能越界。\n返回值 l 表示：[0, l) 位置都是小于 target 的，而 [l, len) 则是大于等于 target 的。这里 l 可能等于 len (越界)。\n 所以在使用二分查找，来判断 target 是否存在时，要注意判断是否越界。\n 作者最后给了一种通用解决方案，将判断逻辑变成一个闭包方法作为参数传入，这样就可以得出多个二分变种问题的解法。\n总之 # 可见，想写对二分不容易，那么我们只记一种正确的写法，归纳成模板即可\n# template def _bsearch(a: List[int], x: int, l: int = 0, r: int = None) -\u0026gt; int: r = r or len(a) while l \u0026lt; r: m = l + (r - l) // 2 if a[m] \u0026lt; x: l = m + 1 else: r = m return l   https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Binary_search_algorithm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://www.cplusplus.com/reference/algorithm/binary_search/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"March 8 2022","permalink":"/posts/binary-search/","section":"碎語閑言","summary":"\u003cp\u003e“二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 \u003ccode\u003eO(log n)\u003c/code\u003e，空间复杂度 \u003ccode\u003eO(1)\u003c/code\u003e，相比线性搜索优秀太多。\u003c/p\u003e\n\u003cp\u003e但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e能准确写对“二分”查找。\u003c/p\u003e","title":"很难写“正确”的二分查找"},{"content":"获取 Class 对象的方法有很多，本文主要是收集整理它们的区别以及探究具体的实现。\nclass 方法 # 有两种 class 方法，一个是实例方法，一个是类方法：\n@interface NSObject \u0026lt;NSObject\u0026gt; - (Class)class OBJC_SWIFT_UNAVAILABLE(\u0026#34;use \u0026#39;type(of: anObject)\u0026#39; instead\u0026#34;); + (Class)class OBJC_SWIFT_UNAVAILABLE(\u0026#34;use \u0026#39;aClass.self\u0026#39; instead\u0026#34;); @end 查看 runtime 的源码：NSObject.mm\n可以看到它们的实现：\n+ (id)self { return (id)self; } - (id)self { return self; } + (Class)class { return self; } - (Class)class { return object_getClass(self); } 所以，说给类对象发 class 消息，得到的是类本身 self，也就是\n [NSObject class] == [NSObject self]\n 给实例对象发 class 消息，相当于调用了 object_getClass\nobject_getClass # 那么这个方法的实现是怎么样的呢？\n同样查看 runtime 源码：objc-class.mm\nClass _Nullable object_getClass(id _Nullable obj)\nClass object_getClass(id obj) { if (obj) return obj-\u0026gt;getIsa(); else return Nil; } 调用了 类的 getIsa() 方法\n// objc-object.h\ninline Class objc_object::getIsa() { if (!isTaggedPointer()) return ISA(); uintptr_t ptr = (uintptr_t)this; if (isExtTaggedPointer()) { uintptr_t slot = (ptr \u0026gt;\u0026gt; _OBJC_TAG_EXT_SLOT_SHIFT) \u0026amp; _OBJC_TAG_EXT_SLOT_MASK; return objc_tag_ext_classes[slot]; } else { uintptr_t slot = (ptr \u0026gt;\u0026gt; _OBJC_TAG_SLOT_SHIFT) \u0026amp; _OBJC_TAG_SLOT_MASK; return objc_tag_classes[slot]; } } objc_getClass # 这个方法和上面的 object_getClass 长得很像，但还是有一些区别：\n  参数不一样，一个是 id，一个是 const char *，也就是一个传入是个类对象，一个是类名\n  实现不一样，一个调用的是 obj-\u0026gt;getIsa()，一个调用的是 loop_up_class()\n  // objc-runtime.mm\nClass objc_getClass(const char *aClassName) { if (!aClassName) return Nil; // NO unconnected, YES class handler  return look_up_class(aClassName, NO, YES); } 调用了 look_up_class:\n// objc-runtime-new.mm\nClass look_up_class(const char *name, bool includeUnconnected __attribute__((unused)), bool includeClassHandler __attribute__((unused))) { if (!name) return nil; Class result; bool unrealized; { runtimeLock.lock(); result = getClassExceptSomeSwift(name); unrealized = result \u0026amp;\u0026amp; !result-\u0026gt;isRealized(); if (unrealized) { result = realizeClassMaybeSwiftAndUnlock(result, runtimeLock); // runtimeLock is now unlocked  } else { runtimeLock.unlock(); } } if (!result) { // Ask Swift about its un-instantiated classes.  // We use thread-local storage to prevent infinite recursion  // if the hook function provokes another lookup of the same name  // (for example, if the hook calls objc_allocateClassPair)  auto *tls = _objc_fetch_pthread_data(true); // Stop if this thread is already looking up this name.  for (unsigned i = 0; i \u0026lt; tls-\u0026gt;classNameLookupsUsed; i++) { if (0 == strcmp(name, tls-\u0026gt;classNameLookups[i])) { return nil; } } // Save this lookup in tls.  if (tls-\u0026gt;classNameLookupsUsed == tls-\u0026gt;classNameLookupsAllocated) { tls-\u0026gt;classNameLookupsAllocated = (tls-\u0026gt;classNameLookupsAllocated * 2 ?: 1); size_t size = tls-\u0026gt;classNameLookupsAllocated * sizeof(tls-\u0026gt;classNameLookups[0]); tls-\u0026gt;classNameLookups = (const char **) realloc(tls-\u0026gt;classNameLookups, size); } tls-\u0026gt;classNameLookups[tls-\u0026gt;classNameLookupsUsed++] = name; // Call the hook.  Class swiftcls = nil; if (GetClassHook.get()(name, \u0026amp;swiftcls)) { ASSERT(swiftcls-\u0026gt;isRealized()); result = swiftcls; } // Erase the name from tls.  unsigned slot = --tls-\u0026gt;classNameLookupsUsed; ASSERT(slot \u0026gt;= 0 \u0026amp;\u0026amp; slot \u0026lt; tls-\u0026gt;classNameLookupsAllocated); ASSERT(name == tls-\u0026gt;classNameLookups[slot]); tls-\u0026gt;classNameLookups[slot] = nil; } return result; } NSClassFromString # 这个在 Foundation.framework 中的实现，并没有开源，\n函数原型是\nFOUNDATION_EXPORT Class _Nullable NSClassFromString(NSString *aClassName); 与 objc_getClass 参数一样，传入 Class 的名字，返回 Class 地址。\n有大佬通过研究汇编分析出它的具体实现：从汇编代码探究 NSClassFromString 实现\n最后，做个试验：\nStudent *stu = [Student new]; Class cls = [stu class]; NSLog(@\u0026#34;%p %p %p %p %p\u0026#34;, cls, [Student class], objc_getClass(\u0026#34;Student\u0026#34;), object_getClass(stu), NSClassFromString(@\u0026#34;Student\u0026#34;)); 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 可以看出来，这四种方法拿到的结果是一样的。\n","date":"February 23 2022","permalink":"/posts/get-class/","section":"碎語閑言","summary":"\u003cp\u003e获取 \u003ccode\u003eClass\u003c/code\u003e 对象的方法有很多，本文主要是收集整理它们的区别以及探究具体的实现。\u003c/p\u003e","title":"获取 OC Class 对象"},{"content":"Meta 这个词在 2021 年下半年开始火爆，而后 Facebook 改名 Meta 引发各大科技公司跟风押注。似乎全球资本都在追逐“元宇宙”的概念，但什么是“元宇宙”，各家有各家的说法，没有一个统一的标准。\n 我个人感觉，元宇宙就是个伪概念。除了一堆跟风炒概念准备割韭菜的老庄家和引颈待收割的韭菜外，各个公司在做的与“元宇宙”相关的事，似乎都是一些“复古网络游戏”。\n  历史是一个轮回，唯有资本逐利是永恒的。不出三年，这个概念应该就不会有人提了，一如 VR 的喧嚣与沉寂。\n Meta 的起源 # 以上只是个引子，与本文无关 \u0026lt;生硬的转折 😅\u0026gt;。本文继续讨论 Runtime，聚焦 OC 中的 MetaClass。\nGreg Parker 经典图\n   为什么要这么设计 # 由于 OC 是 Smalltalk 语言哲学的一种实践，“在 Smalltalk 中，所有的值都是对象”。因此一个实例是对象，它的类也是一个对象。\n实例中的 isa 指针指向了它的类对象，那么类对象的 isa 指针指向谁呢？—— 指向它的元类对象 MetaClass！\n Since a class is an object, it must be an instance of some other class: a metaclass. 1\n 那么能不能不这么设计呢？\n当然能，但是这样就不那么 “Smalltalk” 了。非 Smalltalk 语言如 C++，与 OC 的一个重要区别是：\n C++ 支持多重继承\n Meta 与 继承关系 # 定义一对父类与子类：\n@interface Person : NSObject @end @interface Student : Person @end package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } isa 链 # 定义一个子类的实例 Student *stu，根据之前的文章 class-object-isa，实例本质上是一个 objc_object 结构体，内部存在一个 isa 指针，指向的是 Student 这个类对象。\n而类对象 Student 本质上是一个 objc_class 结构体，继承自 objc_object，所以内部也有一个 isa 指针，类对象的 isa 指针指向的是它的元类对象。\n所以，这条链，也就是上图中最下面一行虚线所示：\n 实例 \u0026ndash;\u0026gt; 类 \u0026ndash;\u0026gt; 元类\n 那么元类的 isa 又指向谁呢，图中显示的是 根元类，通过代码来获取一下这条链：\nStudent *stu = [Student new]; NSLog(@\u0026#34;Student instance addr: %p\u0026#34;, stu); Class cls = [stu class]; NSLog(@\u0026#34;Student class addr: %p\u0026#34;, cls); id rootMetaClass = nil; while (cls) { NSLog(@\u0026#34;isa: %s addr: %p\u0026#34;, object_getClassName(cls), cls); Class tmp = object_getClass(cls); if (tmp == cls) { rootMetaClass = cls; break; } cls = tmp; } NSLog(@\u0026#34;root MetaClass: %p\u0026#34;, rootMetaClass); \u0026ndash;\u0026gt;\nStudent instance addr: 0x100668810 Student class addr: 0x10000e7b8 isa: Student addr: 0x10000e7b8 isa: NSObject addr: 0x10000e790 isa: NSObject addr: 0x7fff806e7060 root MetaClass: 0x7fff806e7060 可以看出来，元类对象最终指向的是根元类对象，但它的名字也叫 NSObject，同时根元类的 isa 是指向自身的，所以最终形成了闭环。\n 实例 \u0026ndash;\u0026gt; 类 \u0026ndash;\u0026gt; 元类 \u0026ndash;\u0026gt; 根元类 ↩️\n    继承链 # 再来看一下继承关系，\nClass cls = [stu class]; id rootClass = nil; while (cls) { NSLog(@\u0026#34;class: %s addr: %p\u0026#34;, object_getClassName(cls), cls); if (!class_getSuperclass(cls)) { rootClass = cls; } cls = class_getSuperclass(cls); } NSLog(@\u0026#34;rootClass: %p\u0026#34;, rootClass); \u0026ndash;\u0026gt;\nclass: Student addr: 0x10000e7b8 class: Person addr: 0x10000e768 class: NSObject addr: 0x7fff806e7088 rootClass: 0x7fff806e7088 继承链比较简单：\n 子类 -\u0026gt; 父类 -\u0026gt; 根类 -\u0026gt; nil\n    可以看出来根类没有父类，顺便我们看一下根类的 isa 指向哪里？\nNSLog(@\u0026#34;rootClass\u0026#39;isa: %p\u0026#34;, object_getClass(rootClass)); // rootClass\u0026#39;isa: 0x7fff806e7060 地址 0x7fff806e7060 与前面根元类 rootMetaClass 一样，这也证实了 根类 --\u0026gt; 根元类。\n  http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"February 14 2022","permalink":"/posts/meta-class/","section":"碎語閑言","summary":"\u003cp\u003eMeta 这个词在 2021 年下半年开始火爆，而后 Facebook 改名 Meta 引发各大科技公司跟风押注。似乎全球资本都在追逐“元宇宙”的概念，但什么是“元宇宙”，各家有各家的说法，没有一个统一的标准。\u003c/p\u003e","title":"从 Meta 说起"},{"content":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。\n参考 OC 编译过程 我们可以借助 clang 工具将 OC 源码预处理成 CPP 来窥探 OC 的内部实现。\n定义一个简单的类：\n@interface Foo : NSObject @property (nonatomic, assign) BOOL ppty1; @property (nonatomic, copy) NSString *ppty2; - (BOOL)iMethod1; - (void)iMethod2:(NSString *)p1; + (void)cMethod1; @end 通过命令 clang -rewrite-objc xx.m 得到一个 9 万多行的 cpp 文件 😱\nhttps://gist.github.com/ryderfang/75a852f1ae0961aeea97127f7d9ca6c5\nTL;DR # 太长不看版：\n 🧸 objc_object 是所有实例对象的底层结构，内部只有一个 isa\n  🎁 objc_class 是所有类/元类对象的底层结构，它也有一个 isa 指针，指向自己的元类\n     OC 1.0 OC 2.0     id 实例 typedef struct objc_object *id; typedef struct objc_object *id;   objc_object struct objc_object {} struct objc_object {}   Class 类 typedef struct objc_class *Class; typedef struct objc_class *Class;   objc_class struct objc_class {} struct objc_class : objc_object {}     Class 是什么 # Class 1.0 # 在 \u0026lt;objc/objc.h\u0026gt; 中有这样一行：\ntypedef struct objc_class *Class;\n在 iOS 15 之前 \u0026lt;objc/runtime.h\u0026gt; 中曾经有 objc_class 的定义：\nhttps://opensource.apple.com/source/objc4/objc4-750/runtime/runtime.h.auto.html\n/* Types */ #if !OBJC_TYPES_DEFINED  struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__  Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif  } OBJC2_UNAVAILABLE; /* Use `Class` instead of `struct objc_class *` */ #endif 目前我使用的 Xcode 13.2.1 中已经找不到这个定义，也就是说在 macOS 12.1 / iOS 15.2 中，OBJC1 已经被完全废弃。\n Hint: 按照官方文档 Runtime Version 的解释, legacy 版本 (OC 1.0) 在 2007 年就完全废弃了，所有 iPhone 和 OSX 10.5 以后的 Mac 上使用的都是 modern 版本 (OC 2.0)!\n  根据 wiki 的说明，OC 2.0 于 2006 年发布，而 iPhone 第一代 是在 2007 年发布的，Mac OS X 10.5 Leopard 也是在 2007 年上市。\n 从这个宏 OBJC2_UNAVAILABLE 可以看出来 OBJC2 这种定义会失效。那么 OBJC2 是什么？\nClass 2.0 # 在 objc-runtime-new.h 中定义了 objc_class 的 2.0 版本：\nstruct objc_class : objc_object { // Class ISA;  Class superclass; cache_t cache; // formerly cache pointer and vtable  class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags  class_rw_t *data() { return bits.data(); } ... } 参考 1 和 2\n了解到，苹果在 2006 年重写了 runtime，发布了新的 Runtime 2.0，那么 __OBJC2__ 这个宏是什么时候生效的呢？\n通过查找苹果公开的 runtime 源码：https://opensource.apple.com/source/objc4/ 发现：\n从 objc4-750 这个版本开始，在 objc-config.h 中开始有了 __OBJC2__ 的定义！\n// Define __OBJC2__ for the benefit of our asm files. #ifndef __OBJC2__ # if TARGET_OS_OSX \u0026amp;\u0026amp; !TARGET_OS_IOSMAC \u0026amp;\u0026amp; __i386__  // old ABI # else # define __OBJC2__ 1 # endif #endif 来自 apple 的 commit：\n   https://github.com/apple-oss-distributions/objc4/commit/26c7408b94ead1f04a0b5976e354a03966ce61ea\n在 objc-api.h 中定义了 OBJC_ISA_AVAILABILITY:\n/* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable * in the future */ #if !defined(OBJC_ISA_AVAILABILITY) # if __OBJC2__ # define OBJC_ISA_AVAILABILITY __attribute__((deprecated)) # else # define OBJC_ISA_AVAILABILITY /* still available */# endif #endif 在 objc-private.h 中同时定义了 OBJC_TYPES_DEFINED:\n/* Isolate ourselves from the definitions of id and Class in the compiler * and public headers. */ #ifdef _OBJC_OBJC_H_ #error include objc-private.h before other headers #endif  #define OBJC_TYPES_DEFINED 1 同时也定义了 Class 和 id\ntypedef struct objc_class *Class; typedef struct objc_object *id; 所以，不管 OC 1.0 还是 2.0，\n Class 都是一个叫 objc_class 的结构体指针。\n Object 与 id # 在 \u0026lt;objc/objc.h\u0026gt; 中，定义\nhttps://opensource.apple.com/source/objc4/objc4-750/runtime/objc.h.auto.html\nObject 1.0 # #if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; #endif 同样被包在 OBJC_TYPES_DEFINED 宏中，也就是 OC 2.0 并不生效。\n那么，OC 2.0 的 objc_object 是什么样的呢，在 objc-private.h 中定义了：\nObject 2.0 # struct objc_object { private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object  Class ISA(); // initIsa() should be used to init the isa of new objects only.  // If this object already has an isa, use changeIsa() for correctness.  // initInstanceIsa(): objects with no custom RR/AWZ  // initClassIsa(): class objects  // initProtocolIsa(): protocol objects  // initIsa(): other objects  void initIsa(Class cls /*nonpointer=false*/); void initClassIsa(Class cls /*nonpointer=maybe*/); void initProtocolIsa(Class cls /*nonpointer=maybe*/); void initInstanceIsa(Class cls, bool hasCxxDtor); // 省略大量方法  private: void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor); // 省略大量方法` }; 可以看出来不管 OC 1.0 还是 2.0,\n objc_object 都是一个包含着一个叫 isa 指针/变量 的对象。\n isa 又是什么 # 在 1.0 版本中 isa 就是一个 Class 对象，也就是一个指向 objc_class 的指针，而在 2.0 时，isa 是一个叫 isa_t 的结构体变量。\n那么 isa_t 是什么呢？\n同样在 objc-private.h 中有定义：\nunion isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } uintptr_t bits; private: // Accessing the class requires custom ptrauth operations, so  // force clients to go through setClass/getClass by making this  // private.  Class cls; public: #if defined(ISA_BITFIELD)  struct { ISA_BITFIELD; // defined in isa.h  }; bool isDeallocating() { return extra_rc == 0 \u0026amp;\u0026amp; has_sidetable_rc == 0; } void setDeallocating() { extra_rc = 0; has_sidetable_rc = 0; } #endif  void setClass(Class cls, objc_object *obj); Class getClass(bool authenticated); Class getDecodedClass(bool authenticated); }; 参考 1 的图：\n   作为一个 union 结构，与 struct 区别在于，成员之间会互相覆盖，union 的总内存占用等于最大的成员占用的内存大小，而 struct 大小至少是成员内存占用之和，如果需要字节对齐则会更大。\n所以采用 union 结构可以节省内存。\n在 objc-object.h 中，有 objc_object::initIsa() 的实现：\ninline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { ASSERT(!isTaggedPointer()); if (!nonpointer) { isa = isa_t((uintptr_t)cls); } else { ASSERT(!DisableNonpointerIsa); ASSERT(!cls-\u0026gt;instancesRequireRawIsa()); isa_t newisa(0); #if SUPPORT_INDEXED_ISA  ASSERT(cls-\u0026gt;classArrayIndex() \u0026gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE  // isa.nonpointer is part of ISA_MAGIC_VALUE  newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-\u0026gt;classArrayIndex(); #else  newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE  // isa.nonpointer is part of ISA_MAGIC_VALUE  newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls \u0026gt;\u0026gt; 3; #endif  // This write must be performed in a single store in some cases  // (for example when realizing a class because other threads  // may simultaneously try to use the class).  // fixme use atomics here to guarantee single-store and to  // guarantee memory order w.r.t. the class index table  // ...but not too atomic because we don\u0026#39;t want to hurt instantiation  isa = newisa; } } 可以看出 isa_t 中的 Class 与 bits 是互斥的，避免了互相覆盖的问题。\n  https://halfrost.com/objc_runtime_isa_class/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://kangzubin.com/objc1.0-class-object/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"January 4 2022","permalink":"/posts/class-object-isa/","section":"碎語閑言","summary":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。","title":"Class, Object 与 isa"},{"content":"本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章：\nResponding to the Launch of Your App\n有个主要的流程图：\n   另外，还有一篇介绍如何优化启动速度的文章，毕竟只有准确了解了启动中做了哪些事，才能更针对地进行优化。\nReducing Your App’s Launch Time\n这里还参考了以下几篇文章：\n[1]: iOS App 启动优化\n[2]: iOS App 从点击到启动\n[3]: 深入了解 App 启动过程\n总结一下：\n系统层 # pre-main 阶段 # main 方法 # 首屏渲染后 # ","date":"December 28 2021","permalink":"/posts/app-launch-process/","section":"碎語閑言","summary":"本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章：","title":"发生在用户点击 icon 之后"},{"content":"概述 # Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。\n当我们在讲 Runtime 的时候，我们在说什么？\n根据官方文档的定义，\nObjective-C Runtime\nObjective-C Runtime Programming Guide\nRuntime 是一个动态库 (/usr/lib/libobjc.A.dylib)，用于实现 OC 语言的动态性。\n这个动态性主要体现在三个方面 ref:\n Dynamic Typing 运行时才能决定对象的类型，也就是说编译器不检查类型合法性 Dynamic Binding 运行时才能知道方法被如何执行，也就是消息机制 (messaging) Dynamic Loading 允许动态添加类、方法等  起源 # 孙源大佬在 博客 中说过，OC1 其实是 C 语言与 SmallTalk2 思想结合的产物。\n与同属 SmallTalk 学派的语言 Java, Python 和 Ruby 一样，OC 具有面向对象、动态类型和反射式等特点。\n Objective-C = C + Preprocessor + Runtime\n SmallTalk 领先了时代 20 年，至今 OC 仍然没有实现它的全部特性。\nRuntime Version # 存在两个版本的 Runtime，modern 和 legacy：\ndeveloper.apple.com/ObjCRuntimeGuide/ocrtVersionsPlatforms\n按照官方的说明，所有 iPhone 和 10.5 版本之后的 Mac OSX 64 位程序都使用的 OC 2.0。\nRuntime 源码: https://opensource.apple.com/source/objc4/\n下载 tarballs: https://opensource.apple.com/tarballs/objc4/\n可调试项目: https://github.com/RetVal/objc-runtime\nRuntime 里有什么 # Runtime 的源码可以在 RetVal/objc-runtime 这里找到，甚至可以 Debug。\n主要包含如下几个方面，后续会逐个总结。\nClass/Object 与 isa # 参考：Class Object 与 isa\nMetaClass #   元类指向链: 实例 -\u0026gt; 类 -\u0026gt; 元类 -\u0026gt; 根元类 -\u0026gt; 根元类 (isa 指向自己) 类的继承链: 子类 -\u0026gt; 父类 -\u0026gt; NSObject -\u0026gt; nil 元类的继承链: 子类元类 -\u0026gt; 父类元类 -\u0026gt; 根元类 -\u0026gt; NSObject -\u0026gt; nil   参考：从 Meta 说起\nMethod/IMP/SEL # Category # Messaging # Swizzling # 其它常用方法 # ++++++\n  https://zh.wikipedia.org/wiki/Objective-C\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://zh.wikipedia.org/zh-hans/Smalltalk\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"December 28 2021","permalink":"/posts/what-is-runtime/","section":"碎語閑言","summary":"概述 # Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。","title":"ObjC 之 Runtime 是个啥"},{"content":"很早之前看过一个 前端 Roadmap，图做的非常漂亮。最近发现有人做了类似的 移动端 Roadmap，\n其中 iOS 是这样的：\n   还有 Swift 的，暂时先不关注了。这里综合一下形成文字版，方面查缺补漏。\n   iOS 的体系结构如下图：\n    Ref: iOS abstraction layers\n 需要重点关注的有下面几个方面：\nFoundation # I. ARC/MRC 3️⃣ # ARC is supported in Xcode 4.2 for OS X v10.6 and v10.7 (64-bit applications) and for iOS 4 and iOS 5.\n现在除了一些老项目，基本没有 MRC 为主的代码了，所以只需要简单了解下 MRC 与 ARC 的区别即可\n  MRC 需要手动写 dealloc，并且一定要最后再调用父类的 dealloc； ARC 一般不需要写 dealloc，也不需要调用 [super dealloc]。移除 NSNotification Observer 和 KVC Observer 例外。\n  在 ARC 的工程中使用 MRC，需要在工程中设置源文件的编译选项 -fno-objc-arc\n  II. AutoReleasePool 4️⃣ #   AutoReleasePool 的数据结构\n  AutoReleasePool 与 @autoreleasepool\n  III. Block 5️⃣ #   block 的结构体类型\n  block 如何捕获外部变量\n  循环引用 与 Weak-Strong Dance\n  IV. Category 5️⃣ #   load 加载时机\n  load 与 initialze\n  category 覆盖原类方法的原理\n  category 同名方法调用顺序\n  V. HotPatch 1️⃣ #  JSPatch 的原理  VI. KVC 2️⃣ #  KVC 是如何实现的  VII. KVO 4️⃣ #  KVO 的原理  VIII. MultiThread 4️⃣ #   哪些多线程方法\n  互斥锁与自旋锁\n  IX. Network 3️⃣ #  NSURLSession 与 NSURLConnection  X. NSTimer 5️⃣ #   timer 与 Runloop\n  timer 导致循环引用的产生与解决\n  XI. Property 5️⃣ #   不同属性的区别\n  weak 与 copy\n  atomic 并不是线程安全的\n  如何实现一个弱引用容器\n + [NSPointerArray weakObjectsPointerArray] 弱引用数组 + [NSMapTable weakToWeakObjectsMapTable] 弱引用表 + [NSHashTable weakObjectsHashTable] 弱引用 hash 表 + [NSValue valueWithNonretainedObject:] 弱引用对象    XII. Runloop 4️⃣ #   Runloop 与线程的关系\n  如何实现一个常驻线程\n  XIII. Runtime 5️⃣ # 一图胜千言，引用 Runtime 工程师 Greg Parker 在其博客中给出的经典图\n   系列文章：Runtime 是个啥？\nUIKit # UIView 与 CALayer #   bounds 与 frame\n  setNeedsDisplay 与 layoutIfNeeded\n  常用 UI 组件 #   UIScrollView\n  UITableView\n  UICollectionView\n  AutoLayout #  Masonary 原理  UIResponder #   touch events\n  hitTest\n  离屏渲染 #  layoutSubview 与 drawRect  Core 系列 # Core Graphics #  高效绘制圆角  Core Data # AVFoundation #","date":"December 23 2021","permalink":"/posts/objc-roadmap/","section":"碎語閑言","summary":"\u003cp\u003e很早之前看过一个 \u003ca href=\"https://github.com/kamranahmedse/developer-roadmap\"\u003e前端 Roadmap\u003c/a\u003e，图做的非常漂亮。最近发现有人做了类似的 \u003ca href=\"https://github.com/godrm/mobile-developer-roadmap\"\u003e移动端 Roadmap\u003c/a\u003e，\u003c/p\u003e\n\u003cp\u003e其中 iOS 是这样的：\u003c/p\u003e","title":"ObjC 之 技术路线图"},{"content":"时隔两年，再次拾起博客。\n我完全不是一个有恒心的人，而且做什么事都是三分钟热度。包括博客，从 Jekyll 到 Hexo，再到现在 Hugo。\n有新鲜玩意都想把玩一下，折腾完了又觉得索然无味。注重形式大于内容，纠结字体字号、各种样式的事情，反而没什么内容沉淀下来。\n关于博客 # 在腾讯云买了域名 ryderfang.com，然后折腾备案、SSL 证书部署、nginx 配置静态页面等等， 目前源文件拖管在 Github 上，每次 push 自动触发 Actions， 完成编译并推送到 gh-pages 分支的操作。站内搜索使用 algolia，使用手动 Actions 的方式，需要时触发更新。\n同样在腾讯云买了一个轻应用服务器，托管一下这个静态博客，不打算再折腾自动化了，需要同步的时候 ssh 登录一下，手动拉一下 repo 就好。\n 哈哈，总是在打脸，还是把自动同步服务器做成了一个 Action\n - name: remote ssh command uses: appleboy/ssh-action@master with: host: ${{ secrets.TENCENT_CLOUD_HOST }} username: ubuntu key: ${{ secrets.TENCENT_CLOUD_KEY }} port: 22 script: | whoami cd blog \u0026amp;\u0026amp; git pull echo \u0026#39;Done!\u0026#39; 再把之前的博客内容整理到新的博客上，发现并没多少值得保留的，真是有点惭愧。\n技术目标 # 常常想起小时候爸爸告诫我的话：\n 有志之人立常志，无志之人常立志。\n 但是，这么多年的工作经历，让我认识到自己只是个普通人。普通的技术、普通的能力和普通的志向，甚至于在 “内卷” 与 “躺平” 的浪潮中，已经逐渐想要躺平。\n最近又看到一句话：\n 到底什么样的终点，才配得上这一路的颠沛流离 ?!\n 是啊，或许，我们只是想去码头整点薯条，人生本无太多意义。\n   扯远了，总之，普通人就定几个能完成的普通目标。也不要过分自责，因为你就是一粒宇宙的尘埃。\n写文章 # 到年底还有一个多月，输出 2-3 篇技术博客。\n UPDATE: 算完成 80% 吧，内容还需要补充\n iOS 技术栈 # 继续完善 iOS 八股技术栈: https://github.com/ryderfang/iOSBagu，尽可能去了解一些犄角旮旯的知识点。\n UPDATE: 没有完成，需要尽快补齐\n 读书 # 读一点其他领域的书，随便看一点。\n UPDATE: 没有完成，多读书是 2022 重点目标\n 生活目标 # 健康 # 身体 NO.1，换季的时候，一家人都得了咽炎，去医院太折腾了。希望全家都健康，宝宝也快点长大，少让姥姥和大家操点心吧。\n UPDATE: 安安越来越大了，前段时间脸上又被虫咬了一大块，最近快长好了。\n  平安、健康、快乐，足矣。没有别的希冀。\n 早起 # 每天送老婆上班，虽然累，但还是挺好的，早到公司一小时，可以做很多事了。困的问题就中午多午睡一会儿吧。\n能睡说明自己还年轻吧，至少没有失眠的困扰，感觉至少要睡十个小时才能满足，也只能周末才有这个机会了。\n UPDATE: 本来年底想面试一下来年换个工作，但老婆可能也要换，准备还是继续苟一段时间。\n  总的来说，鹅厂的人文关怀还是可以的。但不同项目组也差异很大，PCG 确实是个天坑。\n 结语 # 就这些吧，我感觉能完成 80% 就已经很不错了。元旦的时候再来 check 一下 🚀\n","date":"November 16 2021","permalink":"/posts/2021-personal-challeng/","section":"碎語閑言","summary":"\u003cp\u003e时隔两年，再次拾起博客。\u003c/p\u003e","title":"2021 个人目标 🎯"},{"content":"G’day, I’m Ryder! 👋 # 互联网游荡者，历经 \u0026lsquo;BAT\u0026rsquo; 三家公司，现任鹅厂废柴搬砖工。\nI worked at Bilibili, Alibaba and now Tencent, still too vegetable to be a senior coder.\nNow I\u0026rsquo;m living with my wife and little son in Shanghai, China.\n Life is too short, Just enjoy it.\n 经历 # 🐧 腾讯科技（上海）有限公司  客户端开发 2019.11 - Now 手 Q 开发  相机渲染，道具特效等 图片、视频编辑 AI 端智能    🚼 口碑（上海）信息技术有限公司 | 阿里巴巴  高级无线开发工程师 2017.10 - 2019.11 口碑掌柜  业务开发、投放体系建设 Lottie 接入 阿里云语音SDK   技术专项  端 AI 智能算法 H5 容器相关    🏝 上海哔哩哔哩科技有限公司 | 幻电信息科技  iOS 开发工程师 2016.04 - 2017.10 iOS 客户端  C++ 转 iOS 开发 业务开发，视频收藏夹 图片治理，webP 接入等   UGC 投稿助手  QT \u0026amp; C++ 开发 多线程视频文件上传 稿件管理功能等    📟 上海二三四五网络科技有限公司  2013.12 - 2016.04 2345 单核/双核 浏览器  浏览器业务开发 逆向技术、Flash 兼容 广告拦截技术   看图王、好压  DirectUI C++ 多线程开发    +++\n","date":"November 11 2021","permalink":"/about/","section":"","summary":"G’day, I’m Ryder!","title":"About"},{"content":"Mark Zuckerberg 每年都会发布自己的年度挑战 Personal Challenge\nSo，我也要给自己立一些 Flag\u0026hellip;\n技术目标 # //\u0026lt;!-- --\u0026gt; console.log(\u0026#39;达到中初级前端工程师水平\u0026#39;) //\u0026lt;!-- --\u0026gt;  UPDATE: 并没有达到 😢\n 这将是技术广度拓宽的一年。\n最近几年，随着中年危机的提前到来，90年码农越来越焦虑，在知乎上的各种问题:\n35 岁以上的互联网 / 科技行业从业者面临裁员时，应如何规划职业发展？\n新时代的中年危机长啥样？\n30岁程序员的出路\n知乎圆桌 - 30 岁人生攻略\n等等\n很多人表达了这样一个观点，要想维持职场生命力，必须要努力掌握更深更广地技能。\n成为所谓的斜杠 (Slash) 青年，不再满足于单一职业，而是多元化发展。\n生活目标 # 早点睡觉 # 常年处于缺觉的状态，整个人都不好了\n TODO: 最好 11:30 pm 前睡觉\n 锻炼身体 # 小肚子减减减呀！\n家里收拾好 # 养了点花花草草，买了一只小龟龟，希望它明年还在\n UPDATE: 小龟龟被我养死了 😭\n 结婚吧 # 在一起快一年了，喜欢她的性格，也觉得该修成正果，安定下来了。\n UPDATE: 2018.12.01 相识 520 天，我们结婚啦！👫 💕💕\n","date":"January 29 2018","permalink":"/posts/2018-personal-challenge/","section":"碎語閑言","summary":"\u003cp\u003eMark Zuckerberg 每年都会发布自己的年度挑战 \u003ca href=\"https://www.facebook.com/zuck/posts/10104380170714571\"\u003ePersonal Challenge\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSo，我也要给自己立一些 Flag\u0026hellip;\u003c/p\u003e","title":"2018 个人目标 🎯"},{"content":"Chromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏\n 当然是因为好用(zhuāng bī) 了 😅\n 废话少说，下载地址： https://download-chromium.appspot.com/\n如果下载不了，可以试下：\n  Windows https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/\n  Mac https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Mac/\n  打不开之类的需要翻墙的问题自行解决吧。\n问题 # 打开 Chromium 会提示 缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用 😒\n由于 Chromium 使用的 API 都需要自行申请密钥才能使用。\n所以 在 https://console.cloud.google.com/ 上创建密钥。\n相关文档：http://www.chromium.org/developers/how-tos/api-keys\n最后密钥有三个，位置在 https://console.cloud.google.com/apis/credentials\n GOOGLE_API_KEY GOOGLE_DEFAULT_CLIENT_ID GOOGLE_DEFAULT_CLIENT_SECRET  解决 # 官方的解决方法是：\n将下面三行写到 ~/.bash_profile 中，然后重启浏览器即可\nexport GOOGLE_API_KEY=\u0026#34;****\u0026#34; export GOOGLE_DEFAULT_CLIENT_ID=\u0026#34;**** export GOOGLE_DEFAULT_CLIENT_SECRET=\u0026#34;****\u0026#34; $source ~/.bash_profile 这样，有时是管用的。特别是在 Windows上，使用类似的在命令行输入：\nsetx GOOGLE_API_KEY your_key_goes_here setx GOOGLE_DEFAULT_CLIENT_ID your_client_id_goes_here setx GOOGLE_DEFAULT_CLIENT_SECRET your_client_secret_goes_here 但是 Mac 上有时不管用，参考:\nhttps://gist.github.com/cvan/44a6d60457b20133191bd7b104f9dcc4\n在文档最后，发现有个哥们写了一个 Python 脚本，试了下，很好用！\n我 Fork 了一下，修复了一个 bug，给他提了 PR (https://github.com/ezeeyahoo/ChromiumSyncEnabler/pull/1)\nhttps://github.com/ryderfang/ChromiumSyncEnabler\n跑下来重启 Chromium 就 OK 了！\n","date":"January 26 2018","permalink":"/posts/chromium-api-keys/","section":"碎語閑言","summary":"\u003cp\u003eChromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏\u003c/p\u003e","title":"Chromium 缺少 Google API 密钥解决办法"},{"content":"Visual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。\n其中 社区版 Community Version 是永久免费的。\n唯一不足的是在导出图表为图片时，右下角会有一个水印。\n   本文就是要使用 Python 去除这个水印，输出 png 图片。\n 该方法参考了网络上手动去除的方法，需要有一些操作\n 导出 # 首先需要将完成的图表导出为 svg 格式的图片：\n   选择 svg 格式保存：\n   这样我们就得到了一个带水印的 svg 图片:\n   去除水印 #  处理 svg 图片   Svg（Scalable Vector Graphics，可缩放矢量图形） 是一种矢量图片格式，可以使用文本编辑器直接打开，可以看得到在最后几行有水印的内容，所以我们可以用代码自动把他们去掉（当然也可以手动删除）。\n 水印内容在 Svg 文件中：\n\u0026lt;text x=\u0026#34;68\u0026#34; xml:space=\u0026#34;preserve\u0026#34; y=\u0026#34;276\u0026#34; stroke=\u0026#34;none\u0026#34; \u0026gt;Powered ByVisual Paradigm Community Edition\u0026lt;/text \u0026gt;\u0026lt;image font-size=\u0026#34;12\u0026#34; x=\u0026#34;303\u0026#34; y=\u0026#34;264\u0026#34; fill=\u0026#34;white\u0026#34; width=\u0026#34;16\u0026#34; xlink:href=\u0026#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABvklEQVR42o1TPUgC YRi+z1PSzWrSc6ho6W/xNIhEoZoCl/a2fqaGoJKwyHIp16ZyCyIolwpq6c8lIz0h h6ACa/KWOHGz4byezz7lkNM8eHjf7/ve53l/vu84rsWXEcVo2uOJtYrhW5A3YCKE 48YXnE7zoSzfty3AyFHdln/R4bBA5O5fgQbyiUbIK6oY5gjxG1XCtyAngFl7qXT+ Y7UOwR+glTSK8EZkomlJMZsNCrKs7iuKOuXzJboUJYAqemrtHEBkGwsTIy/pe0bZ /Rmvd6K27svnx7Q/cu08LIliiPpmlvEGJo0DL4sRSKVyBuEZledznKpeYs+u6/YF nKt6C+jpe14QPjCsQUpmQVYgaNK0R9hPYJLtZ5Eo5JGkVF0AmUZAvoBLM5WBXhZs A6YB+pi+AAudD+zOnMuVjBcKheoMbOXyG0wcWKGtAPr77gauKyYTFU8g+xrsUWex mKu2r79Gye3eQkAE7i4wCtQG+YTMKZwt0zOUv274DjCLJGZBoEqv9JRtyyDfgrwK f09PNnyJ6OuBiYSxPAbecf9UMNZIbvovUBE8FjRINrEMNJbd1t9I28Gz7YD7DHKo WdwvFl2vGaThOSEAAAAASUVORK5CYII=\u0026#34; height=\u0026#34;16\u0026#34; stroke=\u0026#34;white\u0026#34; preserveAspectRatio=\u0026#34;none\u0026#34; /\u0026gt; 用 Python 读取文件内容，去除这一段内容即可。\n 转换成 png 图片  然后将 Svg 格式转换成 png格式，这里有现成的库 cairosvg 来实现。\n完整的代码可以在 我的 Github 上找到。\n使用方法 #  需要先安装 cairosvg:  $ pip3 install cairosvg 可能会报错，Pillow 安装失败，提示： The headers or library files could not be found for zlib.\n可以尝试一下:\n$ xcode-select —-install $ brew install libtiff libjpeg webp little-cms2 $ pip3 install Pillow 安装 cairosvg 成功后，使用 Python3 import cairosvg 发现还是报错:\n\u0026gt;\u0026gt;\u0026gt; import cairosvg Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/__init__.py\u0026#34;, line 29, in \u0026lt;module\u0026gt; from . import surface File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/surface.py\u0026#34;, line 24, in \u0026lt;module\u0026gt; import cairocffi as cairo File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\u0026#34;, line 41, in \u0026lt;module\u0026gt; cairo = dlopen(ffi, \u0026#39;cairo\u0026#39;, \u0026#39;cairo-2\u0026#39;) File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\u0026#34;, line 38, in dlopen raise OSError(\u0026#34;dlopen() failed to load a library: %s\u0026#34; % \u0026#39; / \u0026#39;.join(names)) OSError: dlopen() failed to load a library: cairo / cairo-2 经过搜索，发现还需要安装 cairo 和 libffi：\n$ brew install cairo pango gdk-pixbuf libffi  终于弄完了     源文件： vp_remove_watermark.py\n 核心代码如下：  import cairosvg svg_content = \u0026#39;\u0026#39; with open(src_name, \u0026#39;r\u0026#39;) as f: svg_content = f.read() end = svg_content.rfind(\u0026#39;\u0026lt;/g\u0026#39;) beg = svg_content.rfind(\u0026#39;\u0026lt;g\u0026#39;, 0, end) svg_content = svg_content[:beg] + svg_content[end:] with open(\u0026#39;./vp_test_out.svg\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(svg_content) cairosvg.svg2png(url=\u0026#39;./vp_test_out.svg\u0026#39;, write_to=dst_name)  赶紧跑起来  $ python vp_remove_watermark test.svg -o out.png ","date":"January 25 2018","permalink":"/posts/visual-paradigm-remove-watermark/","section":"碎語閑言","summary":"\u003cp\u003eVisual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。\u003c/p\u003e\n\u003cp\u003e其中 \u003ca href=\"https://www.visual-paradigm.com/cn/download/community.jsp\"\u003e社区版 Community Version\u003c/a\u003e 是永久免费的。\u003c/p\u003e","title":"移除 Visual Paradigm 流程图的水印"},{"content":"最近开始学习 Vue.js, 一脸懵逼地进入前端世界。\n不使用 vue-cli 和 webpack 这些构建工具，使用单个 html 引入 Vue。\nhtml 内容是这样的:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Vue\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#39;app\u0026#39;\u0026gt; \u0026lt;span v-bind:title=\u0026#34;message\u0026#34;\u0026gt;鼠标悬停\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;页面加载于 \u0026#39; + new Date().toLocaleString() } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用浏览器打开这个 html 就可以看到效果（鼠标悬停显示『页面加载于yyyy-MM-dd hh:mm:ss』）\n安装 Vue-Devtools，但是插件栏显示\nVue.js not detected\n    由于访问的路径是 file:// 文件路径，Chrome 扩展默认是不能访问的。\n Vue.js not detected # 打开右上角 ... -\u0026gt; 更多工具 -\u0026gt; 扩展程序，找到 Vue.js devtools，选中 允许访问文件网址:\n   OK，然后 devtools 仍然不可用，提示\nVue.js is detected on this page. Devtools inspection is not available because it's in production mode or explicitly disabled by the author.\n 由于我们使用的 vue.js https://cdn.jsdelivr.net/npm/vue 是生产版本，所以不能访问。\n Production mode # 下载开发版本的vue.js，放到本地，修改src路径为本地即可。\n  开发版本: https://vuejs.org/js/vue.js\n  生产版本: https://vuejs.org/js/vue.min.js (或者 https://cdn.jsdelivr.net/npm/vue)\n  Vue-Devtools # 这样，打开开发者工具 (option + command + i || F12)\n可以看到多了一个Vue的Tab:\n   ","date":"January 24 2018","permalink":"/posts/vue-devtools/","section":"碎語閑言","summary":"\u003cp\u003e最近开始学习 \u003ca href=\"https://cn.vuejs.org/\"\u003eVue.js\u003c/a\u003e, 一脸懵逼地进入前端世界。\u003c/p\u003e\n\u003cp\u003e不使用 \u003ccode\u003evue-cli\u003c/code\u003e 和 \u003ccode\u003ewebpack\u003c/code\u003e 这些构建工具，使用单个 html 引入 Vue。\u003c/p\u003e","title":"Vue 调试工具 Devtools"},{"content":"关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是:\n$ npm install -g hexo $ hexo init $ hexo generate (hexo g) $ hexo server (hexo s) $ hexo new [name] - 新建文章 $ hexo new page [name] - 新建页面 正常情况下，这样就会启动本地的服务:http://localhost:4000，但现实总是残酷的，\n由于国内XXX的网络环境，总会遇到各种各样的问题，\n下面总结一下本博客迁移到Hexo过程中遇到的一些问题。\nNPM 源 # node的包管理工具npm，默认使用国外的源，访问比较慢，建议换成国内源，一般是淘宝npm:\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用cnpm代替npm进行模块安装了:\n$ cnpm install [name] 或者，使用nrm (npm的源管理工具):\n$ npm install nrm $ nrm ls * npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ $ nrm use taobao $ nrm test taobao Hexo 安装 # hexo-server # hexo server执行失败:\nERROR Plugin load filed: hexo-server 需要单独安装hexo-server:\n$ npm install hexo-server --save node-sass # $ npm install node-sass --save 如果出现如下情况:\n$ node scripts/install.js Cannot download \u0026#34;https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node\u0026#34;: read ECONNRESET Hint: If github.com is not accessible in your location try setting a proxy via HTTP_PROXY, e.g. export HTTP_PROXY=http://example.com:1234 or configure npm proxy via npm config set proxy http://example.com:8080 $ node-sass@4.5.3 postinstall /private/tmp/node_modules/node-sass $ node scripts/build.js 说明github访问比较慢，两种方法：\n 修改host:   http://tool.chinaz.com/dns?type=1\u0026amp;host=github.com\u0026amp;ip= 找一个TTL比较小的host，如:\n 192.30.255.112 github.com  直接去github下载   https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node 然后将该文件放到目录:~/.npm/node-sass/4.5.3/darwin-x64-51_binding.node 再执行安装命令\n $ npm intall node-sass --save hexo-renderer-scss # 有些主题需要安装hexo-renderer-scss:\n$ npm install hexo-renderer-scss --save 会出现错误:\nERROR Plugin load failed: hexo-renderer-scss Error: ENOENT: no such file or directory, scandir \u0026#39;xxx/node_modules/node-sass/vendor\u0026#39; at Object.fs.readdirSync (fs.js:914:18) ... 提示这个目录找不到，那我们手动创建好了:\n$ mkdir xxx/node_modules/node-sass/vendor $ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor 接下来还是报错:\nERROR Plugin load failed: hexo-renderer-scss Error: Missing binding xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 7.x Found bindings for the following environments: 到这个目录下，把刚刚下载的darwin-x64-51_binding.node重命名复制进去好了:\n$ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/ $ cp darwin-x64-51_binding.node xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node 页面空白 # 有时执行hexo s后显示服务启动，但页面打开空白，显示Cannot GET /，这种情况有很多原因，\n可以尝试:\n$ npm install $ hexo cl $ hexo g $ hexo s 如果还有问题，查看一下npm插件是否安装正常:\n$ npm ls --depth 0 hexo-site@0.0.0 xxx ├── hexo@3.3.9 ├── hexo-deployer-git@0.3.1 ├── hexo-generator-archive@0.1.4 ├── hexo-generator-baidu-sitemap@0.1.2 ├── hexo-generator-category@0.1.3 ├── hexo-generator-feed@1.2.2 ├── hexo-generator-index@0.2.1 ├── hexo-generator-sitemap@1.2.0 ├── hexo-generator-tag@0.2.0 ├── hexo-renderer-ejs@0.3.1 ├── hexo-renderer-marked@0.3.0 ├── hexo-renderer-scss@1.0.3 ├── hexo-renderer-stylus@0.3.3 ├── hexo-server@0.2.2 └── node-sass@4.5.3 npm ERR! invalid: hexo-generator-baidu-sitemap@0.0.8 xxx/node_modules/hexo-generator-baidu-sitemap/node_modules/hexo-generator-baidu-sitemap 可以看到hexo-generator-baidu-sitemap这个插件安装失败了，尝试重新安装或者删除它:\n$ npm install hexo-generator-baidu-sitemap --save $ npm uninstall hexo-generator-baidu-sitemap 或者在package.json中将它删除掉。\n","date":"September 27 2017","permalink":"/posts/hexo-workflow/","section":"碎語閑言","summary":"\u003cp\u003e关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ npm install -g hexo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo init\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo generate \u003cspan class=\"o\"\u003e(\u003c/span\u003ehexo g\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo server \u003cspan class=\"o\"\u003e(\u003c/span\u003ehexo s\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo new \u003cspan class=\"o\"\u003e[\u003c/span\u003ename\u003cspan class=\"o\"\u003e]\u003c/span\u003e - 新建文章\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo new page \u003cspan class=\"o\"\u003e[\u003c/span\u003ename\u003cspan class=\"o\"\u003e]\u003c/span\u003e - 新建页面\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"使用 Hexo 遇到的一些问题"},{"content":"   来自一个神奇的域名: http://fuckingblocksyntax.com/\nDeclaration # local variable # returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; property # @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); method parameter # - (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; argument to a method call # [someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; typedef # typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; Hint #  block 在 ARC 下是否声明为 copy 属性  It is still a good idea to declare block properties as having copy semantics since a block assigned to a strong property will in fact be copied.\nApple recommends this as well:\n You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior.\n ","date":"May 31 2017","permalink":"/posts/how-to-declare-block-in-oc/","section":"碎語閑言","summary":"来自一个神奇的域名: http://fuckingblocksyntax.","title":"在 ObjC 中如何定义 Block"},{"content":"最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。\n   我自己在虚拟机中试了下，确实这样！\n在用户机器中获取了 DUMP，只看到有几个线程一直在跑，调用堆栈中也看不到太多信息（主要是没有线程 CPU 占用信息），一时没有方法。\n今天突然想到 VS2013，新版本增加了一些功能，貌似有性能分析相关的。\n找了一下，果然在调试菜单下发现了性能与诊断：\n   选择 CPU使用率，就开始分析啦！\n很快就给出了分析结果：\n   哈哈！瞬间定位 CPU 占用元凶，原来是一个后台线程一直在跑（空转），设计不合理。这个线程最早设计成自驱动的，找到原因就好办了，改成被驱动式就行了！\n","date":"August 8 2016","permalink":"/posts/detect-cpu-usage-with-vs2013/","section":"碎語閑言","summary":"\u003cp\u003e最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。\u003c/p\u003e","title":"VS2013 检测 CPU 占用率"},{"content":"安装 Ruby 和 Ruby DevKit\n Ruby 2.2.4 Ruby DevKit  切换到安装目录：\n$ cd C:\\RubyDevKit $ ruby dk.rb init $ ruby dk.rb install 安装Jekyll\n$ gem install jekyll $ gem install wdm 切换到博客目录运行 bash $ jekyll build [--watch/-w] $ jekyll serve [--watch/-w]\n用浏览器打开http://127.0.0.1:4000，即可看到效果，而且在修改文件的同时刷新页面即可实时更新。\n可以通过\u0026ndash;port 888指定端口号，更多命令行参数参考[官方手册]1\n安装有问题，可以参考更多文档：\n  [Running Jekyll on Windows]2\n  [Jekyll Windows]3\n  [Setup Jekyll on Windows]4\n    http://jekyll.bootcss.com/docs/configuration/ \u0026ldquo;配置\u0026rdquo;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://jekyll-windows.juthilo.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://yizeng.me/2013/05/10/setup-jekyll-on-windows/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"June 5 2016","permalink":"/posts/install-jekyll-locally/","section":"碎語閑言","summary":"\u003cp\u003e安装 Ruby 和 Ruby DevKit\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-2.2.4.exe\"\u003eRuby 2.2.4\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://dl.bintray.com/oneclick/rubyinstaller/DevKit-mingw64-32-4.7.2-20130224-1151-sfx.exe\"\u003eRuby DevKit\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Jekyll 本地安装"}]