[{"content":" App 开发不可避免地要和内存问题打交道，OOM (Out Of Memory) 也是开发者非常头疼的问题。\n为了方便复现内存问题，我们可以手动分配一个大内存，这样在 App 启动之后根据用户的操作路径就有可能复现这类问题。\n在 Swift 中如何分配大内存呢？我们知道，Swift 一般来说变量的内存分配和销毁都是系统自动管理的 (ARC)，但 Swift 也为我们提供了直接访问内存的方法， 也就是 Pointer 类。\n分配大内存 # 回到开头的问题，我们可以在代码中定义一个 Pointer 类型的变量，分配一块大内存让它常驻。\npublic class AppDelegate: NSObject, AppDelegateProtocol { private var p: UnsafeMutablePointer\u0026lt;UInt8\u0026gt;? public override init() { super.init() // ... p = UnsafeMutablePointer.allocate(capacity: Int(1.8 * 1024 * 1024 * 1024)) p?.initialize(repeating: 0, count: Int(1.8 * 1024 * 1024 * 1024)) } } UInt8 是占用一个字节的整型数据，所以上面我们分配了 1.8G 的内存！\nTip: 超过 2G 内存 app 就很容易被系统杀掉：Terminated due to memory issue.\n手动内存管理 # https://medium.com/@shoheiyokoyama/manual-memory-management-in-swift-c31eb20ea8f\n","date":"October 11 2022","permalink":"/posts/2022/swift-manually-alloc-memory/","section":"碎语闲言","summary":"App 开发不可避免地要和内存问题打交道，OOM (Out Of Memory) 也是开发者非常头疼的问题。","title":"Swift 中手动管理内存"},{"content":"背景 # 最近在写 UT，使用 SnapshotTesting 对一些 UI 组件做测试。 为了方便扩展，使用了泛型(Generics) 。首先，有一个基类，大概是这样的：\nclass WidgetsTestCase\u0026lt;ViewClass: ViewClassProtocol\u0026gt;: XCTestCase { var sut: ViewClass! override func setUpWithError() throws { try super.setUpWithError() parseMockData() buildSut() } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() } func mockFileName() -\u0026gt; String { XCTAssertTrue(false, \u0026#34;This function must be overrided.\u0026#34;) return \u0026#34;\u0026#34; } func parseMockData() { let fileName = mockFileName() // ... } func buildSut() { } func testSut() throws { // ... } } 然后对于不同的 Widgets，仅是 mock 文件和 test 方法的少许区别：\nclass MyCellViewTests: WidgetsTestCase\u0026lt;MyCellView\u0026gt; { override func mockFileName() -\u0026gt; String { return \u0026#34;MyCellViewData.json\u0026#34; } override func testSut() throws { try super.testSut() let exp = expectation(description: \u0026#34;wait for image loading\u0026#34;) let result = XCTWaiter.wait(for: [exp], timeout: 2.0) if result == XCTWaiter.Result.timedOut { assertSnapshot(matching: sut, as: .image) } } } 但是在提交完代码跑 CI 流水线时发现，新写的 MyCellViewTests 文件只是被编译，但并没有被测试跑到。\n问题分析 # 首先，由于本地环境 (Xcode 14.0 \u0026amp; iOS 16.0) 和 CI 环境 (Xcode12.4 \u0026amp; iOS 14.2) 差距较大， 虽然本地跑起来没有问题，但一时无法找到原因在哪。\n开始怀疑是 throws 导致的，删除了仍然没有效果。\n而后又删除了 override，问题依旧。\n新增了一个直接继承 XCTestCase 的类，正常被测试。\n到这里，开始怀疑跟泛型有一定的关系，然后用 XCTestCase Generics 关键词搜索时，发现了关键线索：\nhttps://stackoverflow.com/questions/35273597/is-use-of-generics-valid-in-xctestcase-subclasses\n同样的单测框架 Quick 也被提过类似的 issue：\nhttps://github.com/Quick/Quick/issues/1060\n问题原因最终指向是 Xcode 的 bug (https://developer.apple.com/documentation/xcode-release-notes/xcode-12_5-release-notes)：\nXCTest now automatically includes specialized subclasses of Swift generic test classes when running tests on macOS 11.3, iOS 14.5, tvOS 14.5, watchOS 7.4, or later OS versions. This allows you to use generics to improve reusability of test classes.\n解决 # 既然暂时无法升级 CI 的 Xcode 版本，只能先想办法绕过这个问题。\n新增一个测试类，手动创建并调用这些泛型类的测试方法：\nclass DummyWidgetTests: XCTestCase { override func run() { XCTestSuite(forTestCaseClass: MyCellViewTests.self).run() super.run() } // At least one func is needed for `run` to be called func testDummy() { } } 提交，这次测试方法被执行到了！🎉🎉\n（但是又出现了 case 失败的情况，继续苦逼调试\u0026hellip;\nBe debugging\u0026hellip; 🐞\n","date":"October 9 2022","permalink":"/posts/2022/swift-xctest-generics-issue/","section":"碎语闲言","summary":"背景 # 最近在写 UT，使用 SnapshotTesting 对一些 UI 组件做测试。 为了方便扩展，使用了泛型(Generics) 。首先，有一个基类，大概是这样的：","title":"一个 Swift 泛型导致 XCTestCase 失效的问题"},{"content":"利益相关：\n在猫厂、鹅厂各呆过两年，在鹅晋升了两次都失败的菜狗程序员。\n不管你是写 C++/Java/OC/Python 还是 Haskell/Rust/Scala，都不如 PPT 有用。\n总之，大厂想晋升，一方面要靠个人的奋斗，主要还是要看历史的进程。\n这几年客户端一边被唱衰，另一边就是竞争白热化。可造的轮子也被造得差不多了。那么，靠什么才能晋升？\n方法论 (chě dàn) # 用阿里味儿来说，P6 -\u0026gt; P7 -\u0026gt; P8 是 点 -\u0026gt; 线 -\u0026gt; 面的关系。也就是 P6 负责需求点，P7 打通业务线，P8 搞定产业面。\n按鹅的职级来说，对标的就是 T8/T9 -\u0026gt; T10/T11 -\u0026gt; T12。\n但是！一般来说晋升答辩只有 30 分钟左右的时候向评委展示自己，想让平时跟你完全无交集的这些评委客观评价你，基本是不可能的。\n所以，包装才是核心，一般来说有这么几招：\n无中生有：啥也没干，说，“造了核弹”\n移花接木：Work is Fine, Now is Mine\n指鹿为马：虽然造了把破铁剑，但它是用天外陨石造的，所以好剑\n暗度陈仓：评委是我二舅，你懂的\n\u0026hellip;\n一图胜千言 # #! pip3 install jieba #! pip3 install wordcloud Python 真好用，嘿！\n","date":"July 7 2022","permalink":"/posts/2022/promote-dev-words/","section":"碎语闲言","summary":"利益相关：","title":"关于大厂晋升的那点事"},{"content":"书接上回，了解了 发生在用户点击 App Icon 之后 的过程，可以对各个阶段做针对性优化。\n回顾一下 App 启动的过程：\n通常来说，我们主要关注 pre-main 和 启动 Tasks 两个阶段。\n影响因素 # 系统层 # 在这个阶段影响启动速度的因素有：\n动态库的数量\nobjc 类和方法的数量\n+load 方法的数量\n__contructor__ 构造函数的数量\nC++ 静态初始化代码的数量\n业务层 # 启动的 Tasks 要具体分析，每个 app 情况不同，冷热启动也有所有不同。\n需要关注的点有：\n每个 Task 的耗时\n核心 Task 的执行时序\n异步 Task 占用内存/CPU 的情况\n各显神通 # 初阶优化 # 容易想到的一些优化点：\n动态库加载耗时 -\u0026gt; 转静态库\nPage fault 耗时 -\u0026gt; 二进制重排\nrebase/rebind，oc setup 耗时 -\u0026gt; 减少冗余代码\n+load 耗时 -\u0026gt; 减少 +load 使用，简化内部逻辑\nC/C++ 构造函数耗时 -\u0026gt; 优化 __contructor__ 代码\n启动 Task 耗时 -\u0026gt; 懒加载、延时加载、并行执行\n核心 Task 耗时 -\u0026gt; 专项优化，预加载\n进阶优化 # 图片加载优化 使用 xcassets 代码 bundle，图片读取速度提升 80 ~ 100 倍。\nbundle 加载图片相对慢的原因主要有两个：\n获取 Key Signature 时的位操作 为了线程安全所做的加锁操作 xcassets 相对更高效在于：\nUIAssetManager 存在一个 NSMapSet 缓存 未命中缓存时，会解压 Assets.car 查找 再找不到才去 bundle 中找 __TEXT__ 段 iOS 13 之前的系统会对 __TEXT__ 段加密，启动时进行解密，所以这个段的大小在中低端机器上会影响启动速度。\n通过 ld -rename_section 指令将 __TEXT__ 段重命名，规避系统加密操作。\n抖音就是将 __TEXT__ 重命名成了 __BD_TEXT__\n启动 Tasks 清理 清理 AppDelegate 和 Main 方法中的代码\n减少同步执行的高优任务 (Main Sync High Priority Tasks)\n通过 TaskManager 管理所有同步低优和异步任务，减少资源消耗\n动态库懒加载 一般情况下 dyld 会递归分析 app 依赖的所有动态库并自行加载。\n首先断开系统链接 使用 CocoaPods 的工程可以在 Podfile 中修改\nnew_xcconfig = new_xcconfig.sub(\u0026#39;-framework \u0026#34;XX\u0026#34;\u0026#39;, \u0026#34;\u0026#34;) 手动加载 使用 dlopen 或者 -[NSBundle loadAndReturnError:] 来实现。\n仅限于放在 ipa/Frameworks 目录下与主 app 同签名的动态库加载。\n调用 想要在动态库加载前使用动态库中的类是不行的。\n对于 OC 来说，可以使用 NSClassFromString 的反射方法，但是如果这个库已经被业务广泛使用，改造量会比较大。\n还有一种比较 Trick 的方案：\n使用宏定义 #define DyLibClassA ProxyClassB 将业务调用类转发到代理类中，实现所有 DyLibClassA 中的接口和协议 后记 # 优化之路无穷无尽，特别是在国内巨型 App 大行其道的今天，大家绞尽脑汗想出各种奇技淫巧只为那几千字节的优化。\n我想说的是，\n最大的优化应该是精简无效的业务代码，删除无用的功能，拒绝垃圾需求。\n","date":"July 4 2022","permalink":"/posts/2022/app-launch-speedup/","section":"碎语闲言","summary":"书接上回，了解了 发生在用户点击 App Icon 之后 的过程，可以对各个阶段做针对性优化。","title":"iOS 之 App 启动优化"},{"content":"背景 # 我们有时会遇到这种需求：在程序启动时立即需要知道某些数据。\n一个例子是，我们在解耦时会定义一些协议，用于模块间沟通，这些协议与实现类的关联关系就是这样一种数据，如果通过本地文件读写可能来不及，因为这个协议的反射调用可能非常早。如果不及时获取映射数据，会导致调用失败。\n原理 # 之前在 app 启动过程 一文中提过，main 函数之前系统会让 dyld 去加载 app 依赖的各种动态库， 这里系统提供了一个回调方法，可以让我们获知这些库被加载进内存的时机。\n在 \u0026lt;mach-o/dyld.h\u0026gt; 中\n/* * The following functions allow you to install callbacks which will be called * by dyld whenever an image is loaded or unloaded. During a call to _dyld_register_func_for_add_image() * the callback func is called for every existing image. Later, it is called as each new image * is loaded and bound (but initializers not yet run). The callback registered with * _dyld_register_func_for_remove_image() is called after any terminators in an image are run * and before the image is un-memory-mapped. */ extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); 在这个回调方法中，我们可以拿到 mach_header 的指针，就可以读写 section 中的数据，具体实现在下一节介绍。\n解决了读的时机问题，那么我们怎么写数据呢？\n我们知道静态变量是存储在 Mach-O 的静态存储区，比如定义一个 NSString：\nstatic NSString * const s_myStr = @\u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;; 通过 MachOView 可以发现，具体是存储在 section 段的 __TEXT,__cstring 区块中。\n存储数据 # 所以，我们有没有办法在 section 中存储自定义的数据呢？有！\n__attribute((used, section(\u0026#34;__DATA,_my_pre_data\u0026#34;))) static const char *quote = \u0026#34;Practice makes perfect.\u0026#34;; 声明这样一个静态变量之后，会发现 __DATA 中多了一个区块，但是定义的字符串并不在这里。这里只存储了字符串的地址，数据仍然存储在 __TEXT,__cstring 区块中。\n实现 # 有了上述的背景知识，我们就可以读写自己的数据了。\n假如我们有这样一个数据结构：\ntypedef struct { char *key; char *val; int idx; } my_data_t; 那么，写入 section 段就是：\n__attribute((used, section(\u0026#34;__DATA,_my_pre_data\u0026#34;))) static my_data_t dt1 = { \u0026#34;kkk1\u0026#34;, \u0026#34;vvv1\u0026#34;, 1, }; 为了便于通用，我们可以定义一个宏，方便自动创建这样的静态变量：\n#define _PRELD_SECNAME \u0026#34;_my_pre_data\u0026#34; #define _STR(name) (#name) #define _PRELD_DATA(_k, _v, _i)\\ __attribute((used, section(\u0026#34;__DATA,\u0026#34; _PRELD_SECNAME))) static my_data_t _dt##_k = \\ {\\ _STR(_k),\\ _STR(_v),\\ _i,\\ };\\ 用起来非常方便：\n_PRELD_DATA(kkk, vvv, 1)\n读取数据 # 前面说过，注册 dyld 加载的回调即可读取 section 中存储的数据：\n__attribute__((constructor)) void preMainMethod() { _dyld_register_func_for_add_image(dyld_func); } __attribute__((constructor)) 使用这种描述的 C 方法就可以在 main 之前执行。\n那么 dyld_func 如何实现呢？\nstatic void dyld_func(const struct mach_header *header, intptr_t slide) { unsigned long size = 0; #if defined(__LP64__) \u0026amp;\u0026amp; __LP64__ const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)header; uintptr_t *memory = (uintptr_t *)getsectiondata(mhp64, SEG_DATA, _PRELD_SECNAME, \u0026amp;size); #else uintptr_t *memory = (uintptr_t *)getsectiondata(header, SEG_DATA, _PRELD_SECNAME, \u0026amp;size); #endif unsigned long n = size / sizeof(my_data_t); my_data_t *data = (my_data_t *)memory; for (int i = 0; i \u0026lt; n; i++) { my_data_t tmp = data[i]; std::cout \u0026lt;\u0026lt; tmp.key \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; tmp.val \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; tmp.idx \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } } 这里可能会有一个疑问，既然这个回调方法是每次加载 image 时都会调用，这个读取不是会多次执行吗？\n是的，但是只有 image 是 app 本身时才能读取到数据。因为我们写入数据的 section 是在 app 本身的 Mach-O 中的。\n副产品 # 那么能不能获取到 app 启动到底加载了哪些库呢？\n在 #include \u0026lt;dlfcn.h\u0026gt; 中，有这样一个数据结构：\n/* * Structure filled in by dladdr(). */ typedef struct dl_info { const char *dli_fname; /* Pathname of shared object */ void *dli_fbase; /* Base address of shared object */ const char *dli_sname; /* Name of nearest symbol */ void *dli_saddr; /* Address of nearest symbol */ } Dl_info; 我们可以使用 dladdr() 获取它：\nDl_info DlInfo; dladdr(header, \u0026amp;DlInfo); const char* image_name = DlInfo.dli_fname; std::cout \u0026lt;\u0026lt; image_name \u0026lt;\u0026lt; std::endl; 搞定！\n","date":"June 8 2022","permalink":"/posts/2022/store-data-in-mach-o/","section":"碎语闲言","summary":"背景 # 我们有时会遇到这种需求：在程序启动时立即需要知道某些数据。","title":"在 Mach-O 中读写数据"},{"content":"经常遇到一些编码、调试或者电脑方面的小问题，苦寻解答无果后自己找出了症结。\n这些方案只是当时场景下的一种可能解决思路，现在或者你的环境下并不一定适用。\nSo，仅供参考\n调试问题 # 替换沙盒中的文件 默认情况下 App 沙盒是不可见，可以在 Info.plist 添加\nUIFileSharingEnabled = YES (Application supports iTunes file sharing)\n即可在 Finder 中找到 App 的沙盒文件。\ncrash 符号化 使用 symbolicatecrash // 找到本地 symbolicatecrash 所在位置 find /Applications/Xcode.app -name symbolicatecrash -type f export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer // 把 symbolicatecrash copy 到 crash 文件同一目录下再执行 ./symbolicatecrash ./*.crash ./*.app.dSYM \u0026gt; symbol.log 使用 atos 找到 dSYM 符号文件\natos -o ./xx.framework.dSYM/Contents/Resources/DWARF/xx -arch arm64 -l 0x10888e8000 0x00000001xxxx 0x00000001yyyy 其中 0x10888e8000 是 xx 二进制的基址，也就是程序的入口地址。一般在 crash 日志最后。 0x00000001xxxx, 0x00000001yyyy 是堆栈中函数的地址。\nLLDB 调试技巧 输出格式化字符串 po [[NSString alloc] initWithFormat:@\u0026#34;$RYDER$ %@\u0026#34;, self.xxStr] po [[NSString alloc] initWithData:[NSJSONSerialization dataWithJSONObject:xxDic options:0 error:0] encoding:NSUTF8StringEncoding] 编码问题 # 一些常用的 Xcode 编译错误关键词 在编译机吐出大量 Xcodebuild 编译日志时方便快速定位错误。\n❌ error generated. ERROR: ERROR: Build failed. clang: error: linker command failed with exit code pod lint 命令，添加私有源 pod spec lint *.podspec --allow-warnings --no-clean --verbose --use-libraries --sources=\u0026#39;xxx/pod_specs.git,yyy/pod_specs.git\u0026#39; UIButton 点击状态 开发环境问题 # 清理资源 MBP 作为开发机，如果一直使用 Xcode 开发，会产生大量中间文件。512G 的存储很容易爆掉，下面是一些可清理的资源位置：\nCocoaPods 缓存 /Users/$USER/Library/Caches/CocoaPods/Pods/Release/ /Users/$USER/Library/Caches/CocoaPods/Pods/External/ Xcode 编译缓存 /Users/$USER/Library/Developer/Xcode/DerivedData 微信缓存 /Users/$USER/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/$UID/Message/ 企业微信缓存 /Users/$USER/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Data/$UID/Cache /Users/$USER/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Data/$UID/Emotion /Users/$USER/Library/Containers/com.tencent.WeWorkMac/Data/Documents/Profiles/$UID/Caches 邮箱缓存 /Users/$USER/Library/Group Containers/UBF8T346G9.Office/Outlook/Outlook 15 Profiles/Main Profile/Data 其他问题 # M1 的 MacBook Pro 突然 Esc 键无效了？ 打开活动监视器，找到 Siri 进程，强制关闭它！（再也不用每次重启解决了）\ngit 操作 删除本地在远程已经被删除的分支 git branch --merged \u0026gt;/tmp/merged-branches \u0026amp;\u0026amp; \\ vi /tmp/merged-branches \u0026amp;\u0026amp; xargs git branch -d \u0026lt;/tmp/merged-branches git 暂存区、工作区文件恢复 模拟器点击异常 现象：模拟器点击位置漂移 解决：是多点触控导致，按住 alt，把两个触控点合并就可以了\nTo be continued\u0026hellip;\n","date":"June 2 2022","permalink":"/posts/2022/tech-tips/","section":"碎语闲言","summary":"经常遇到一些编码、调试或者电脑方面的小问题，苦寻解答无果后自己找出了症结。","title":"日常小问题的技术偏方"},{"content":"概念 # 组合，就是在排列的基础上，去除顺序的因素。对于同一组数，只计数 1。\n$$ C_n^m = \\frac {P_n^m}{P_m} = \\frac {n!}{m!(n-m)!} = \\frac {n(n-1)(n-2)\u0026hellip;(n-m+1)}{m!} $$\n组合总数：\\( \\displaystyle\\sum_{k=0}^nC_n^k = C_n^0 + C_n^1 + \u0026hellip; + C_n^n = 2^n \\)\n性质：\n$$ \\begin{aligned} C_n^m\u0026amp;=C_n^{n-m}\\newline C_{n}^m\u0026amp;=C_{n-1}^m + C_{n-1}^{m-1} \\nonumber \\end{aligned} $$\n例题 # 无重复组合 # 77. Combinations 就是求所有 \\(C_n^k\\) 的组合\nfunc combine(_ n: Int, _ k: Int) -\u0026gt; [[Int]] { var used = [Bool](repeating: false, count: n) var ans = [[Int]]() func _p(_ index: Int, _ count: Int) { if count == 0 { ans.append(used.enumerated().filter{ $0.element }.map{ $0.offset + 1 }) return } for i in index..\u0026lt;n { used[i] = true _p(i + 1, count - 1) used[i] = false } } _p(0, k) return ans } 这里 used.enumerated().filter{ $0.element }.map{ $0.offset + 1 } 是过滤所有被标记使用的节点，并返回下标。\n一种 Swiftier 的写法。\n当然我们也可以不使用标记数组。\nfunc combine(_ n: Int, _ k: Int) -\u0026gt; [[Int]] { var ans = [[Int]]() func _p(_ index: Int, _ res: [Int]) { if res.count == k { ans.append(res) return } for i in index..\u0026lt;n { if n - i \u0026lt; k - res.count { break } var tmp = res tmp.append(i + 1) _p(i + 1, tmp) tmp.removeLast() } } _p(0, []) return ans } 一个小优化：if n - i \u0026lt; k - res.count { break }，表示即使剩余的元素全选也无法达到 \\(k\\) 个时直接返回。\n子集 # 78. Subsets 90. Subsets II 一个集合的所有子集，也称为幂集 (Power Set)，它的总数是\n$$ C_n^0 + C_n^1 + \u0026hellip; + C_n^n = 2^n $$\n在回溯的时候去掉 k 的限制即可：\nfunc subsets(_ nums: [Int]) -\u0026gt; [[Int]] { var ans = [[Int]]() let n = nums.count func _p(_ index: Int, _ res: [Int]) { ans.append(res) for i in index..\u0026lt;n { var tmp = res tmp.append(nums[i]) _p(i + 1, tmp) tmp.removeLast() } } _p(0, []) return ans } 还有一种很秀的写法：\nfunc subsets(_ nums: [Int]) -\u0026gt; [[Int]] { var ans = [[Int]]() ans.append([]) return nums.reduce(into: ans, { r, c in r = r + r.map{ $0 + [c] } }) } 有重复子集 # 对于有重复元素的问题，最简单的方法是用 Set 去重\nfunc subsetsWithDup(_ nums: [Int]) -\u0026gt; [[Int]] { var ans = Set\u0026lt;[Int]\u0026gt;() ans.insert([]) for num in nums { for item in ans { var tmp = item tmp.append(num) tmp.sort() ans.insert(tmp) } } return Array(ans) } 参考之前排列的回溯写法：\nfunc subsetsWithDup2(_ nums: [Int]) -\u0026gt; [[Int]] { guard !nums.isEmpty else { return [] } let n = nums.count var ans: [[Int]] = [[]] let a = nums.sorted() func _backTracking(_ index: Int, _ result: inout [Int]) { guard index \u0026lt; n else { return } for i in index..\u0026lt;n { if (i \u0026gt; index \u0026amp;\u0026amp; a[i] == a[i-1]) { continue } result.append(a[i]) ans.append(result) _backTracking(i + 1, \u0026amp;result) result.removeLast() } } var tmp: [Int] = [] _backTracking(0, \u0026amp;tmp) return ans } 以上。\n","date":"May 25 2022","permalink":"/leetcode/combinations/","section":"算法专栏","summary":"概念 # 组合，就是在排列的基础上，去除顺序的因素。对于同一组数，只计数 1。","title":"组合算法"},{"content":" 前面介绍了各种全排列算法，那么有这样一些问题：\n给定一个排列，求它之前或之后的第 \\(k\\) 个排列 给定一个排列，求它的序号 给定一个序号，求排列 我们知道，对于 \\(n\\) 个数，有 \\(n!\\) 种排列方式。每种算法生成的排列顺序是不一样的， 这个在前文中有一个颜色图能直观看出来。\n我们将这些排列从 \\(0\\) 到 \\((n!-1)\\) 右边比它小的数的个数。 编号，这样每个排列就有了自己的序号。1\n单纯从序号，我们比较难直接推导出排列本身，这样就需要引入中介数 的概念。\n定义 # 中介数是为了快速推导某个排列的中间数。\n以字典序为例，\n假设排列 \\(\\sigma = (\\sigma_0,\\sigma_1,\u0026hellip;\\sigma_{n-1})\\)，定义中介数为 \\(L(\\sigma) = (L_0,L_1,\u0026hellip;L_{n-1})\\)，其中 \\(L_i\\) 表示 \\(\\sigma_i\\) 右边比它的小的数的个数。\n以 \\(\\sigma = (83674521)\\) 为例，它的中介数是 \\(L = (7244221)\\)。 因为最后一位的右边没有数字，那么 \\(L_{n-1}\\) 总是 0，可以省略，所以中介数比原排列少一位。\n中介数是特殊进制设计，最低位是 1 进制 \\((L_{n-1})\\)，次低位是 2 进制，依次类推 中介数的计算： \\(L(\\sigma) = L_{n-2} * 1! + \u0026hellip; + L_0 * (n-1)! = \\displaystyle\\sum_{i=0}^{n-2}L_i * (n-1-i)! \\)\n这个十进制结果就是字典序的序号\n一个 \\(n-1\\) 位的中介数，可以表示 \\(n!\\) 个数字，正好与排列数对应 一个中介数对应一个特定的排列，同样根据一个排列也能求出其中介数 字典序的中介数也叫 Lehmer Code - 莱默编码2\n应用 # 60. Permutation Sequence\n1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number\n有了中介数的定义，我们来解决两个基本问题：\n中介数 \u0026lt;-\u0026gt; 序号 # 中介数 -\u0026gt; 序号 这个直接使用上面的公式 \\(\\displaystyle\\sum_{i=0}^{n-2}L_i * (n-1-i)! \\) 即可\noverride func code_to_index() { index = 0 var factorial = 1 for i in (0..\u0026lt;sz-1).reversed() { index += L[i] * factorial factorial *= (sz-i) } } 序号 -\u0026gt; 中介数 我们观察一下求和公式：\n\\(L(\\sigma) = L_{n-2} * 1! + \u0026hellip; + L_0 * (n-1)! = L_{n-2} + L_{n-3} * 2 + L_{n-4} * 3 * 2 + \u0026hellip; + L_0 * (n-1) * (n-2) * \u0026hellip; * 2\\)\n首先 \\(L_{n-2}\\) 是整个和除 \\(2\\) 的余数，然后 \\(L_{n-3}\\) 是除 \\(2\\) 的商，再除 \\(3\\) 的余数，依次类推。\noverride func index_to_code() { var tmp = index for i in (0..\u0026lt;sz-1).reversed() { L[i] = tmp % (sz - i) tmp /= (sz - i) } } 中介数 \u0026lt;-\u0026gt; 排列 # 排列 -\u0026gt; 中介数 这个比较简单，按照定义求解即可。\noverride func order_to_code() { for i in 0..\u0026lt;sz-1 { var cnt = 0 for j in i+1..\u0026lt;sz { if nums[j] \u0026lt; nums[i] { cnt += 1 } } L[i] = cnt } } 中介数 -\u0026gt; 排列 从 \\(L_0\\) 开始，它表示排列的第一位右边比它的小的数的个数，很明显排列第一位就是 \\(L_0 + 1\\)，但是到第二位的时候， 可能不是 \\(L_1 + 1\\)，因为如果 \\(L_0 + 1\\) 如果比它小，就应该是 \\(L_1 + 2\\)。\n这样说可能不太容易理解，还是以 \\(\\sigma = (83674521)\\) 为例，如果中介数是 \\(L = (7244221)\\)， 第一位是 \\(7 + 1 = 8\\) ，第二位是 \\(2 + 1 = 3\\)，到第三位时，由于前面出现了 \\(3\\)，比 \\(4 + 1 = 5\\) 要小， 那么计数就应该 \\(+1\\)，所以第三位是 \\(6\\)。\noverride func code_to_order() { nums = L.map({ $0 + 1 }) for i in stride(from: sz-1, to: 0, by: -1) { for j in stride(from: i - 1, to: -1, by: -1) { if (nums[j] \u0026lt;= nums[i]) { nums[i] += 1 } } } } 解决了这两个互相转换的问题，我们就可以以 中介数 为桥梁，解决 排列 与 序号 间的转换。 这也是 中介数 这个词的本来意义。\n那么，这个 Hard 问题 60. Permutation Sequence 就可以变成：\nindex_to_code() code_to_order() 不同算法的中介数 # 不同的算法中的中介数定义是不一样的，下面再说明一下另外几种常见排列算法的 中介数 定义。\n假设排列 \\(\\sigma = (\\sigma_0,\\sigma_1,\u0026hellip;\\sigma_{n-1})\\)\n为了方便做加法，我们把中介数的最低位放在 \\(L_0\\)，这样与一般表示出来的是相反的。\n以 \\((83674521)\\) 为例，递增中介数是 \\((7442221)\\)，存储在数据组中是 \\([1, 2, 2, 2, 4, 4, 7]\\)。\n递增进位法 # 定义 \\(L(\\sigma) = (L_1,L_2,..L_{n-1})\\)，其中 \\(L_i\\) 表示 \\((i+1)\\) 右边比它小的数的个数。\n由于 \\(L_0 = 0\\)，所以这一位通常被忽略。\n那么，它的范围就是 \\((0,0,..,0) \\thicksim (1,2,3,..{n-1})\\)，注意 \\(L_i\\) 是 \\(i+1\\) 进制数。\n递减进位法 # 定义 \\(L(\\sigma) = (L_0,L_1,..L_{n-2})\\)，其中 \\(L_i\\) 表示 \\((n-i)\\) 右边比它小的数的个数。\n由于 \\(L_{n-1} = 0\\)，所以这一位也是被忽略的。\n那么，它的范围就是 \\((0,0,..,0) \\thicksim ({n-1},{n-2},..1)\\)，注意 \\(L_i\\) 是 \\(n-i\\) 进制数。\n可以看出来，递增和递减进位法的中介数的位数都是 \\(n-1\\) 个。\n邻位对换法 # 定义 \\(L(\\sigma) = (L_0,L_1,..L_{n-2})\\)，其中 \\(L_i\\) 表示 \\((n-i)\\) 的 方向的反方向 上比它小的数的个数。其中 \\(L_{n-1} = 0\\)，这一位也是被忽略的。\n邻位交换法的中介数是比较难理解的。有几个重要的概念3 4：\n逆序：对于一个序列中的两个元素 \\(\\sigma_i, \\sigma_j\\)，如果 \\(i \u0026lt; j\\) 的同时，\\(\\sigma_i \u0026gt; \\sigma_j\\)，则称 \\((i, j)\\) 是一个逆序。 逆序数：一个序列中任意两个元素两两组合，它们是逆序的的个数称为逆序数。 逆序数为偶数的排列称为偶排列，反之为奇排列。 这样，初始的递增排列，逆序数为 \\(0\\)，是偶排列。\n另外一个概念是 方向，下面是几条规则：\n排列中一个数的方向由比它小的数的构成的序列的逆序数决定，逆序数为偶数时，向左；否则向右。 逆序数的奇偶性与它的中介数对应的序号的奇偶性一致。 由于中介数是最大数到最小数排列的，那么比它小的数组成排列的中介数，就是当前位后面的中介数。 完整的实现代码在 Gist 上\n展开查看 练习 # 求不同的排列算法中 83674521 之前第 2015 个排列。5\n这个问题的求解步骤是：\n原排列 -\u0026gt; 原中介数 -\u0026gt; 序号 -\u0026gt; 减去 2015 -\u0026gt; 新序号 -\u0026gt; 新中介数 -\u0026gt; 新排列\n还有一种方式是：\n原排列 -\u0026gt; 原中介数 -\u0026gt; 减去 2015 的中介数 -\u0026gt; 新中介数 -\u0026gt; 新排列\n后一种方式，需要计算 2015 在不同算法中的中介数，同时减法也是在特殊进制下求解，会比较麻烦。 所以，把中介数转成十进制的序号，直接计算会比较方便一点。\n通过计算，我们得出四种不同算法的结果：\n算法 原排列 原中介数 原序号 新序号 新中介数 新排列 字典序 83674521 72442210 37313 35298 70003000 81237456 递增进位法 83674521 7442221 38705 36690 7153300 86451273 递减进位法 83674521 1222447 37895 35880 1211450 37624518 邻位交换法 83674521 1012120 22584 20569 1001121 48673251 https://en.wikipedia.org/wiki/Permutation#Numbering_permutations\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Lehmer_code\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://blog.csdn.net/you1314520me/article/details/8943129\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.cnblogs.com/tianshuai11/archive/2012/04/28/2477157.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n全排列生成算法 - 维基百科\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"May 25 2022","permalink":"/leetcode/lehmer_code/","section":"算法专栏","summary":"前面介绍了各种全排列算法，那么有这样一些问题：","title":"中介数"},{"content":" A permutation is an act of arranging the objects or numbers in order. Combinations are the way of selecting the objects or numbers from a group of objects or collection, in such a way that the order of the objects does not matter.\n排列组合是组合/离散数学中的基础和重要的概念。\n$$ P_n^m = A_n^m = n(n-1)(n-2)\u0026hellip;(n-m+1) = \\frac {n!}{(n-m)!} $$\n当 \\(n = m\\) 时，也就是全排列：\n\\(P_n = n(n-1)(n-2)\u0026hellip;3 \\times 2 \\times 1 = n!\\)\n默认是不放回排列，如果是重复排列，那么排列数就是 \\(n^m\\)\n哈哈，跑偏了，这篇不是要演示 KaTex 的用法 （虽然确实挺有意思的 😹）\n应用 # 46. Permutations 31. Next Permutation 47. Permutations II 60. Permutation Sequence 排列算法 # 我们知道排列数是阶乘级增长，10个数的排列就达到了 \\(10! = 3628800\\)，百万级的规模。\n所以，即使我们 O(1) 生成一个排列，那生成全排列的算法复杂度也是 O(n!)，非常恐怖。\n在 wiki1 上有一个有意思的图，表示了九种算法，生成全排列的顺序。\nOrdering of all permutations of length \\({\\displaystyle n=4}\\) generated by different algorithms. The permutations are color-coded, where 1[❤️], 2[💛], 3[💚], 4[💙]\n这九种算法分别是：\n字典序 邻位对换法 Heap 算法 Ehrlich\u0026rsquo;s star-transposition algorithm Zaks\u0026rsquo; prefix reversal algorithm Sawada-Williams\u0026rsquo; algorithm Corbett\u0026rsquo;s algorithm Single-track ordering Single-track Gray code 下面是参考了一些网站2，用 Swift 实现常见的全排列生成算法。\n回溯法 # 主要思路：交换、排列、恢复\nfunc permute1(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() var ans = [[Int]]() func _p(_ a: [Int], _ l: Int, _ r: Int) { var tmp = a if l == r { ans.append(a) return } for i in l...r { tmp.swapAt(l, i) _p(tmp, l + 1, r) tmp.swapAt(i, l) } } _p(nums, 0, nums.count - 1) TOCK() return ans } 插入法 # 主要思路：对于 n 的全排列，将第 n+1 个数，插入到 (0\u0026hellip;n) 这 n+1 个位置就可以得到 n+1 的全排列。\nfunc permute2(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() let ans : [[Int]] = nums.reduce([[]], { partialResult, a in var nextResult = [[Int]]() for lastArray in partialResult { let sz = lastArray.count // 将 a 插入到 n-1 排列中的 sz 个位置 for i in (0...sz) { // ArraySlice\u0026lt;Int\u0026gt; 类型 let temp = lastArray[0..\u0026lt;i] + [a] + lastArray[i..\u0026lt;sz] nextResult.append(Array(temp)) } } return nextResult }) TOCK() return ans } reduce 是个挺有意思的方法，有两个参数，一个是初始值，一个是闭包，闭包接收两个参数，一是上一步的结果，另一个是序列中的值。\n上面的代码等价于：\nvar ans : [[Int]] = [[]] for i in 0..\u0026lt;nums.count { var nextResult = [[Int]]() for (_, item) in ans.enumerated() { let sz = item.count // 将 a 插入到 n-1 排列中的 sz 个位置 for k in (0...sz) { // ArraySlice\u0026lt;Int\u0026gt; 类型 let temp = item[0..\u0026lt;k] + [nums[i]] + item[k..\u0026lt;sz] nextResult.append(Array(temp)) } } ans = nextResult } 字典序 # 首次定义全升序为最小的序列，全降序为最大的序列。\n问题变成从最小逐一生成下一个排列，生成下一个排列(nextPermutation) 的算法有四步：\n从后向前找到第一个逆序的位置 \\(j\\), 即 \\(p_j \u0026lt; p_{j+1} \u0026gt;= p_{j+2}\\) 重新从后向前找到第一个比 \\(p_j\\) 大的数 \\(p_k\\)，由于 \\([j+1, n)\\) 是降序的 (第一步决定)， \\(k\\) 必然也是满足这个条件的最小的数，即 \\(P_k = \\min\\{P_i | P_i \u0026gt; P_j, i \u0026gt; j\\}\\) 交换 \\(j\\) 和 \\(k\\) 位置的数 将 \\([j+1, n)\\) 反转 (降序变升序，其实就是重排序) func permute3(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() let nextPermutation : ([Int]) -\u0026gt; [Int]? = { array in var result = array let sz = array.count var j = -1 // 找到第一个比后面数小的数 for i in (0..\u0026lt;sz-1).reversed() { if result[i] \u0026lt; result[i+1] { j = i; break; } } // 找不到说明已经是全逆序，即最后一个排列 if (j == -1) { return nil } var k = -1 // 找到 [j+1, sz) 中比 j 大的数中最小的一个 k // 第一个就是最小的，因为 [j+1, sz) 是递减的 for i in (j+1..\u0026lt;sz).reversed() { if result[i] \u0026gt; result[j] { k = i break } } // 交换 j - k result.swapAt(j, k) // [j+1, sz) result = Array(result[0...j] + result[j+1..\u0026lt;sz].reversed()) return result } var ans = [[Int]]() ans.append(nums.sorted()) while let next = nextPermutation(ans.last!) { ans.append(next) } TOCK() return ans } 递归法 ✨ # 主要思路是，枚举原数组所有位置，将位置上的数移到结果数组中，直到原数组清空。\nfunc permute4(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() var ans = [[Int]]() func _p(_ a: [Int], _ result: [Int]) { let sz = a.count if sz == 0 { ans.append(result) return } for i in 0..\u0026lt;sz { let rest = Array(a[0..\u0026lt;i] + a[i+1..\u0026lt;sz]) _p(rest, result + [a[i]]) } } _p(nums, []) TOCK() return ans } 邻位对换法3 # 也就是 Steinhaus–Johnson–Trotter 算法。\n首先，定义升序是正方向，而对于 \\(a[i] \u0026gt; a[j], i \u0026lt; j\\)，就是一个逆序对。\n初始化一个方向数组，默认全 0，表示向左交换，如果变成 1，就是向右交换 确认一个元素是否能交换（活动状态）：在它的方向上，它的邻位比自己小。 算法步骤就是：\n初始化方向数组，全部向左交换 找到所有处于活动状态元素中最大的一个 将它与邻位交换 将所有大于上面这个元素（非活动状态）的其他元素方向反转 跳转 2，直至找不到这样的元素 func permute5(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() var a = nums let sz = a.count var ans = [[Int]]() // -1 means left, 1 means right var directions = [Int](repeating: -1, count: sz) func _movable() -\u0026gt; Int? { var max = 1 var pos = -1 for i in 0..\u0026lt;sz { if a[i] \u0026lt; max { continue } if (directions[i] \u0026gt; 0 \u0026amp;\u0026amp; i \u0026lt; sz - 1 \u0026amp;\u0026amp; a[i] \u0026gt; a[i+1]) || (directions[i] \u0026lt; 0 \u0026amp;\u0026amp; i \u0026gt; 0 \u0026amp;\u0026amp; a[i] \u0026gt; a[i-1]) { max = a[i] pos = i } } if (pos \u0026gt;= 0) { return pos } return nil } ans.append(a) while let max_i = _movable() { let max_v = a[max_i] a.swapAt(max_i, max_i + directions[max_i]) // 注意：方向也要跟着交换 directions.swapAt(max_i, max_i + directions[max_i]) ans.append(a) for i in 0..\u0026lt;sz { if (a[i] \u0026gt; max_v) { directions[i] = -directions[i] } } } TOCK() return ans } 相比字典序来说，邻位交换在交换这一步更快，但是查找最大可移动元素和修改方向时，需要遍历。整体来说，时间差不多。\nHeap 算法4 # func _permute6(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() var ans = [[Int]]() func _heap(k: Int, a: inout [Int]) { if k == 1 { ans.append(a) return } // Generate permutations with k-th unaltered // Initially k = length(A) _heap(k: k-1, a: \u0026amp;a) // Generate permutations for k-th swapped with each k-1 initial for i in 0..\u0026lt;k-1 { // Swap choice dependent on parity of k (even or odd) if k % 2 == 0 { a.swapAt(i, k-1) } else { a.swapAt(0, k-1) } _heap(k: k-1, a: \u0026amp;a) } } var a = nums _heap(k: a.count, a: \u0026amp;a) TOCK() return ans } 递增进位法 # func permute7(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() var ans = [[Int]]() let sz = nums.count var inc = [Int](repeating: 0, count: sz) // inc[i] 表示 (i+1) 右边比它的小的数的个数，是 (i+1) 进制数 // inc[0] 总是 0 func _outInc() -\u0026gt; String { let rev : [String] = inc[1...].reversed().map({ String($0) }) return rev.joined() } // 最低位是 2 进制，递增时进位多 func _increace() -\u0026gt; Bool { var i = 1 var carry = 1 while i \u0026lt; sz { if carry == 0 { break } let sum = inc[i] + carry inc[i] = sum % (i + 1) carry = sum / (i + 1) i += 1 } // 如果还有进位，说明已经到了最大的排列 return (carry == 0) } func _next() -\u0026gt; Bool { // 根据当前中介数求排列 var p = [Int](repeating: 0, count: sz) for i in (0..\u0026lt;sz).reversed() { var count = 0 var j = sz - 1 // inc[i] + 1 的空位，放 sz - i while j \u0026gt;= 0 { if p[j] == 0 { count += 1 } if (count \u0026gt; inc[i]) { break } j -= 1 } // p[j] = i + 1 p[j] = nums[i] } ans.append(p) //print(_outInc()) // 中介数 + 1 return _increace() } while _next() { } TOCK() return ans } 递减进位法 # func permute8(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() var ans = [[Int]]() let sz = nums.count var inc = [Int](repeating: 0, count: sz) // inc[i] 表示 (n-i) 右边比它的小的数的个数，是 (n-i) 进制数 // inc[sz-1] 总是 0 func _outInc() -\u0026gt; String { let rev : [String] = inc[0..\u0026lt;sz-1].reversed().map({ String($0) }) return rev.joined() } // 最低位是 n 进制，递增时进位少 func _increace() -\u0026gt; Bool { var i = 0 var carry = 1 while i \u0026lt; sz - 1 { if carry == 0 { break } let sum = inc[i] + carry inc[i] = sum % (sz - i) carry = sum / (sz - i) i += 1 } // 如果还有进位，说明已经到了最大的排列 return (carry == 0) } func _next() -\u0026gt; Bool { // 根据当前中介数求排列 var p = [Int](repeating: 0, count: sz) for i in 0..\u0026lt;sz { var count = 0 var j = sz - 1 // inc[i] + 1 的空位，放 sz - i while j \u0026gt;= 0 { if p[j] == 0 { count += 1 } if (count \u0026gt; inc[i]) { break } j -= 1 } // p[j] = sz - i p[j] = nums[sz - i - 1] } ans.append(p) //print(_outInc()) // 中介数 + 1 return _increace() } while _next() { } TOCK() return ans } 可以看出来，递减进位制和递增进位制法非常类似。区别仅在于：\n中介数的最低位，递减法是 \\(n\\) 进制数，而递增法是 \\(2\\) 进制，这样在迭代时，递增法需要进位的次数更多。 快速排列 # QuickPerm 算法5。\nfunc permute9(_ nums: [Int]) -\u0026gt; [[Int]] { TICK() var ans = [[Int]]() var a = nums // init: [0,0,0...0] var p = [Int](repeating: 0, count: a.count) ans.append(a) var i = 1 var j : Int while i \u0026lt; a.count { if (p[i] \u0026lt; i) { // if i is odd, j = p[i]; else 0 j = i % 2 * p[i] // swap(a[i], a[j]) (a[i], a[j]) = (a[j], a[i]) ans.append(a) p[i] += 1 i = 1 } else { p[i] = 0 i += 1 } } TOCK() return ans } 开始我没太理解这个算法的逻辑，后来看到了 Heap 算法的 非递归实现。\n不能说比较相似吧，只能说一模一样。唯一的区别是这个算法改进了起始点从 i = 0 变成了 i = 1，因为 i = 0 进入循环后什么也没有变化就进入了 i = 1 的状态。但是这一点优化，在数据量巨大的情况下，是质的提升！\n另外，在它的官网上，这一实现被称为 Counting，还有另一种实现叫 Countdown，区别就在于 \\(P[]\\) 数组的初始化和修改方式，一个递增、一个递减。\n耗时统计 ⌛ # 以下是通过 TICK/TOCK 宏生成的各个算法的执行时间 （以 10 个数排列为例）\n算法 时间 回溯法 4.97 s 插入法 4.58 s 字典序 8.24 s 递归法 11.49 s 邻位对换法 28.37 s Heap 算法 2.57 s 递增进位法 16.70 s 递减对换法 19.67 s 快速排列算法 0.78 s 不愧是 快速排列 算法！\n统计宏 var g_start_time = NSDate() public func TICK() { g_start_time = NSDate() } public func TOCK(function: String = #function) { print(String(format: \u0026#34;[%@] cost: %.2lf s\u0026#34;, function, -g_start_time.timeIntervalSinceNow)) } 最佳实践 🚀 # 上面讲了非常多的算法，但是有些难以理解，我觉得对于同类算法，只需记住最容易理解的逻辑即可。\nfunc permute(_ nums: [Int]) -\u0026gt; [[Int]] { guard !nums.isEmpty else { return [] } var ans = [[Int]]() var a = nums let n = nums.count func _p(_ index: Int) { if index == n { ans.append(a) return } for i in index..\u0026lt;n { a.swapAt(index, i) _p(index + 1) a.swapAt(i, index) } } _p(0) return ans } 关于去重 # 对于有重复元素的排列6：\n47. Permutations II 最容易想到的是，不管重复元素，先求出所有排列。然后再去重。\n我们在上面的最佳实践上稍加改动：\nfunc permuteUnique(_ nums: [Int]) -\u0026gt; [[Int]] { guard !nums.isEmpty else { return [] } var ans = Set\u0026lt;[Int]\u0026gt;() var a = nums let n = nums.count func _p(_ index: Int) { if index == n { ans.insert(a) return } for i in index..\u0026lt;n { a.swapAt(index, i) _p(index + 1) a.swapAt(i, index) } } _p(0) return Array(ans) } 也还行，就是依赖 Set 的性质，有点耗时。那么怎么在求排列过程中直接忽略重复项呢？\nfunc permuteUnique2(_ nums: [Int]) -\u0026gt; [[Int]] { guard !nums.isEmpty else { return [] } var ans = [[Int]]() var a = nums let n = nums.count func _p(_ index: Int) { if index == n { ans.append(a) return } var used = Set\u0026lt;Int\u0026gt;() for i in index..\u0026lt;n { if used.contains(a[i]) { continue } used.insert(a[i]) a.swapAt(index, i) _p(index + 1) a.swapAt(index, i) } } _p(0) return ans } 对于重复的元素只选择一次！\nCheers! 🎉\nhttps://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.baeldung.com/cs/array-generate-all-permutations\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSteinhaus–Johnson–Trotter algorithm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Heap%27s_algorithm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.quickperm.org/quickperm.php\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://segmentfault.com/a/1190000040142137\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"May 21 2022","permalink":"/leetcode/permutations/","section":"算法专栏","summary":"A permutation is an act of arranging the objects or numbers in order.","title":"全排列算法"},{"content":"本来博客不想写非技术的东西，但是吧，这一个月太过魔幻，不吐不快。\n因为上海疫情原因，在家已经封控整两月 2022.3.18 - 2022.5.17 了，关于疫情，没什么要说的也不想吐嘈什么。（物资充足，感恩 🙏）\n说回面试，从 4 月底开始面试，目前半个多月，结果是，一个 offer 也没有收到。\n十几次自我介绍，人已经麻了。一方面人菜，一方面形势可能确实比想象中更加严峻。\n吐嘈几个面试小插曲，纯安慰自己吧。\n某公司终面，中间白头发的“大佬”：“你年纪也挺大了啊”。（本人 91）\n某公司一面，“你是计算机专业毕业的哈”，“说一下你对图灵机的理解”\n某公司一面完，以为 GG 了，半个月后收到 HR 电话，说：“不好意思，把你忘了，能约个时间二面吗”\n某外企，一个小时一道 Trie 树题，没有想到（当时使用了多级 dictionary）。面试结论：数据结构、变量命名、英文，都不行。（说的好，😢）\n使用 OC 裸写算法，没有 API 提示。\n某某外企，一个小时一道 B+ 树，没有做出来。（行吧，我没有 B shu）\n某交友 app，\n你们的工作时间？ 朝 9 晚 10，加班有饭补和打车。 那挺晚的。 不算晚，外面比我们晚的公司多了去了。 某些猎头，连岗位都搞不清，发过来一个几十页的 jd 文档，让自己找个岗位投递。\n某 HR，面试前天天催，面试完问进度，各种没有回复。\n某节 HR，三天两头捞出来鞭尸一波。\n写在最后 # 下面是一些面试高频问题的内心答案：\n自我介绍一下？ 简历上没有吗？不识字？\n为什么想要换工作？ 马老师说过，离职就两个原因。我觉得两者都有。\n说一下你项目中遇到的难点，你是怎么解决的。 没有遇到过什么难点，我的工作小学生都能做。\n类似循环 10万次，会不会 crash 之类的代码。 会不会 crash 我跑一下就知道，但是写这种代码的人建议开除。\n说一下内存优化。 建议低端机用户换手机。参考：OOM 问题解决方案\n你有什么要问的吗？ 没有，我的问题你解答不了。（问你对俄乌局势的看法？\n","date":"May 17 2022","permalink":"/posts/2022/about-interview/","section":"碎语闲言","summary":"本来博客不想写非技术的东西，但是吧，这一个月太过魔幻，不吐不快。","title":"最近一个月的面试总结"},{"content":"老是被问这种问题，常见的内存优化方法无非：\n减少图片等加载到内存中的资源大小 及时清理内存资源 利用磁盘缓存 避免内存泄露 但是！\n最好的做法应该是：\n建议用户换手机，跳转电商平台，还能赚一波广告费。\n","date":"May 6 2022","permalink":"/posts/2022/oom-crash/","section":"碎语闲言","summary":"老是被问这种问题，常见的内存优化方法无非：","title":"关于 OOM 类 crash 的解决方法"},{"content":"在 在 ObjC 中如何定义 Block 中总结了 OC 中 block 的语法。\n不知道 Swift 有没有类似 fuckingblocksyntax.com 的网站，反正我这篇是叫 fucking-closures-syntax 😬\n使用方法 # { (parameters) -\u0026gt; returnType in statements } 局部变量 # 语法定义 var closureName : (parameters) -\u0026gt; returnType = { (parameters) -\u0026gt; returnType in // statements } 例如：\nlet handler : (Float) -\u0026gt; Void = { (_ arg: Float) -\u0026gt; Void in print(arg) } // 这里参数类型可以省略 let handler : (Float) -\u0026gt; Void = { arg in print(arg) } // 如果闭包内只有一个表达式，return 也可以省略 var completion : ((Float) -\u0026gt; Int)? = { Int($0) * 2 } 属性 # 语法定义 var closureName : (parameters) -\u0026gt; returnType 例如：\nvar defaultHandler : () -\u0026gt; Void = { print(\u0026#34;Hello Closures.\u0026#34;) } 我们有时候需要定义一个可能为空的闭包，那么可以使用可选值。\nvar handler : ((Float) -\u0026gt; Void)? // 在使用时更安全，不需要额外判空 self.handler?(2.0) 方法参数 # func methodA(closure: () -\u0026gt; Void) { closure() } func methodB(closure: (_ a : Float) -\u0026gt; Void) { closure(3.0) } func methodC(closure: (_ a : Float) -\u0026gt; Void, arg: Int) { closure(3.0) } 函数调用 # 对于上述参数是闭包的方法，调用时，我们可以忽略一些细节。\n如闭包是函数最后一个参数，可以直接忽略实参标签 可以用 $0 $1 代替闭包的实参，避免写 arg in 对于操作类闭包，甚至可以省略到只保留操作符 self.methodA { print(2.0) } self.methodB { print($0) } self.methodC(closure: { a in print(a) }, arg: 0) typealias # typealias CompletionHandler = ((Float) -\u0026gt; Int)? ","date":"May 2 2022","permalink":"/posts/2022/fucking-closures-syntax/","section":"碎语闲言","summary":"在 在 ObjC 中如何定义 Block 中总结了 OC 中 block 的语法。","title":"在 Swift 中如何定义 Closures"},{"content":" 熟悉一门语言，可以从熟悉它的关键字入手。\n本文列举一下 Swift 区别 OC 的一些特有关键字吧。这里仅列举常用的，完整的关键词列表可以参考：Swift 语言参考/关键字和标点符号\n@autoclosure # Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.\n—— Swift 官方教程\n自动闭包，也是一种闭包。\n自动就是省略了 {}，系统自动将一个表达式转换成闭包。有个前提是这个闭包不能有参数。否则会收到编译错误：\nArgument type of @autoclosure parameter must be \u0026lsquo;()\u0026rsquo;\nprivate func _autoclosure(_ bar: @autoclosure () -\u0026gt; Bool) { if bar() { print(#function) } } 闭包是个值得讨论的话题，有机会单独写一篇文章。\n@escaping # 逃溢闭包，是指闭包的生命周期被延长。正常情况下在闭包作为函数参数时，函数执行完，闭包就被释放了。\n但是，如果闭包被缓存或延迟执行，生命周期被延长到函数执行之后。就需要显示指明 @escaping，否则会编译报错。\n因为 Swift 3 以后，闭包默认都是 nonescape 的。\nEscaping closure captures non-escaping parameter \u0026lsquo;bar\u0026rsquo;\nprivate func _escapingclosure(_ arg1: Int, _ arg2: Int, _ bar: @escaping (_ a: Int, _ b: Int) -\u0026gt; Int) { let concurrentQueue = DispatchQueue(label: \u0026#34;com.ryder.concurrent.queue1\u0026#34;, attributes: .concurrent) concurrentQueue.asyncAfter(wallDeadline: .now() + 1.5) { print(bar(arg1, arg2)) } } @convention # 也是用于修饰闭包的\n@convention(c) 修饰的闭包会返回 C 类型的函数指针，用于传给参数是函数指针的 C 方法。\n@convention(block) 修复的闭包会返回 block，用于传给参数是 block 的 OC 方法。\ndefer # defer 后面接一个闭包，表示推迟这个闭包执行到 defer 语句的作用域之后。\nprivate func _defer() { var num = 1 defer { print(\u0026#34;Defer: \\(num)\u0026#34;) } num += 1 print(\u0026#34;Number: \\(num)\u0026#34;) } // Number: 2 // Defer: 2 defer 内的闭包不会持有外部值。\nMore: 喵总遇到的 defer 死锁问题\ndeinit # deinit { print(String(format: \u0026#34;%@ dealloced.\u0026#34;, String(describing: self))) } 析构方法。\nextension # 扩展，类似于 OC 的 category。\n扩展的作用主要有：\n添加计算实例属性和计算类型属性 定义实例方法和类型方法 提供新初始化器 定义下标 定义和使用新内嵌类型 使现有的类型遵循某协议 类型方法的定义，所有类型都可以有类型方法，不限于 class/struct/enum。都可以使用 static func， 而在 class 中还可以使用 class func。\n注意：扩展不能直接定义存储类属性，也就是不能有属性的实例。也没有 OC 的关联对象可以使用 （当然我们可以桥接一个 OC 实现）。\n那么怎么办呢？有个取巧的办法是定义一个类变量。\nextension MyOCFunction { private static var _temp = 0 var fact: Int { get { return MyOCFunction._temp } set { MyOCFunction._temp = newValue } } } fallthrough # 贯穿。Swift 中的 case 默认是非贯穿的，也就是 case 执行完之后自动退出，所以也就不需要 break 了。\n但是，如果你希望像其他语言一样，多个 case 执行一段逻辑，则可以在 case 后使用 fallthrough\nfileprivate # Swift 共有五种访问控制关键字，从高到低：\nopen, 可以被本模块和外部模块任意访问 public, 与 open 唯一的区别是不能被外部模块继承和重写 (can\u0026rsquo;t subclass or override outside the module) internal, 默认 的级别，本模块内任意访问，不能被外部访问 fileprivate, 当前文件可见 private, 实体作用域可见，对于属性来说，仅当前类和它的 externsion 可见 这几个关键字可以用于修饰实体，如属性、基本类型、函数等。\nfinal # final 修饰类，表示这个类不对被继承 （不能修饰 struct/enum，因为它们本来就不会被继承） final 修饰类中的属性、方法，表示不能被子类重写 显然，final 和 open 关键字是互斥的 guard # guard 守卫，用于校验某个条件，并退出当前作用域。\n在 guard..else 块中必须使用 return/throw 显式退出。\nlet temp = 0 guard temp != 0 else { print(\u0026#34;zero checked.\u0026#34;) return } inout # inout 用于在函数内修改值类型数据。在调用时，需要在参数前加 \u0026amp;\nvar num = 1 self._inout(num: \u0026amp;num) private func _inout(num: inout Int) { num *= 2 } inout 的工作方式是这样的（copy-in-copy-out）：\n函数调用时，参数的值被拷贝。 函数体内部，拷贝后的值被修改。 函数返回后，拷贝后的值被赋值给原参数。 let/var # let - constant 修饰常量，仅可赋值一次 var - variable 修饰变量，可以被改变\n不管是常量还是变量，定义都遵循标识符的 定义标准，我们可以使用各种 Unicode 字符包括 emoji 来定义名称。\nprivate func _var() { var 🐶🐮 = \u0026#34;dogcow\u0026#34;; 🐶🐮 = \u0026#34;cowdog\u0026#34; print(🐶🐮) let 💩 = \u0026#34;shit\u0026#34; print(💩) } lazy # lazy 用在属性中，表示这个属性只有在被访问到才会执行初始化。也就是所谓的“懒加载”，避免的无效的内存占用。\n另一种用法，在序列，如 Array 的计算时，可以使用 lazy 只计算关心的值，如：\n// 只输出两次 `Calculating..` private func _lazy () { let array = Array(0..\u0026lt;100) let incArray = array.lazy.map{(item) -\u0026gt; Int in print(\u0026#34;Calculating..\u0026#34;) return item + 1 } print(incArray[0], incArray[8]) } 如果没有 lazy，那么 map 会被调用 100 次。\nref: https://swift.gg/2016/03/25/being-lazy/\nmutating # 对于 struct/enum 值类型对象来说，使用 mutating 修饰的方法才能修改它们的属性。\nstruct Meeting { var name : String var date : Date? init() { self.name = \u0026#34;\u0026#34; self.date = Date() } mutating func cancel() { self.date = nil } } Optional # 可选类型。\n这是 Swift 区别 OC 的一个主要特征。\nprefix/infix/postfix # 用于修饰自定义操作符的，prefix 表示操作符在变量前，同理 infix 和 postfix 分别是中缀表达式和后缀表达式。\n自定义操作符方法，必须是 static 的。\nextension Vector2D { static prefix func +++ (vector: inout Vector2D) -\u0026gt; Vector2D { vector += vector return vector } } struct/class # 结构体与类的区别，在 之前 已经介绍过，不再赘述。\ntuple # 元组，通过圆括号和分号，将不同的类型组成在一起，形成一个新的类型。tuple 甚至可以嵌套包含别的 tuple。\nA tuple type is a comma-separated list of zero or more types, enclosed in parentheses.\n通常用于函数返回值。\n一个有趣的事实：\nVoid 是 () 的 typealias，其实就是一个空的 tuple\ntypealias # Swift 中替代 typedef 的关键字。\n","date":"April 26 2022","permalink":"/posts/2022/keywords-in-swift/","section":"碎语闲言","summary":"熟悉一门语言，可以从熟悉它的关键字入手。","title":"Swift 中的关键字"},{"content":" 我是万万没想到，现在客户端面试卷到要问 ⌜图灵机⌟ 了。\n—— 某公司一面后有感\n大清废除八股已经 120 年了，但我们选拔制度并没有明显的改变。不管是面试还是晋升，无不充斥着八股套路。\n“破题“结束，闲话少说。\n三大架构中公共的 View 和 Model 很好理解：\nView，也就是 UI，是用户看到的界面，是 Model 的外在表现\nModel，Data Logic，是数据的集合\nMVC # Controller 是什么？类似一个中枢的概念，控制着数据如何被展示出来。 类型 1 # MVC 架构有很多设计。最早的版本是这样的：\n用户通过操作 View 来完成系统更新，整个控制流是单向的。\n当然还有一种，用户只通过 Controller 来操作，这在 Wikipedia 中可以看到。\n类型 2 # 如果 View 和 Controller 都接收用户指令的话，就会变化成这样：\nController 可以直接接收用户指令，如通过 scheme/url 进入某个页面，而不是通过直接操作 View。这时，Controller 响应的方法， 可能是 Update/Manipulate(操纵) Model，也可能是更新 View。\n用户直接操作 View，这里 View 如果想要变更 Model，只能通过 Controller 中转。\n有时，Model 的变更会直接通知 View （通过观察者的方式）。\n这个实现，也就是阮一峰在博客1中提到的 Backbone.js 的架构方式。\n类型 3 # 在 iOS 开发中，MVC 被苹果演变成了如下方式：\n解除了 Model -\u0026gt; View 之间的耦合。\nMVP # 在上述类型 3 的 MVC 模型中，将 Controller 替换成 Presenter，就是 MVP 模型。\n也就是说，Presenter 作为 View/Model 的中枢，承载了所有显示相关的逻辑2。 在 MVP 架构下原先的 UIViewController 其实变成了 View 的一部分。\nMVVM3 # 区别与 MVP 的显著特征就是 View \u0026lt;-\u0026gt; Model 之间使用了数据绑定 (Data-binding) 技术。使两者在松耦合的同时，也能及时感知对方的变化。 Data Binding 在前端框架中比较常见，比如 Vue 中：https://v1.vuejs.org/guide/syntax.html\n\u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; 在 iOS 中，要实现双向绑定，可以使用 RAC 框架 ReactiveCocoa\nSwftUI 中的 @Binding 也可以实现类似的功能。（或许不是？这里待学习）\nhttps://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"April 25 2022","permalink":"/posts/2022/mvc-mvp-mvvm.md/","section":"碎语闲言","summary":"我是万万没想到，现在客户端面试卷到要问 ⌜图灵机⌟ 了。","title":"面试八股之 MVC/MVP/MVVM"},{"content":" 很多年前，我在本科时，学习数据结构用的教科书上面这本 《数据结构教程》（蔡子经、施伯乐 编著）。 在家翻了下，发现已经找不到了。不知道什么时候遗失了，因为我一般不会丢弃书籍，尤其是专业书。\n写这篇的目的是帮自己回忆一下，有些数据结构和算法的内容都已经被忘记了。 比如 Trie 树、B 树等结构，Floyd 算法本质是个 DP，还有 KMP 算法，常看常忘。\n数据结构这门课的教科书五花八门，尤其以严蔚敏的那版最为出名。目前看网上好评最高的是清华大学的邓俊辉教授的 《数据结构（C++ 语言版）》。本文参考：\nhttps://cloud.tsinghua.edu.cn/d/76cbab99574046698804/files/?p=%2Fdsacpp-3rd-edn.pdf\n虽然有电子版，等疫情结束还是会买本实体书支持下老师。\n2022/05/27 买到了！JD 下单后 4 天收到，说明上海的疫情快结束了。加油吧！\n这本书有自己的官网：https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/index.htm\nI. 数据结构 # 队列、链表、栈这些基础的结构按下不提，主要看看有哪些平时用得很少容易忽略的类型。\n优先队列 # 二叉树的遍历 # Huffman 编码 # 邻接矩阵 # 邻接表 # II. 算法 # 散列 hash # 字符串 # BMP # BM # Karp-Rabin 算法 # 二叉树/平衡树 # 二叉搜索树，又叫二叉查找树 (Binary Search Tree)，简称 BST。\n平衡二叉树，也就是平衡树 (self-Balancing Binary Bearch Tree)，简称 BBST。\n平衡树有非常多的 种类\n常见的有：\nAVL 树 # 伸展树 # B 树 # 红黑树 # k-d 树 # 图论 # BFS # DFS # 最短路 # ","date":"April 22 2022","permalink":"/leetcode/base/algo-in-data-structure/","section":"算法专栏","summary":"很多年前，我在本科时，学习数据结构用的教科书上面这本 《数据结构教程》（蔡子经、施伯乐 编著）。 在家翻了下，发现已经找不到了。不知道什么时候遗失了，因为我一般不会丢弃书籍，尤其是专业书。","title":"重拾数据结构中的算法"},{"content":" 参考：swift.bootcss.com 基本语法 # 分号 # 分号在 Swift 中不是必须的，当然在一行中多个语句间还是需要的。 越看越觉得像 Python :)\n空格 # Swift 对于空格有着一定的约束，相对 OC 来说更严格，但又没有 Python 那么精确 （不需要游标卡尺 🤡） // \u0026#39;=\u0026#39; must have consistent whitespace on both sides var a= 1 + 2 // \u0026#39;+\u0026#39; is not a postfix unary operator var a = 1+ 2 // Consecutive statements on a line must be separated by \u0026#39;;\u0026#39; var a = 1 +2 // ok var a = 1 + 2 // ok, not recommand var a = 1+2 switch # Swift 中的 switch 支持任意类型，而 OC 只支持整型及能转换成整型的类型。\n在 Swift 中 break 并不是必须的。某个 case 匹配成功后，会在执行完代码后自动跳出；而 OC 以及 C/C++ 会继续匹配， —— 这种方式叫做 贯穿。在 Swift 中可以使用 fallthrough 关键词以支持这种特性。\nSwift 中的 switch 支持 where 语句以添加额外的条件。\n函数嵌套 # Swift 支持在函数内部定义函数。 func testVariable () { var a : String? = \u0026#34;1\u0026#34; func _inerfunc() { print(\u0026#34;hello\u0026#34;, a ?? \u0026#34;2\u0026#34;) } _inerfunc() } 继承 # Swift 继承自父类的方法，重写时，需要加 override 关键字。OC 不需要。 区间运算符 # 在 Swift 中 [a, b] 的区间可以用 a...b\n[a, b) 可以表示成 a..\u0026lt;b\n还有 [a...] 和 [..\u0026lt;b] 等\n类型 # Swift 是一个类型安全 (type safe) 的语言。\ntypealias 类型别名 # 这个在 OC 中可以使用 typedef 实现。 隐式转换 # Swift 有严格类型定义，不能隐式转换。 比如 if 语句中的条件，在 OC 中可以使用整数，但在 Swift 中只能是 Bool 型。\nlet a = 1 // Type \u0026#39;Int\u0026#39; cannot be used as a boolean; test for \u0026#39;!= 0\u0026#39; instead if (a) { } Optional 可选值 # 这是 OC 没有的特性，避免了很多判空的逻辑代码。在链式调用时，也更方便。 闭包与 block # Swift 中的闭包与 OC 中的 block 类似，都是将一段代码封装起来，用于参数、返回值等，也都可以捕获外部变量。\n但也有不同之处：\n本质不同，闭包本质是个函数，但 block 是一个结构体。\n闭包写起来更简洁、更灵活。有多种类型：自动闭包、尾随闭包、逃逸闭包 \u0026amp; 非逃逸闭包等。\nenum 枚举 # Swift 中的 enum 可以包含方法，而 OC 不行 Tuple 元组 # 这是 OC 没有的类型，用于返回一组数据，如 (404, \u0026ldquo;Not Found\u0026rdquo;) nil # Swift 中的 nil 表示可选值类型的值为空，不能用于确定的类型。而 OC 中，它是一个空指针的概念，只能对于对象。\n可选值可以是整型，如 var a : Int? = nil\n?? 空合 # 是对一个可选类型解析，类型于 OC 中的 a ?: b // if a == nil, return b a ?? b // is equal to a == nil ? a! : b 高级特性 # 函数 # Swift 中的函数，可以不指明返回值，默认返回的是 () —— 空元组。而不是 Void\nSwift 可以给函数参数设置标签（别名），_ 表示不需要标签。\n单行表达式的函数，可以直接省略 return；常用于 get 方法。\n默认函数参数是不能修改的，需要使用 inout 标明需要修改的参数。\n结构体与类 # struct 在 OC 中并不是一等公民，但在 Swift 中，是与 class 同等地位的对象封装。\nSwift 中的 struct 与 class 比较：\nstruct 是值类型，而 class 是引用类型 (值类型存储变量本身，引用类型存储内存地址) struct 不支持继承，而 class 可以 struct 会给成员变量默认值，而 class 必须自行初始化 struct 不需要引用计数，所以没有 deinit 方法 使用 let声明的实例，class 可以修改它的属性，而 struct 不行 (需要借助 mutating 方法) struct 不支持类型转换 (typecasting) ref: Choosing Between Structures and Classes\n值类型与引用类型 # 值类型 被赋值给另一个变量时，会进行 copy 操作，以确保新变量的修改不会影响原来的变量值。 而 引用类型 的赋值是一次指针赋值，新旧变量指向同一块内存。\nString, Array, Dictionary 都是 struct\nSwift 中 enum, struct 是值类型，class 是引用类型。\nOC 中仅有基本数据类型、基础 struct 是值类型。\n属性包装器 # Swift 中的新特性，关键词 @propertyWrapper 用于将某个属性的实际值隐藏起来，对外暴露封装过的值。\n类方法 # static 和 class 在 func 前都表示类型方法，后者表示可被子类继承\nSwift 中可以为类、结构体和枚举定义类型方法\nextension 扩展 # Swift 中的扩展与 OC 中的 category 类似，也有一些不同\n扩展是没有名字的 扩展可以添加属性 扩展不能重写已有方法，但分类可以（覆盖） 扩展中的功能，可被扩展定义之前的实例使用；但分类方法必须被 import 后才可见 protocol 协议 # Swift 中的协议支持指定属性 Swift 中的协议可以指定初始化方法，实现时需要使用 required 关键字 Swift 中的协议可以组合，使用 ProtocolA \u0026amp; ProtocolB 变成一个新的协议类型 Swift 中的协议，可以提供默认实现 泛型 # 类似 C++ 中的模板语法特性，OC 中没有。 actor 类型 # Swift 中新增的类型 To be continued\u0026hellip;\n","date":"April 10 2022","permalink":"/posts/2022/swift-vs-oc/","section":"碎语闲言","summary":"参考：swift.","title":"Swift 与 OC 有哪些不同"},{"content":"最近大搞减包运动，今天从同事那了解到一个神奇的减包策略：\n把 @protocol 换成 NSProtocolFromString ! 这是为啥呢？\n做个实验 # 添加一个 @protocol 调用：\n可以看到生成的 lib 中 __DATA,__objc_const 段中少了多个 protocol 相关的符号。\n改成 NSProtocolFromString，也不会生成符号：\n为啥呢 # 我们反编译一下 文件：\nclang -rewrite-objc BGStaticLib.m 在反编译后的 BGStaticLib.cpp 中可以看出：\n新增的几个符号，被指定放到了 __DATA 段，正是用 MachOView 看到新增的那几个符号：\n_OBJC_PROTOCOL_INSTANCE_METHODS_NSObject __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) _OBJC_PROTOCOL_OPT_INSTANCE_METHODS_NSObject __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) _OBJC_PROTOCOL_PROPERTIES_NSObject __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) _OBJC_PROTOCOL_REFS_BGProtocol __attribute__ ((used, section (\u0026#34;__DATA,__objc_const\u0026#34;))) 能减多少 # 比较了下修改前后的 lib 文件，size xx.a\n// 修改前 __TEXT\t__DATA\t__OBJC\tothers\tdec\thex 703\t1256\t0\t6519\t8478\t211e\txx/libBGStaticLib.a(BGStaticLib.o) // 修改后 __TEXT\t__DATA\t__OBJC\tothers\tdec\thex 204\t320\t0\t6531\t7055\t1b8f\txx/libBGStaticLib.a(BGStaticLib.o) __TEXT 和 __DATA 段共减少了 499 + 936 = 1435，共 1.4 KB。\n通过 stat xx.a 命令获取整个 lib 字节数发现：\n共减少了 15504 - 11168 = 4336，共 4.3 KB。\n积小成多 # 看起来单个文件并不多，但实际上在巨型 app 中，使用 protocol 作为 bridge 跨工程调用其他模块的方法非常多。\n这次减包过程中，某模块经过这样改写之后，减少了 10M 的包体积。🤩\n","date":"April 8 2022","permalink":"/posts/2022/reduce-pkg-size-1/","section":"碎语闲言","summary":"最近大搞减包运动，今天从同事那了解到一个神奇的减包策略：","title":"一个神奇的减包方法"},{"content":" 查了下订单，这本书买了 4 年多，还没看完！\n所谓 flag，永远也完不成 😢\n毕其功于一役，这次快速啃完这本书，吸收一些最佳实践。\n这本书完整的书名是 《Effective Objective-C 2.0：编写高质量 iOS 与 OS X 代码的 52 个有效方法》，第一版写作于 2014 年，2017 年重印，距今已经比较长的时间了，那么，\n这 52 条规则是不是都还适用呢？\n带着这个疑问，快速过一遍！\n基础概念 # 1. 起源 # OC 是 C 的超集，是 C + Object。\nOC 的消息发送机制与其他语言的函数调用的区别是：\n前者由运行时决定，后者由编译器决定。\n2. 减少头文件引用 # 这个应该所有语言 (严谨点，大部分) 都通用吧，减少模块间耦合，避免过多引用。\n3. 字面量语法糖与下标操作 # NSString, NSArray, NSNumber, NSDictionary 使用 @\u0026quot;\u0026quot;, @[], @(), @{} 语法创建。\n需要注意的是如果有空对象，字面量会抛异常而 crash，但是 arrayWithObjects: 会截断列表，只取 nil 前的元素。\n而对于 NSArry 和 NSDictionary 来说，下标操作比 objectAtIndex: 和 objectForKey: 要方便一点， 但是越界一样会抛异常。\n4. 用 const 常量代替 #define # // xx.m --\u0026gt; 尽量不要定义在 .h 中，如果是给别人使用，需要 extern static const NSTimeInterval kAnimationDuration = 0.3 // xx.h extern NSString *const XXStringConst; // xx.m NSString *const XXStringConst = @\u0026#34;VALUE\u0026#34; const 常量带有类型信息，会被编译器检查；#define 是单纯的字符串替换，没有任何校验。 extern const 常量只能被定义一次 (可多次声明)，而 #define 没有限制，容易产生覆盖问题。 tip: static const 定义在 .m 文件中，不会出现在全局符号表中。 5. 使用枚举 # typedef NS_ENUM(NSInteger, XXState) { XXState1, XXState2, XXState3, }; typedef NS_OPTIONS(NSInteger, XXOPT) { XXOPT1 = 1 \u0026lt;\u0026lt; 0, XXOPT2 = 1 \u0026lt;\u0026lt; 1, XXOPT3 = 1 \u0026lt;\u0026lt; 2, }; switch 中的枚举，不要实现 default 分支，避免新加入枚举值时漏掉分支实现。\n对象、消息与运行时 # 6. 属性 # atomic 是原子性的，但并不是线程安全的。\n如果在一个线程多次读取某个属性的时候，有另一个线程在写，即使声明为 atomic，也会读取到不同的值。\niOS 中使用同步锁开销较大，一般不使用 atomic\n7. 在对象中尽量直接访问实例变量 # 在读取时，使用 _val 而不是 self.val\n在设置时，使用 self.val = xx\n不要在 init 和 dealloc 中使用 self.val！\n如果子类重写了某个属性的 set 方法，\n在 init 中，父类如果调用 set，其实是调用的子类实现，可能会出现不想要的结果 在 dealloc 中，子类先释放了实例，父类再去调用 set 方法，会导致 crash 8. 对象相等性 # ==： 是地址比较 isEqual:： 默认也是比较指针，可以被重写。对于 NSString，等效于 isEqualToString: hash：如果对象相等，则 hash 必须相等；反之，不一定成立 9. 类族 # class cluster，看起来类似于工厂模式。\n系统库的集合类，如 NSArray、NSDictionary 都是类族的抽象基类。\n10. 关联对象 # 非必要不要用。\n11. 消息发送 # objc_msgSend 是一个重要的概念。\nobjc_msgSend 在调用方法时，甚至使用了 \u0026ldquo;尾递归\u0026rdquo; 优化。\n12. 消息转发 # message forwarding 也是一个重要的概念。三步走：\n+ (BOOL)resolveInstanceMethod:(SEL)sel，可用于动态添加实现\n- (id)forwardingTargetForSelector:(SEL)aSelector，转发给其他对象\n- (void)forwardInvocation:(NSInvocation *)anInvocation，完整的消息转发\n第三步，需要配合\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n使用。\n13. 黑魔法 # Method Swizzling 也是一个重要的概念。\n不要滥用，难以调试\n14. 类对象 # 参考：[Runtime] Class, Object 与 isa\n接口与 api # 15. 使用前缀命名 # 由于没有名字空间 (namespace) 机制，只能通过加前缀的方式避免符号冲突。\n特别注意，要在分类方法名前加前缀\n16. 使用指定初始化方法 # 指定初始化方法 (designated initializer, NS_DESIGNATED_INITIALIZER) 必须调用父类的指定初始化方法 本类的其他初始化方法 (便捷初始化方法，convenience initializer) 必须调用本类指定初始化方法，不能调用父类的 如果子类有指定初始化方法，则必须实现所有父类的指定初始化方法 17. 实现 description 方法 # 或者 debugDescription 方法，用于调试输出日志。\n18. 尽量使用不可变对象 # immutable 也是个重要的概念。\n对外的容器属性尽量只读，并提供读写接口。\n19. 命名 # 前缀 + 驼峰式，尽可能一眼看懂作用的命名。\n20. 私有方法加前缀 ️❓ # 作者建议私有方法使用 p_ 作为前缀，这点个人觉得存疑。\n实际开发中，没有必要区分 public 和 private 方法。不在头文件中的方法即为 private， 显然使用者有很多办法可以绕过这个限制。但这不重要。\n这里作者提了一点很重要，不要使用 _ 单下划线作为前缀，因为系统库也这样命名，容易无意中重载。\n21. 处理异常 # 少用异常，除非必须 crash 的场景。一般错误使用 NSError 替代。\n这里我要说一句，有些人喜欢 NSAssert 滥用，真是非常影响调试！😒\n22. 理解 NSCopying # immutable 与 mutable 与 深浅拷贝 的概念不要混淆。\ncopy -\u0026gt; immutable mutableCopy -\u0026gt; mutable [NSArray copy] -\u0026gt; 浅拷贝，即与原数组指针相同 [NSArray mutableCopy], [NSMutableArray copy], [NSMutableArray mutableCopy] 都是深拷贝，会生成新的地址。 对于集合类成员来说，默认都没有执行 copy 操作。\n可以使用 -initWithXX:copyItems:YES 方法执行逐个 copy。\n协议与分类 # 23. 委托 delegate # Cocoa 框架大量使用，约定俗成的设计模式。\n24. 分类 # 将一个大类，按功能拆成多个分类，是一种代码优化的方法。\n25. 分类名和方法 # 在为系统或第三方类添加分类时，要加上自己特有的名字前缀。\n与 #15 类似。\n26. 分类中不要定义属性 # 一般也定义不了。除非使用关联对象。\n27. 匿名类 # class-continuation\n可以用来\n隐藏私有变量 隐藏私有方法 隐藏私有协议 28. 用协议提供匿名对象 # 指 id\u0026lt;XXProtocol\u0026gt; delegate 这种形式\n内存管理 # 内存管理对于 OC 来说很重要。 29. 引用计数 # 对象间引用构成一颗树，根结点是 NSApplication/UIApplication。\nautorelease 可以延长变量的生命期，通常用于方法返回。(MRC)\n30. 使用 ARC # ARC 很好用。但需要注意：\n必要的时候需要借用 autoreleasePool 管理 CoreFoundation 对象不归 ARC 管，需要自行调用 CFRelease 31. dealloc 方法 # MRC 中 dealloc 最后需要手动调用 [super dealloc]，ARC 中不再需要\n不要在 dealloc 中调用异步操作 不要在 dealloc 中调用属性的读写操作 在对象处于 deallocating state 时，不要做修改对象内容的事情。\n32. 异常与内存管理 # try 块中创建的对象需要在 @finally 中释放。ARC 下需要开启 -fobjc-arc-exceptions 编译标志才可以正确释放。\n33. 弱引用 # weak 也是一个重要的概念。\n与 unsafe_unretained 区别在于，weak 会进行 autonilling。\n34. @autoreleasepool 的使用 # autorelasePool 也是一个重要的概念。\n降低内存峰值 (high-memeory waterline)\n35. 僵尸对象 # Zombie Object\nXcode 中有一个开关可以打开 Enable Zombie Objects = YES。\n这样系统会替换 NSObject 的 dealloc 实现。在原类的 dealloc 中，通过 objc_setClass，生成一个 _NSZombie_XXCls 类替换原类， 在后续再向原类发送消息时，就会被转发到僵尸类中，然后输出已经被释放的类名和错误信息。\n*** -[XXCls method]: message send to deallocated instance 0x7xxxx 36. 不要使用 retainCount # ARC 下可用，MRC 下不准确。所以是无用的 存在自动释放池，延迟释放，所以这个值也不准 系统优化释放行为，可能对象引用计数不会为 0 block 与 GCD # 中文版译为 “块与大中枢派发”，无力吐嘈。\n这两者都非常重要。 37. 理解块 block # block 也是对象，有自己的引用计数和生命周期管理 block 是一种代替函数指针的语法结构，核心功能在 void (*)(void *,) invoke 函数指针 捕获的变量在 block 体内，invoke 将 block 本身传入以便于读取到捕获的变量 有栈 block、堆 block 和 全局 block，可以通过它的 Isa 指针区别 38. 使用 typedef 重命名 block # 常用的做法\n39. 使用 handler 块降低代码分散程度 # 就是将 block 作为参数传入，而不是使用 delegate 这个完全取决于实际情况，如果回调过多，还是 delegate 更好一点。\nAPI 设计常用同一个 block 返回结果和错误\nNSNotificationCenter 的设计值得学习，应该由调用者决定回调的线程\n40. block 与 循环引用 # retain cycle 是个使用 block 时常见的问题\n某个类 retain 的 block 内部如果捕获了类本身，就会出现循环引用。此时需要及时释放 block。\n41. 用队列代替锁 # 使用串行队列代替 @synchronized(self) 串行队列，读同步 dispatch_sync；写异步 dispatch_async，执行速度快，但性能会比同步慢，因为需要 copy block 并发队列，读同步，写异步，此时避免竞争需要用 dispatch_barrier_async，栅栏 到底什么是线程安全，很难有个准确的定义。锁机制能保证一定程度的 thread safety，但不绝对。\n两次读之间，有写操作。这两次读的结果就可能不一样。这样算不算线程不安全？\n42. 用 GCD 替代 performSelector # performSelector 无法让编译器决定是否释放返回对象，容易内存泄露 使用 dispatch_after 代码 performSelector:withObject:afterDelay: 43. GCD 与 NSOperationQueue # NSOperationQueue 底层也是 GCD 实现的。但是相对来说，有一些优点：\n更方便取消 可以指定依赖关系 可以用 KVO 了解运行状态 指定操作的优先级 代码可复用 44. dispatch_group # 掌握几个方法的使用\ndispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); // 成对出现 dispatch_group_enter(dispatch_group_t group); dispatch_group_leave(dispatch_group_t group); // 阻塞等结束或超时 dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); // 不阻塞等结束 dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); // 循环执行多次 dispatch_apply(size_t interations, dispatch_queue_t queue, void (^block)(size_t)); 45. dispatch_once # dispatch_one 性能是 @synchronized 的两倍以上\n46. 不要使用 dispatch_get_current_queue # API_DEPRECATED(\u0026#34;unsupported interface\u0026#34;, macos(10.6,10.9), ios(4.0,6.0)) DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NOTHROW dispatch_queue_t dispatch_get_current_queue(void); 这个 API 已经被弃用，不过理解其不可用的原因还是有用的。\n返回值通常与预期不符，队列按层级组织，无法用单个队列描述当前队列。如在全局队列中 async 执行某个队列，当前队列可能是全局队列 可以使用 dispatch_queue_set_specific() 方法存储队列特有数据，类似于 TLS (Thread Local Storage) 系统框架 # 47. 熟悉系统框架 # Foundation 与 CoreFoundation 存在 “无缝桥接”，如 NString \u0026lt;-\u0026gt; CFString 常用系统库 CFNetwork CoreAudio AVFoundation CoreData CoreText QuartzCore/CoreAnimation CoreGraphics 48. 使用块遍历代替 for # for\u0026hellip;in 语法 enumerateObjectsUsingBlock: 49. 使用 CoreFoundation 中的 collection 类 # 这一节感觉不是太常用。\nNSArray -\u0026gt; CFArrayRef: 使用 (__bridge CFArrayRef) 转换 反之使用 (__bridge_transfer NSMutableDictionary *)(CFMutableDictionaryRef xx) 50. 使用 NSCache # 相比于 NSDictionary 的优势在于：\n键不需要支持 copy 低内存时自动清理 线程安全 配合 NSPurgeableData 使用，实现自动清除数据 51. 精简 initialize 和 load 代码 # load 方法在启动时调用，先调用本类的，再调用分类的。先调用父类的，再调用子类的。子类不实现，父类不会调用。\nload 中使用其他类是不安全的\n尽量在 initialize 方法中做初始化操作，与 load 的区别：\n惰性调用，使用时才调用 比 load 更可靠，此时使用其他类是线程安全的 遵循继承规则，子类没有实现，会调用父类的 也尽量不要在 initialize 中添加太多代码\n52. NSTimer 会 retain 它的 Target # NSTimer 也是一个重要的对象\n有多种方法可以打破循环引用 。\n终于看完了！这是一本不错的书，但由于年代久远，一些概念和用法需要更新。 OC 这个古老的语言，如今在大厂的 屎山 项目中还在发挥着作用。\n但是作为开发者，我们要拥抱未来！\nTo Learn Swift, right now !!\n","date":"April 7 2022","permalink":"/posts/2022/effective-oc-2.0/","section":"碎语闲言","summary":"查了下订单，这本书买了 4 年多，还没看完！","title":"一文学完《Effective Objective-C 2.0》"},{"content":"Git 操作是程序员必须掌握的基本技能。刚毕业那会，大家还都使用 svn 作为版本管理工具。\n但近些年大家基本都改用 git 了，甚至在我们项目内部 UI 切图都开始使用 git 管理了。\n感谢 Linus Torvalds 的伟大发明！\n一般情况下，我们常用的命令无非是：\n$ git init $ git checkout $ git add $ git pull $ git push $ git merge 在说 rebase 前，先重点强调一下 黄金法则：\n永远不要在公共分支上使用 rebase !! rebase 作为一个进阶命令，常常与 merge 放在一起比较。\nrebase 与 merge # $ git checkout feature $ git merge main // or $ git merge feature main 将 main 分支合并到 feature：\n这样在 feature 分支上会产生一个新的 commit，这是一个 merge commit。\n而对于 rebase:\n$ git checkout feature $ git rebase main 可以看到 feature 分支所有 commit 都被放到了 main 前面，整个 history 形成了一条直线。\n值得注意的是，feature 的所有 commit 都被重建了，它们的 hash 已经不是原来的那个了！\n所以，rebase 相对于 merge 来说，优点是：\n时间线更漂亮，符号强迫症和整洁癖的喜好 为了做到这个，它对 安全性 (safety) 和 可追溯性 (traceability) 做了折衷1，如果不遵循 rebase 黄金法则，将带来灾难！\nrebase 的缺点很明显：\n不当的使用容易造成严重后果 难以追溯历史，比如上面的 feature 分支在 rebase 之后，无法知道是什么时候从 main 切出进行的修改。无法知道什么时候合入的 main 分支。 git pull # 首先，git pull 是两个动作的合并，即 git fetch + git merge FETCH_HEAD\n比如 git pull origin master，首先拉取 origin/master，再将本地分支与 origin/master 执行 merge 操作。\n如果你本地有一个 commit，但是没有提交到远程；同时你的同事在同一个分支上提交了代码。你进行 fetch 的时候会发现，本地分支既 ahead 又 behind：\n如果这个时候执行 merge 操作： Merge made by the \u0026lsquo;recursive\u0026rsquo; strategy.\n会产生一个 merge 节点！\n如果执行的是 rebase 呢？ 会将本地的 commit 重建，并放到最上面。（可以看到 commit id 不一样了）\n然后 push 之后，时间线就成了一条直线！\n所以，git pull 这个操作，大部分情况来说，使用 \u0026ndash;rebase 更合适！\n我们可以设置 git pull 默认使用 rebase 选项：\n# 仅设置 master 分支生效 git config branch.master.rebase true # 对所有 tracking 的 branch 生效 git config branch.autosetuprebase always # 对所有 pull 操作生效 git config pull.rebase true 以上仅对当前目录的 git 生效，如果要全局生效，记得加上 --global 选项。\n# 手动编辑更方便！ git config --global --edit rebase 的禁忌 # 再次复习一下 黄金法则：\n永远不要在公共分支上使用 rebase !! 如果你和同事公用了一个 feature 分支，而你使用 rebase 同步主干。很有可能弄丢同事的代码！\n我们来看下是怎么出现的：\n首先我们从 master 切出一个 feature 分支： 这个时候有两个同事同时在这个分支上开发，相安无事。\n某天，有个同事说，主干上有一些更新，我们要不要同步一下到 feature 分支： “好啊，好啊”，那么怎么同步呢？要不要试试新学的 rebase 命令 ?! 3.1. 你的同事一边说“好啊”，一边在自己本地的 feature 上提交了好几次，并 push 到了远程！\n你并不知道，这样你本地的 feature 分支并没有完全包含同事的提交，与此同时，你开始了可怕的 rebase 操作：\n这时，你发现提交不上去：\n于是，头脑一热，你决定大力出奇迹，--force 一把： 这时，你同事更新一下代码，发现！“我的代码怎么没了？？！！”\n怎么办？ # 有办法补救嘛？有！\n让你的同事使用 git reflog：\n找到丢失的 commit，通过 git cherry-pick [commit-id] 提交到 feature 分支即可！\n但是！我们还是不要随便使用 --force 来制造这种凶险事件了。\n看下面这个场景：\n前面介绍过，超前是本地分支有三个变更，落后是远程分支有四个变更没有同步过来。\n如果我们强行 push 就会丢失远程的 commit，所以我们试一下 --force-with-lease 参数：\n没有区别，还是提交上去了！\n在这种明知道本地落后，仍然强行提交的情况下，--force-with-lease 的作用与 --force 是一样的！\n正常的做法是：\ngit pull \u0026ndash;rebase 更新本地分支\n而 git push --force-with-lease 能够解决的是，在 rebase-push 过程中，有其他人提交到该分支时的，这次提交操作会被拒绝。相对来说更安全一点。\n所以，总得来说，还是黄金法则：\n永远不要在公共分支上使用 rebase !! 多人协作分支，同步主干，请使用 merge !!\nhttps://www.atlassian.com/git/tutorials/merging-vs-rebasing\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"March 19 2022","permalink":"/posts/2022/git-rebase/","section":"碎语闲言","summary":"\u003cp\u003eGit 操作是程序员必须掌握的基本技能。刚毕业那会，大家还都使用 svn 作为版本管理工具。\u003c/p\u003e\n\u003cp\u003e但近些年大家基本都改用 git 了，甚至在我们项目内部 UI 切图都开始使用 git 管理了。\u003c/p\u003e","title":"关于 Rebase 容易被坑的那些事"},{"content":" “二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 O(log n)，空间复杂度 O(1)，相比线性搜索优秀太多。\n但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本1能准确写对“二分”查找。\n尽管二分查找的基本思想相对简单，但细节可以令人难以招架 \u0026hellip; — 高德纳\n二分查找的前提是待查找的序列是有序的。\n本身算法逻辑非常简单2：\nfunction binary_search(A, n, T) is L := 0 R := n − 1 while L ≤ R do m := floor((L + R) / 2) if A[m] \u0026lt; T then L := m + 1 else if A[m] \u0026gt; T then R := m − 1 else: return m return unsuccessful 减少一次判断 # 上述伪代码每次循环都会比较 mid 与 target 是否相等，如果去掉这个比较，将之放到循环退出时，就可以在每次循环中减少一次比较，总得循环次数仅比上面的算法多一次。\nfunction binary_search_alternative(A, n, T) is L := 0 R := n − 1 while L != R do m := ceil((L + R) / 2) if A[m] \u0026gt; T then R := m − 1 else: L := m if A[L] = T then return L return unsuccessful 关于 cell 和 floor # 可以看出来，上面两个实现中在取 mid 时使用了不同的方法，一个是 floor()，一个是 ceil()，\nfloor((0 + 1) / 2) = 0\nceil((0 + 1) / 2) = 1\n为什么会有这个不同呢？在 StackOverflow 上有很好的解释：\n如果更新二元组 (l, r) -\u0026gt; (m + 1, m - 1) 时，这两种方法都可以，结果是一样的。 如果是 (l, r) -\u0026gt; (m, m - 1) 时，必须要使用 ceil，否则循环无法退出。比如 l = 0, r = 1, A = [1, 2]， target = 2 时，floor 会导致 l 一直被更新为 0，无法退出。 如果是 (l, r) -\u0026gt; (m + 1, m) 时，必须要使用 floor，否则同时循环无法退出。比如 l = 0, r = 1, A = [1, 2]，target = 1 时，ceil 会导致 r 一直被更新成 1。 总之，就是更新下边界更多时，使用 floor，更新上边界更多时，使用 ceil。\n关于溢出 # 上述算法中还有一个问题，计算 mid = floor((L + R) / 2) 存在可能的溢出错误，这在 C++ 中比较常见，比如 l = r = 2^31-1，相加就会溢出整数范围！\n正常的写法是：\nmid = l + (r - l) // 2 如果有重复元素 # 如果序列中存在重复元素，比如 [1, 2, 3, 3, 3, 4, 5]，要查找 T = 3，可能会有多个结果。\n如果只是判断 target 是否存在，上述的算法都没有问题。但是如果想找到 index 最小或最大的 target 位置，算法就需要做一些修改。\n参考 C++ 标准库中的 std::binary_search 的实现3：\ntemplate \u0026lt;class ForwardIterator, class T\u0026gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { first = std::lower_bound(first,last,val); return (first!=last \u0026amp;\u0026amp; !(val\u0026lt;*first)); } 调用了 std::lower_bound() 方法，这个方法就是在一个序列中找值为 val 的最小 index 位置，同理还有一个找最大 index 方法的函数 std::upper_bound()\ntemplate \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { ForwardIterator it; iterator_traits\u0026lt;ForwardIterator\u0026gt;::difference_type count, step; count = distance(first,last); while (count\u0026gt;0) { it = first; step=count/2; advance (it,step); if (*it\u0026lt;val) { // or: if (comp(*it,val)), for version (2) first=++it; count-=step+1; } else count=step; } return first; } template \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val) { ForwardIterator it; iterator_traits\u0026lt;ForwardIterator\u0026gt;::difference_type count, step; count = std::distance(first,last); while (count\u0026gt;0) { it = first; step=count/2; std::advance (it,step); if (!(val\u0026lt;*it)) // or: if (!comp(val,*it)), for version (2) { first=++it; count-=step+1; } else count=step; } return first; } 区别就是在更新 left = mid + 1 时，如果想取左边界，条件是 mid \u0026lt; val；如果想取右边界，条件是 mid \u0026lt;= val。\n处处是坑 # 知乎有一篇专栏文章：\u0026lt;聊聊一看就会一写就跪的二分查找\u0026gt;讲了二分中的各个坑点，我们逐一看一下：\nfunc FirstGreaterOrEqual(array []int, target int) int { // 初始化区间左端点： -1 || 0 || 1 ？ l := 0 // 初始化区间右端点： len(array) - 1 || len(array) || len(array) + 1 ? r := len(array) // 当区间不为空时循环： l + 1 \u0026lt; r || l \u0026lt; r || l \u0026lt;= r || l \u0026lt;= r + 1 ? for l \u0026lt; r { // 计算区间中点： l + (r - l) / 2 || l + (r - l + 1) / 2 ? m := l + (r - l) / 2 // 将中点对应的元素同target比较： \u0026gt; || \u0026gt;= || \u0026lt; || \u0026lt;= ? if array[m] \u0026lt; target { // 继续查找右侧这一半： m - 1 || m || m + 1 ? l = m + 1 } else { // 继续查找左侧这一半： m - 1 || m || m + 1 ? r = m } } // 这里应该是 l - 1 || l || l + 1 ? // 这里应该是 r - 1 || r || r + 1 ? return l } 这是一段 go 语言代码，不过不影响理解它的逻辑，其实它就是在 array 中找 target 的左边界。\n来一一解释作者提出的这些坑：\n区间左端点 l = 0 或者其他？\n区间右端点 r = len(array) 还是 len(array) - 1？\n这两个是一个问题，整个区间有四种状态 (l, r) [l, r] (l, r] [l, r]\n对于数组从 0 开始的语言，左闭区间是合适的。\n右开右闭都是可行的，只需要在循环判断时做一下调整\n[l, r] -\u0026gt; l \u0026lt; r + 1 [l, r) -\u0026gt; l \u0026lt; r 一般来说，我们都会选择 l = 0 \u0026amp; [l, r) 这种组合。\n循环结束条件是 \u0026lt; 还是 \u0026lt;= 还是 != \u0026lt; 和 != 都可以，对于非递减序列来说，一般用 \u0026lt;。\n如果 l = r 时，仍然进入循环，同时如果 array[l] \u0026gt;= target，会导致循环无法退出。\n区间中间计算 l + (r - l + 1) / 2 这就属于是 ceil 操作。这个在前面也解释过，不再赘述。\n判断条件 同样的，取决于问题是取最左边的位置还是最右边的，上一节也解释过。\n返回值 结束条件是 l == r，所以返回 l 没有问题。但是这个位置并不一定能满足 array[l] == target，甚至于可能越界。\n返回值 l 表示：[0, l) 位置都是小于 target 的，而 [l, len) 则是大于等于 target 的。这里 l 可能等于 len (越界)。\n所以在使用二分查找，来判断 target 是否存在时，要注意判断是否越界。\n作者最后给了一种通用解决方案，将判断逻辑变成一个闭包方法作为参数传入，这样就可以得出多个二分变种问题的解法。\n总之，记模板 # 可见，想写对二分不容易，那么我们只记一种正确的写法，归纳成模板即可\n# template def _bsearch(a: List[int], x: int, l: int = 0, r: int = None) -\u0026gt; int: r = r or len(a) while l \u0026lt; r: m = l + (r - l) // 2 if a[m] \u0026lt; x: l = m + 1 else: r = m return l Wikipedia\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Binary_search_algorithm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttp://www.cplusplus.com/reference/algorithm/binary_search/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"March 8 2022","permalink":"/leetcode/base/binary-search/","section":"算法专栏","summary":"\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-search.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e“二分”查找是一种非常常用的算法。最坏的情况下时间复杂度也是 \u003ccode\u003eO(log n)\u003c/code\u003e，空间复杂度 \u003ccode\u003eO(1)\u003c/code\u003e，相比线性搜索优秀太多。\u003c/p\u003e\n\u003cp\u003e但是要“写对”，并不容易，1988 年一项调查发现，二十本专业书籍中仅有五本\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e能准确写对“二分”查找。\u003c/p\u003e","title":"很难写⌜正确⌟的二分查找"},{"content":"获取 Class 对象的方法有很多，本文主要是收集整理它们的区别以及探究具体的实现。\nclass 方法 # 有两种 class 方法，一个是实例方法，一个是类方法：\n@interface NSObject \u0026lt;NSObject\u0026gt; - (Class)class OBJC_SWIFT_UNAVAILABLE(\u0026#34;use \u0026#39;type(of: anObject)\u0026#39; instead\u0026#34;); + (Class)class OBJC_SWIFT_UNAVAILABLE(\u0026#34;use \u0026#39;aClass.self\u0026#39; instead\u0026#34;); @end 查看 runtime 的源码：NSObject.mm\n可以看到它们的实现：\n+ (id)self { return (id)self; } - (id)self { return self; } + (Class)class { return self; } - (Class)class { return object_getClass(self); } 所以，说给类对象发 class 消息，得到的是类本身 self，也就是\n[NSObject class] == [NSObject self]\n给实例对象发 class 消息，相当于调用了 object_getClass\nobject_getClass # 那么这个方法的实现是怎么样的呢？\n同样查看 runtime 源码：objc-class.mm\nClass _Nullable object_getClass(id _Nullable obj)\nClass object_getClass(id obj) { if (obj) return obj-\u0026gt;getIsa(); else return Nil; } 调用了 类的 getIsa() 方法\n// objc-object.h\ninline Class objc_object::getIsa() { if (!isTaggedPointer()) return ISA(); uintptr_t ptr = (uintptr_t)this; if (isExtTaggedPointer()) { uintptr_t slot = (ptr \u0026gt;\u0026gt; _OBJC_TAG_EXT_SLOT_SHIFT) \u0026amp; _OBJC_TAG_EXT_SLOT_MASK; return objc_tag_ext_classes[slot]; } else { uintptr_t slot = (ptr \u0026gt;\u0026gt; _OBJC_TAG_SLOT_SHIFT) \u0026amp; _OBJC_TAG_SLOT_MASK; return objc_tag_classes[slot]; } } objc_getClass # 这个方法和上面的 object_getClass 长得很像，但还是有一些区别：\n参数不一样，一个是 id，一个是 const char *，也就是一个传入是个类对象，一个是类名\n实现不一样，一个调用的是 obj-\u0026gt;getIsa()，一个调用的是 loop_up_class()\n// objc-runtime.mm\nClass objc_getClass(const char *aClassName) { if (!aClassName) return Nil; // NO unconnected, YES class handler return look_up_class(aClassName, NO, YES); } 调用了 look_up_class:\n// objc-runtime-new.mm\nClass look_up_class(const char *name, bool includeUnconnected __attribute__((unused)), bool includeClassHandler __attribute__((unused))) { if (!name) return nil; Class result; bool unrealized; { runtimeLock.lock(); result = getClassExceptSomeSwift(name); unrealized = result \u0026amp;\u0026amp; !result-\u0026gt;isRealized(); if (unrealized) { result = realizeClassMaybeSwiftAndUnlock(result, runtimeLock); // runtimeLock is now unlocked } else { runtimeLock.unlock(); } } if (!result) { // Ask Swift about its un-instantiated classes. // We use thread-local storage to prevent infinite recursion // if the hook function provokes another lookup of the same name // (for example, if the hook calls objc_allocateClassPair) auto *tls = _objc_fetch_pthread_data(true); // Stop if this thread is already looking up this name. for (unsigned i = 0; i \u0026lt; tls-\u0026gt;classNameLookupsUsed; i++) { if (0 == strcmp(name, tls-\u0026gt;classNameLookups[i])) { return nil; } } // Save this lookup in tls. if (tls-\u0026gt;classNameLookupsUsed == tls-\u0026gt;classNameLookupsAllocated) { tls-\u0026gt;classNameLookupsAllocated = (tls-\u0026gt;classNameLookupsAllocated * 2 ?: 1); size_t size = tls-\u0026gt;classNameLookupsAllocated * sizeof(tls-\u0026gt;classNameLookups[0]); tls-\u0026gt;classNameLookups = (const char **) realloc(tls-\u0026gt;classNameLookups, size); } tls-\u0026gt;classNameLookups[tls-\u0026gt;classNameLookupsUsed++] = name; // Call the hook. Class swiftcls = nil; if (GetClassHook.get()(name, \u0026amp;swiftcls)) { ASSERT(swiftcls-\u0026gt;isRealized()); result = swiftcls; } // Erase the name from tls. unsigned slot = --tls-\u0026gt;classNameLookupsUsed; ASSERT(slot \u0026gt;= 0 \u0026amp;\u0026amp; slot \u0026lt; tls-\u0026gt;classNameLookupsAllocated); ASSERT(name == tls-\u0026gt;classNameLookups[slot]); tls-\u0026gt;classNameLookups[slot] = nil; } return result; } NSClassFromString # 这个在 Foundation.framework 中的实现，并没有开源，\n函数原型是\nFOUNDATION_EXPORT Class _Nullable NSClassFromString(NSString *aClassName); 与 objc_getClass 参数一样，传入 Class 的名字，返回 Class 地址。\n有大佬通过研究汇编分析出它的具体实现：从汇编代码探究 NSClassFromString 实现\n最后 # 验证一下：\nStudent *stu = [Student new]; Class cls = [stu class]; NSLog(@\u0026#34;%p %p %p %p %p\u0026#34;, cls, [Student class], objc_getClass(\u0026#34;Student\u0026#34;), object_getClass(stu), NSClassFromString(@\u0026#34;Student\u0026#34;)); 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 0x10000e7b8 可以看出来，这几种方法拿到的结果是一样的。\n","date":"February 23 2022","permalink":"/posts/2022/get-class/","section":"碎语闲言","summary":"\u003cp\u003e获取 \u003ccode\u003eClass\u003c/code\u003e 对象的方法有很多，本文主要是收集整理它们的区别以及探究具体的实现。\u003c/p\u003e","title":"[Runtime] 获取 OC Class 对象"},{"content":" Meta 这个词在 2021 年下半年开始火爆，而后 Facebook 改名 Meta 引发各大科技公司跟风押注。似乎全球资本都在追逐“元宇宙”的概念，但什么是“元宇宙”，各家有各家的说法，没有一个统一的标准。\n我个人感觉，元宇宙就是个伪概念。除了一堆跟风炒概念准备割韭菜的老庄家和引颈待收割的韭菜外，各个公司在做的与“元宇宙”相关的事，似乎都是一些“复古网络游戏”。\n历史是一个轮回，唯有资本逐利是永恒的。个人断言，不出三年，这个概念应该就不会有人提了，一如 VR 的喧嚣与沉寂。\nMeta 的起源 # 以上只是个引子，与本文无关 (生硬的转折 😅\n本文继续讨论 Runtime，聚焦 OC 中的 MetaClass。\n一图胜千言，引用 Runtime 工程师 Greg Parker 在其博客中给出的经典图\n为什么要这么设计 # 由于 OC 是 Smalltalk 语言哲学的一种实践，“在 Smalltalk 中，所有的值都是对象”。因此一个实例是对象，它的类也是一个对象。\n实例中的 isa 指针指向了它的类对象，那么类对象的 isa 指针指向谁呢？—— 指向它的元类对象 MetaClass！\nSince a class is an object, it must be an instance of some other class: a metaclass. 1\n那么能不能不这么设计呢？\n当然能，但是这样就不那么 “Smalltalk” 了。非 Smalltalk 语言如 C++，与 OC 的一个重要区别是：\nC++ 支持多重继承\nMeta 与 继承关系 # 定义一对父类与子类：\n@interface Person : NSObject @end @interface Student : Person @end isa 链 # 定义一个子类的实例 Student *stu，根据之前的文章 class-object-isa，实例本质上是一个 objc_object 结构体，内部存在一个 isa 指针，指向的是 Student 这个类对象。\n而类对象 Student 本质上是一个 objc_class 结构体，继承自 objc_object，所以内部也有一个 isa 指针，类对象的 isa 指针指向的是它的元类对象。\n所以，这条链，也就是上图中最下面一行虚线所示：\n实例 \u0026ndash;\u0026gt; 类 \u0026ndash;\u0026gt; 元类\n那么元类的 isa 又指向谁呢，图中显示的是 根元类，通过代码来获取一下这条链：\nStudent *stu = [Student new]; NSLog(@\u0026#34;Student instance addr: %p\u0026#34;, stu); Class cls = [stu class]; NSLog(@\u0026#34;Student class addr: %p\u0026#34;, cls); id rootMetaClass = nil; while (cls) { NSLog(@\u0026#34;isa: %s addr: %p\u0026#34;, object_getClassName(cls), cls); Class tmp = object_getClass(cls); if (tmp == cls) { rootMetaClass = cls; break; } cls = tmp; } NSLog(@\u0026#34;root MetaClass: %p\u0026#34;, rootMetaClass); \u0026ndash;\u0026gt;\nStudent instance addr: 0x100668810 Student class addr: 0x10000e7b8 isa: Student addr: 0x10000e7b8 isa: NSObject addr: 0x10000e790 isa: NSObject addr: 0x7fff806e7060 root MetaClass: 0x7fff806e7060 可以看出来，元类对象最终指向的是根元类对象，但它的名字也叫 NSObject，同时根元类的 isa 是指向自身的，所以最终形成了闭环。\n实例 \u0026ndash;\u0026gt; 类 \u0026ndash;\u0026gt; 元类 \u0026ndash;\u0026gt; 根元类 ↩️\n继承链 # 再来看一下继承关系，\nClass cls = [stu class]; id rootClass = nil; while (cls) { NSLog(@\u0026#34;class: %s addr: %p\u0026#34;, object_getClassName(cls), cls); if (!class_getSuperclass(cls)) { rootClass = cls; } cls = class_getSuperclass(cls); } NSLog(@\u0026#34;rootClass: %p\u0026#34;, rootClass); \u0026ndash;\u0026gt;\nclass: Student addr: 0x10000e7b8 class: Person addr: 0x10000e768 class: NSObject addr: 0x7fff806e7088 rootClass: 0x7fff806e7088 继承链比较简单：\n子类 -\u0026gt; 父类 -\u0026gt; 根类 -\u0026gt; nil\n可以看出来根类没有父类，顺便我们看一下根类的 isa 指向哪里？\nNSLog(@\u0026#34;rootClass\u0026#39;isa: %p\u0026#34;, object_getClass(rootClass)); // rootClass\u0026#39;isa: 0x7fff806e7060 地址 0x7fff806e7060 与前面根元类 rootMetaClass 一样，这也证实了 根类 --\u0026gt; 根元类。\nobjc_explain_Classes_and_metaclasses\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"February 14 2022","permalink":"/posts/2022/meta-class/","section":"碎语闲言","summary":"\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-meta.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMeta 这个词在 2021 年下半年开始火爆，而后 Facebook 改名 Meta 引发各大科技公司跟风押注。似乎全球资本都在追逐“元宇宙”的概念，但什么是“元宇宙”，各家有各家的说法，没有一个统一的标准。\u003c/p\u003e","title":"[Runtime] 从 Meta 说起"},{"content":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。\n参考 OC 编译过程 我们可以借助 clang 工具将 OC 源码预处理成 CPP 来窥探 OC 的内部实现。\n定义一个简单的类：\n@interface Foo : NSObject @property (nonatomic, assign) BOOL ppty1; @property (nonatomic, copy) NSString *ppty2; - (BOOL)iMethod1; - (void)iMethod2:(NSString *)p1; + (void)cMethod1; @end 通过命令 clang -rewrite-objc xx.m 得到一个 9 万多行的 cpp 文件 😱\nhttps://gist.github.com/ryderfang/75a852f1ae0961aeea97127f7d9ca6c5\nTL;DR # 太长不看版：\n🧸 objc_object 是所有实例对象的底层结构，内部只有一个 isa\n🎁 objc_class 是所有类/元类对象的底层结构，它也有一个 isa 指针，指向自己的元类\nOC 1.0 OC 2.0 id 实例 typedef struct objc_object *id; typedef struct objc_object *id; objc_object struct objc_object {} struct objc_object {} Class 类 typedef struct objc_class *Class; typedef struct objc_class *Class; objc_class struct objc_class {} struct objc_class : objc_object {} Class 是什么 # Class 1.0 # 在 \u0026lt;objc/objc.h\u0026gt; 中有这样一行：\ntypedef struct objc_class *Class;\n在 iOS 15 之前 \u0026lt;objc/runtime.h\u0026gt; 中曾经有 objc_class 的定义：\nhttps://opensource.apple.com/source/objc4/objc4-750/runtime/runtime.h.auto.html\n/* Types */ #if !OBJC_TYPES_DEFINED struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; /* Use `Class` instead of `struct objc_class *` */ #endif 目前我使用的 Xcode 13.2.1 中已经找不到这个定义，也就是说在 macOS 12.1 / iOS 15.2 中，OBJC1 已经被完全废弃。\nHint: 按照官方文档 Runtime Version 的解释, legacy 版本 (OC 1.0) 在 2007 年就完全废弃了，所有 iPhone 和 OSX 10.5 以后的 Mac 上使用的都是 modern 版本 (OC 2.0)!\n根据 wiki 的说明，OC 2.0 于 2006 年发布，而 iPhone 第一代 是在 2007 年发布的，Mac OS X 10.5 Leopard 也是在 2007 年上市。\n从这个宏 OBJC2_UNAVAILABLE 可以看出来 OBJC2 这种定义会失效。那么 OBJC2 是什么？\nClass 2.0 # 在 objc-runtime-new.h 中定义了 objc_class 的 2.0 版本：\nstruct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... } 参考 1 和 2\n了解到，苹果在 2006 年重写了 runtime，发布了新的 Runtime 2.0，那么 __OBJC2__ 这个宏是什么时候生效的呢？\n通过查找苹果公开的 runtime 源码：https://opensource.apple.com/source/objc4/ 发现：\n从 objc4-750 这个版本开始，在 objc-config.h 中开始有了 __OBJC2__ 的定义！\n// Define __OBJC2__ for the benefit of our asm files. #ifndef __OBJC2__ # if TARGET_OS_OSX \u0026amp;\u0026amp; !TARGET_OS_IOSMAC \u0026amp;\u0026amp; __i386__ // old ABI # else # define __OBJC2__ 1 # endif #endif 来自 apple 的 commit：\nhttps://github.com/apple-oss-distributions/objc4/commit/26c7408b94ead1f04a0b5976e354a03966ce61ea\n在 objc-api.h 中定义了 OBJC_ISA_AVAILABILITY:\n/* OBJC_ISA_AVAILABILITY: `isa` will be deprecated or unavailable * in the future */ #if !defined(OBJC_ISA_AVAILABILITY) # if __OBJC2__ # define OBJC_ISA_AVAILABILITY __attribute__((deprecated)) # else # define OBJC_ISA_AVAILABILITY /* still available */ # endif #endif 在 objc-private.h 中同时定义了 OBJC_TYPES_DEFINED:\n/* Isolate ourselves from the definitions of id and Class in the compiler * and public headers. */ #ifdef _OBJC_OBJC_H_ #error include objc-private.h before other headers #endif #define OBJC_TYPES_DEFINED 1 同时也定义了 Class 和 id\ntypedef struct objc_class *Class; typedef struct objc_object *id; 所以，不管 OC 1.0 还是 2.0，\nClass 都是一个叫 objc_class 的结构体指针。\nObject 与 id # 在 \u0026lt;objc/objc.h\u0026gt; 中，定义\nhttps://opensource.apple.com/source/objc4/objc4-750/runtime/objc.h.auto.html\nObject 1.0 # #if !OBJC_TYPES_DEFINED /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; #endif 同样被包在 OBJC_TYPES_DEFINED 宏中，也就是 OC 2.0 并不生效。\n那么，OC 2.0 的 objc_object 是什么样的呢，在 objc-private.h 中定义了：\nObject 2.0 # struct objc_object { private: isa_t isa; public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ // initClassIsa(): class objects // initProtocolIsa(): protocol objects // initIsa(): other objects void initIsa(Class cls /*nonpointer=false*/); void initClassIsa(Class cls /*nonpointer=maybe*/); void initProtocolIsa(Class cls /*nonpointer=maybe*/); void initInstanceIsa(Class cls, bool hasCxxDtor); // 省略大量方法 private: void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor); // 省略大量方法` }; 可以看出来不管 OC 1.0 还是 2.0,\nobjc_object 都是一个包含着一个叫 isa 指针/变量 的对象。\nisa 又是什么 # 在 1.0 版本中 isa 就是一个 Class 对象，也就是一个指向 objc_class 的指针，而在 2.0 时，isa 是一个叫 isa_t 的结构体变量。\n那么 isa_t 是什么呢？\n同样在 objc-private.h 中有定义：\nunion isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } uintptr_t bits; private: // Accessing the class requires custom ptrauth operations, so // force clients to go through setClass/getClass by making this // private. Class cls; public: #if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h }; bool isDeallocating() { return extra_rc == 0 \u0026amp;\u0026amp; has_sidetable_rc == 0; } void setDeallocating() { extra_rc = 0; has_sidetable_rc = 0; } #endif void setClass(Class cls, objc_object *obj); Class getClass(bool authenticated); Class getDecodedClass(bool authenticated); }; 参考 1 的图：\n作为一个 union 结构，与 struct 区别在于，成员之间会互相覆盖，union 的总内存占用等于最大的成员占用的内存大小，而 struct 大小至少是成员内存占用之和，如果需要字节对齐则会更大。\n所以采用 union 结构可以节省内存。\n在 objc-object.h 中，有 objc_object::initIsa() 的实现：\ninline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { ASSERT(!isTaggedPointer()); if (!nonpointer) { isa = isa_t((uintptr_t)cls); } else { ASSERT(!DisableNonpointerIsa); ASSERT(!cls-\u0026gt;instancesRequireRawIsa()); isa_t newisa(0); #if SUPPORT_INDEXED_ISA ASSERT(cls-\u0026gt;classArrayIndex() \u0026gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-\u0026gt;classArrayIndex(); #else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls \u0026gt;\u0026gt; 3; #endif // This write must be performed in a single store in some cases // (for example when realizing a class because other threads // may simultaneously try to use the class). // fixme use atomics here to guarantee single-store and to // guarantee memory order w.r.t. the class index table // ...but not too atomic because we don\u0026#39;t want to hurt instantiation isa = newisa; } } 可以看出 isa_t 中的 Class 与 bits 是互斥的，避免了互相覆盖的问题。\nhttps://halfrost.com/objc_runtime_isa_class/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://kangzubin.com/objc1.0-class-object/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"January 4 2022","permalink":"/posts/2022/class-object-isa/","section":"碎语闲言","summary":"作为 Runtime 系列的第一篇博文（也是 2022 年第一篇），先从最基础的对象、类开始学习。","title":"[Runtime] Class, Object 与 isa"},{"content":" 本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章：\nResponding to the Launch of Your App\n有个主要的流程图：\nref: About the App Launch Sequence\n另外，还有一篇介绍如何优化启动速度的文章: Reducing Your App’s Launch Time ，毕竟只有准确了解了启动中做了哪些事，才能更针对地进行优化。\n这里还参考了以下几篇文章：\n[1]: iOS App 启动优化\n[2]: iOS App 从点击到启动\n[3]: 深入了解 App 启动过程\n总结一下，整个启动过程分成四步：\n1. 系统内核加载 # 应用程序由系统内核 XNU 加载，与此同时会加载一个叫 dyld的程序。\n内核主要做了这几件事：\n创建进程\n加载解析可执行文件 (exec_activate_image)1: 主要工作是对 Mach-O 进行检查，并将文件复制到内存中。\n接下来会根据 Mach-O 的 load commands 中指定的信息来加载启动 dyld\n更加详细深入的信息可以参加滴滴技术公众号上的两篇：\nXNU、dyld 源码分析，Mach-O 和动态库的加载过程 (上)\nXNU、dyld 源码分析，Mach-O 和动态库的加载过程 (下)\nMach-O 格式2：\nMac 与 iOS 仅在应用层实现上有一些差别，可执行文件的格式也都是 Mach-O 的。所以，Mac App 与 iOS App 启动流程是差不多的。\ngraph TD A(Cocoa) --\u003e | Mac | B(Media) E(Cocoa Touch) --\u003e | iOS | B B --\u003e C(Core Services) C --\u003e D(Core OS) 2. pre-main 阶段 # 这里指 main 函数之前，内核加载 app 之后的一些事。主要是 dyld 的工作：\n加载程序所需的动态库 包括分析依赖、验证有效性 (是否符号当前系统架构)，使用 ImageLoader 加载进内存\nrebase/rebind 为了安全性，苹果采用了 ASLR (Address space layout randomization)3 技术，这样 app 实际加载地址会有偏移。\n需要通过 rebase 对所有指向进程内的符号进行地址调整，同时使用 bind 处理 dylib 外部的符号。\nObjC setup Runtime 的初始化，ObjC 类的注册，selector 唯一性检查，Category 注册，Protocol 读取等。\nInitializers 这一阶段会调用所有类的 load 方法，执行带 attribute((constructor)) 修饰的 C++ 方法，非基本类型 C++ 静态变量创建\n可以在 iOS 任一对象的 load 方法处打断点，获得如下堆栈信息4：\n0 +[AppDelegate load] 1 call_load_methods 2 load_images ... 3 dyld::notifySingle(dyld_image_states, ImageLoader const*) 4 ImageLoader::recursiveInitialization(...) 5 ImageLoader::processInitializers(...) 6 ImageLoader::runInitializers(...) 7 dyld::_main(...) 8 dyldbootstrap::start(...) 9 _dyld_start 3. main 方法 # 这个阶段是指从 main 函数开始到 -[UIApplicationDelegate application:didFinishLaunchingWithOptions:] 中首屏渲染完成之前的事。\n初始化各种配置，如 info.plist，UserDefaults 等等\n各种 sdk、日志系统初始化\n用于首屏数据展示的网络请求\n首屏渲染计算\n4. 首屏渲染后 # 这里用户已经感知到 app 启动了，一般来说，会初始化一些非首屏功能的模块。\n后记 # 了解了启动流程，就必须要继续研究如何加快 app 启动速度。一般来说，我们只能在上述第 2，3 两步尽可能做一些优化。\n参考下一篇：\n还能更快吗之启动优化\nhttps://juejin.cn/post/6844903511612899336\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/aidansteele/osx-abi-macho-file-format-reference\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://en.wikipedia.org/wiki/Address_space_layout_randomization\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.jianshu.com/p/c0a1a3ad9336\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"December 28 2021","permalink":"/posts/2021/app-launch-process/","section":"碎语闲言","summary":"本文讨论一下 iOS 的 App 从用户点击图标开始到 App 完全可用的过程。苹果开发者文档有这样一篇文章：","title":"发生在用户点击 App Icon 之后"},{"content":"概述 # Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。\n当我们在讲 Runtime 的时候，我们在说什么？\n根据官方文档的定义，\nObjective-C Runtime\nObjective-C Runtime Programming Guide\nRuntime 是一个动态库 (/usr/lib/libobjc.A.dylib)，用于实现 OC 语言的动态性。\n这个动态性主要体现在三个方面 ref:\n动态类型 (Dynamic Typing): 运行时才能决定对象的类型，也就是说编译器不检查类型合法性 动态绑定 (Dynamic Binding): 运行时才能知道方法被如何执行，也就是消息机制 (messaging) 动态加载 (Dynamic Loading): 允许动态添加类、方法等 起源 # 孙源大佬在 博客 中说过，OC1 其实是 C 语言与 SmallTalk2 思想结合的产物。\n与同属 SmallTalk 学派的语言 Java, Python 和 Ruby 一样，OC 具有面向对象、动态类型和反射式等特点。\nObjective-C = C + Preprocessor + Runtime\nSmallTalk 领先了时代 20 年，至今 OC 仍然没有实现它的全部特性。\nRuntime Version # 存在两个版本的 Runtime，modern 和 legacy：\ndeveloper.apple.com/ObjCRuntimeGuide/ocrtVersionsPlatforms\n按照官方的说明，所有 iPhone 和 10.5 版本之后的 Mac OSX 64 位程序都使用的 OC 2.0。\nRuntime 源码: https://opensource.apple.com/source/objc4/\n下载 tarballs: https://opensource.apple.com/tarballs/objc4/\n可调试项目: https://github.com/RetVal/objc-runtime\nRuntime 里有什么 # Runtime 的源码可以在 RetVal/objc-runtime 这里找到，甚至可以 Debug。\n主要包含如下几个方面，后续会逐个总结。\nClass/Object 与 isa # 参考：Class Object 与 isa\nMetaClass # 元类指向链: 实例 -\u0026gt; 类 -\u0026gt; 元类 -\u0026gt; 根元类 -\u0026gt; 根元类 (isa 指向自己) 类的继承链: 子类 -\u0026gt; 父类 -\u0026gt; NSObject -\u0026gt; nil 元类的继承链: 子类元类 -\u0026gt; 父类元类 -\u0026gt; 根元类 -\u0026gt; NSObject -\u0026gt; nil 参考：从 Meta 说起\nMethod/IMP/SEL # Category # Messaging # Swizzling # 其它常用方法 # ++++++\nhttps://zh.wikipedia.org/wiki/Objective-C\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://zh.wikipedia.org/zh-hans/Smalltalk\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"December 28 2021","permalink":"/posts/2021/what-is-runtime/","section":"碎语闲言","summary":"概述 # Runtime 是 OC 这个语言的核心，也是为什么 OC 被称为动态语言的原因。","title":"ObjC 之 Runtime 是个啥"},{"content":" 本文可以作为面试八股的准备指南\n很早之前看过一个 前端 Roadmap，图做的非常漂亮。最近发现有人做了类似的 移动端 Roadmap，\n其中 iOS 是这样的：\n还有 Swift 的，暂时先不关注了。这里综合一下形成文字版，方面查缺补漏。\niOS 的体系结构如下图：\nRef: iOS abstraction layers\n需要重点关注的有下面几个方面：\ndemo 工程：https://github.com/ryderfang/iosBagu Foundation # ARC/MRC 与 内存管理 # ARC is supported in Xcode 4.2 for OS X v10.6 and v10.7 (64-bit applications) and for iOS 4 and iOS 5.\n现在除了一些老项目，基本没有 MRC 为主的代码了，所以只需要简单了解下 MRC 与 ARC 的区别即可\nMRC 需要手动写 dealloc，并且一定要最后再调用父类的 dealloc； ARC 一般不需要写 dealloc，也不需要调用 [super dealloc]。移除 NSNotification Observer 和 KVC Observer 例外。\n在 ARC 的工程中使用 MRC，需要在工程中设置源文件的编译选项 -fno-objc-arc\nTagged Pointer\nOC 对象与 CF 对象转换\n__bridge, __bridge_retained, __bridge_transfer AutoReleasePool # AutoReleasePool 的数据结构\nAutoReleasePool 与 @autoreleasepool\nBlock 🔥 # __weak 与 __block\nblock 的结构体类型\nblock 如何捕获外部变量\n循环引用 与 Weak-Strong Dance\nCategory 🔥 # load 加载时机\nload 与 initialze\n方法加载时机\n如何添加属性 - 关联对象\ncategory 与 class-extension\ncategory 覆盖原类方法的原理\ncategory 同名方法调用顺序\nHotPatch # JSPatch 的原理 KVC 与 KVO # KVC 是如何实现的\nKVO 的原理\n如何对 NSMutableArray 进行 KVO\nmutableArrayValueForKey KVC 与 KVO 有什么联系与区别\nMultiThread 多线程 🔥 # 哪些多线程方法\nGCD 与 NSThread, NSOperationQueue\n互斥锁与自旋锁\nNetwork 🔥 # NSURLSession 与 NSURLConnection\n常用网络库\nAFNetworking (ObjC)\nAlamofire (Swift)\nNSTimer 🔥 # timer 与 Runloop\ntimer 导致循环引用的产生与解决\nProperty 🔥 # 不指定任何关键字时，默认的类型：\nOC 对象：atomic, readwrite, strong 数值对象：atomic, readwrite, assign 不同属性的区别\natomic/nonatomic readonly/readwrite (retain, MRC)/assign/weak/strong/unsafe_unretained/copy copy 与 assign\nweak 与 copy\nweak 与 __unsafe_unretained\natomic 并不是线程安全的\n如何实现一个弱引用容器\n+ [NSPointerArray weakObjectsPointerArray] 弱引用数组 + [NSMapTable weakToWeakObjectsMapTable] 弱引用表 + [NSHashTable weakObjectsHashTable] 弱引用 hash 表 + [NSValue valueWithNonretainedObject:] 弱引用对象 Runloop 🔥 # Runloop 与线程的关系\nmode\nsource0 \u0026amp; source1\n如何实现一个常驻线程\n用 runloop 监听主线程卡顿\nRuntime 🔥 # 系列文章：Runtime 是个啥？\nMethod Swizzling\n从 Meta 说起\nClass, Object 与 isa\n运行时，动态添加一个类\n消息转发\nNSObject 与 \u0026lt;NSObject\u0026gt;\n其他知识 # NSNotification 原理\nid 与 instancetype\nnil, Nil, NULL, NSNull\nNSPredicate 谓词\nAPNS (Apple Push Notification Service) 原理\nUIKit # UIView 与 CALayer # bounds 与 frame\nsetNeedsDisplay 与 layoutIfNeeded\n常用 UI 组件 # UIScrollView\nUITableView\ncell 复用原理 UICollectionView\nAutoLayout # Masonary 原理\nVFL 语法\n约束 Constraints\nUIResponder # touch events\nhitTest / pointsInside\n事件传递与响应链\n离屏渲染 # layoutSubview 与 drawRect 性能优化 # 图片渲染过程\n卡顿优化\nCore 系列 # Core Graphics # 高效绘制圆角 Core Data # AVFoundation # 架构能力 # 设计模式 # 架构模式 # MVC\nMVP\nMVVM\n响应式编程 # 重构与解耦 # 组件化 # 更多面试题：\nhttps://github.com/LGBamboo/iOS-Advanced https://www.jianshu.com/p/e709fde38de3 https://www.jianshu.com/p/d9a39ab1d526 ","date":"December 23 2021","permalink":"/posts/2021/objc-roadmap/","section":"碎语闲言","summary":"\u003cdiv class=\"!mb-9 text-xl lead\"\u003e\n  \u003cblockquote\u003e\n\u003cp\u003e本文可以作为面试八股的准备指南\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e很早之前看过一个 \u003ca href=\"https://github.com/kamranahmedse/developer-roadmap\"\u003e前端 Roadmap\u003c/a\u003e，图做的非常漂亮。最近发现有人做了类似的 \u003ca href=\"https://github.com/godrm/mobile-developer-roadmap\"\u003e移动端 Roadmap\u003c/a\u003e，\u003c/p\u003e\n\u003cp\u003e其中 iOS 是这样的：\u003c/p\u003e","title":"ObjC 之 技术路线图"},{"content":"时隔两年，再次拾起博客。\n我完全不是一个有恒心的人，而且做什么事都是三分钟热度。包括博客，从 Jekyll 到 Hexo，再到现在 Hugo。\n有新鲜玩意都想把玩一下，折腾完了又觉得索然无味。注重形式大于内容，纠结字体字号、各种样式的事情，反而没什么内容沉淀下来。\n关于博客 # 在腾讯云买了域名 ryderfang.com，然后折腾备案、SSL 证书部署、nginx 配置静态页面等等， 目前源文件拖管在 Github 上，每次 push 自动触发 Actions， 完成编译并推送到 gh-pages 分支的操作。站内搜索使用 algolia，使用手动 Actions 的方式，需要时触发更新。\n同样在腾讯云买了一个轻应用服务器，托管一下这个静态博客，不打算再折腾自动化了，需要同步的时候 ssh 登录一下，手动拉一下 repo 就好。\n哈哈，总是在打脸，还是把自动同步服务器做成了一个 Action\n- name: remote ssh command uses: appleboy/ssh-action@master with: host: ${{ secrets.TENCENT_CLOUD_HOST }} username: ubuntu key: ${{ secrets.TENCENT_CLOUD_KEY }} port: 22 script: | whoami cd blog \u0026amp;\u0026amp; git pull echo \u0026#39;Done!\u0026#39; 再把之前的博客内容整理到新的博客上，发现并没多少值得保留的，真是有点惭愧。\n技术目标 # 常常想起小时候爸爸告诫我的话：\n有志之人立常志，无志之人常立志。\n但是，这么多年的工作经历，让我认识到自己只是个普通人。普通的技术、普通的能力和普通的志向，甚至于在 “内卷” 与 “躺平” 的浪潮中，已经逐渐想要躺平。\n最近又看到一句话：\n到底什么样的终点，才配得上这一路的颠沛流离 ?!\n是啊，或许，我们只是想去码头整点薯条，人生本无太多意义。\n扯远了，总之，普通人就定几个能完成的普通目标。也不要过分自责，因为你就是一粒宇宙的尘埃。\n写文章 # 到年底还有一个多月，输出 2-3 篇技术博客。\nUPDATE: 算完成 80% 吧，内容还需要补充\niOS 技术栈 # 继续完善 iOS 八股技术栈: https://github.com/ryderfang/iOSBagu，尽可能去了解一些犄角旮旯的知识点。\nUPDATE: 没有完成，需要尽快补齐\n读书 # 读一点其他领域的书，随便看一点。\nUPDATE: 没有完成，多读书是 2022 重点目标\n生活目标 # 健康 # 身体 NO.1，换季的时候，一家人都得了咽炎，去医院太折腾了。希望全家都健康，宝宝也快点长大，少让姥姥和大家操点心吧。\nUPDATE: 安安越来越大了，前段时间脸上又被虫咬了一大块，最近快长好了。\n平安、健康、快乐，足矣。没有别的希冀。\n早起 # 每天送老婆上班，虽然累，但还是挺好的，早到公司一小时，可以做很多事了。困的问题就中午多午睡一会儿吧。\n能睡说明自己还年轻吧，至少没有失眠的困扰，感觉至少要睡十个小时才能满足，也只能周末才有这个机会了。\nUPDATE: 本来年底想面试一下来年换个工作，但老婆可能也要换，准备还是继续苟一段时间。\n总的来说，鹅厂的人文关怀还是可以的。但不同项目组也差异很大，PCG 确实是个天坑。\n结语 # 就这些吧，我感觉能完成 80% 就已经很不错了。元旦的时候再来 check 一下 🚀\n","date":"November 16 2021","permalink":"/posts/2021/2021-personal-challeng/","section":"碎语闲言","summary":"\u003cp\u003e时隔两年，再次拾起博客。\u003c/p\u003e","title":"2021 个人目标 🎯"},{"content":" Hello, World! 👋 # 历经 BAT 三家公司，摸鱼达人，废柴码农。人生苦短、及时行乐。\nI worked at Bilibili, Alibaba and now Tencent, still too vegetable to be a senior engineer. Lacking of patience and persistence.\nNow I\u0026rsquo;m living with my wife and little son in Shanghai, China.\nLife is too short, Just enjoy it.\n经历 # 🐧 腾讯科技（上海）有限公司 客户端开发 2019.11 - Now 手 Q 开发 相机渲染，道具特效等 图片、视频编辑 AI 端智能 🚼 口碑（上海）信息技术有限公司 | 阿里巴巴 高级无线开发工程师 2017.10 - 2019.11 口碑掌柜 业务开发、投放体系建设 Lottie 接入 阿里云语音SDK 技术专项 端 AI 智能算法 H5 容器相关 🏝 上海哔哩哔哩科技有限公司 | 幻电信息科技 iOS 开发工程师 2016.04 - 2017.10 iOS 客户端 C++ 转 iOS 开发 业务开发，视频收藏夹 图片治理，webP 接入等 UGC 投稿助手 QT \u0026amp; C++ 开发 多线程视频文件上传 稿件管理功能等 📟 上海二三四五网络科技有限公司 2013.12 - 2016.04 2345 单核/双核 浏览器 浏览器业务开发 逆向技术、Flash 兼容 广告拦截技术 看图王、好压 DirectUI C++ 多线程开发 +++\n","date":"November 11 2021","permalink":"/about/","section":"","summary":"Hello, World!","title":"About"},{"content":" 年代久远，内容不再保正。 之前用的 bangwagon 突然连不上了，找到现在可用的官网 (https://bwh88.net/clientarea.php?action=products) 看了下，服务虽然到期了，但整个 Service 被停用了。\n发了个 Ticket 问了下，倒是很快回复了。结论就是我之前买的那种 10G 的产品是 OpenVZ v6 架构，已经不再维护，下架了。 看了下，现在最便宜的就是 20G 这款，一年 50 美金，差不多也是行情价。\n考虑到 bandwagon 配置并不是特别方便，经同事推荐改用 Vlutr，现在优惠还不错 (重点)：\n1、充 $10 送 $25。 点击注册\n2、充 $25 送 $50。 点击注册\n最关键的是，支持 支付宝 付款！\n注册 # 注册非常简单，点击上面的链接，用邮箱注册即可。都不用激活，方便的一比。\n充值 # 登录之后，在 https://my.vultr.com/billing/ 页面，选择 Alipay (支付宝)，充 $25，搞定！\n$25 足够用 5 个月了！\n买机器 # 进入 https://my.vultr.com/deploy/\n地区 选欧洲或者美国的，相对快一点。 操作系统 选 Ubuntu, 版本 18.04 x64。(因为这是 LTS 版本，相对稳定点) 机器类型选最便宜的 $5/月 的。 其他不用管，直接 Deploy 吧。\n配置 # 等机器准备好，在 Products 页面中找到你的机器 IP 地址、密码等信息。打开本地终端， ssh root@ip -p 22 输入密码，登录远程机器。\n通过脚本一键安装 SS 服务端即可。\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2\u0026gt;\u0026amp;1 | tee shadowsocks.log 设置端口号、密码等，等脚本执行完。 这里有个坑，脚本里 shadowsocks.json 里配置的服务器地址是 0.0.0.0，有 Vlutr 环境里好像不通，我之前用 bandwagon 不用改，但是 Vlutr 不行。\nvim /etc/shadowsocks.json // 把里面的 \u0026#34;server\u0026#34; 字段修改为服务器的 IP 址。 在本地，用 SS 服务端，设置好同样的 IP 地址、端口号和密码即可。\n至此，就可以去浪了！🌊🌊🌊\n","date":"September 10 2019","permalink":"/posts/2019/shadowsocks-with-vlutr/","section":"碎语闲言","summary":"年代久远，内容不再保正。 之前用的 bangwagon 突然连不上了，找到现在可用的官网 (https://bwh88.","title":"从搬瓦工到 Vlutr 继续冲浪"},{"content":"这是干啥的 # 敏感你懂的，不多谈。🌝\n年代久远，内容不再保正。 怎么用 # 下载 ShadowsocksX-NG， https://github.com/shadowsocks/ShadowsocksX-NG/releases/\n配置自己的 VPS，比如我自己使用的 Bandwagon VPS，或者使用其他 SS server 地址\n在 ShadowsocksX-NG 中添加服务器，配置好可以 FQ 了。\n搬瓦工 # 目前可用的主页地址是\nhttps://bwh1.net/clientarea.php?action=products\n我买的最便宜的一个 10G VZ - PROMO，一个月 $2.99，但年付才 $19.99 (130 软妹币) 而已。\n每月流量 550GB 根本用不完\n有需要的朋友，如果不想自己配置，可以给我转 ￥10 (一个月)，我把我的 VPS 共享给你。\n配置项 # 在 ShadowsocksX-NG 的服务器配置中，导入如下配置即可\n{ \u0026#34;random\u0026#34; : false, \u0026#34;authPass\u0026#34; : null, \u0026#34;useOnlinePac\u0026#34; : false, \u0026#34;TTL\u0026#34; : 0, \u0026#34;global\u0026#34; : false, \u0026#34;reconnectTimes\u0026#34; : 3, \u0026#34;index\u0026#34; : 0, \u0026#34;proxyType\u0026#34; : 0, \u0026#34;proxyHost\u0026#34; : null, \u0026#34;authUser\u0026#34; : null, \u0026#34;proxyAuthPass\u0026#34; : null, \u0026#34;isDefault\u0026#34; : false, \u0026#34;pacUrl\u0026#34; : null, \u0026#34;configs\u0026#34; : [ { \u0026#34;enable\u0026#34; : true, \u0026#34;password\u0026#34; : \u0026#34;****\u0026#34;, \u0026#34;method\u0026#34; : \u0026#34;aes-256-cfb\u0026#34;, \u0026#34;remarks\u0026#34; : \u0026#34;Bandwangon\u0026#34;, \u0026#34;server\u0026#34; : \u0026#34;**.**.**.**\u0026#34;, \u0026#34;kcptun\u0026#34; : { \u0026#34;nocomp\u0026#34; : false, \u0026#34;key\u0026#34; : \u0026#34;****\u0026#34;, \u0026#34;crypt\u0026#34; : \u0026#34;salsa20\u0026#34;, \u0026#34;datashard\u0026#34; : 70, \u0026#34;mtu\u0026#34; : 1350, \u0026#34;mode\u0026#34; : \u0026#34;fast2\u0026#34;, \u0026#34;parityshard\u0026#34; : 30, \u0026#34;arguments\u0026#34; : \u0026#34;\u0026#34; }, \u0026#34;enabled_kcptun\u0026#34; : true, \u0026#34;server_port\u0026#34; : 29900, \u0026#34;remarks_base64\u0026#34; : \u0026#34;QmFuZHdhbmdvbg==\u0026#34; } ], \u0026#34;proxyPort\u0026#34; : 0, \u0026#34;randomAlgorithm\u0026#34; : 0, \u0026#34;proxyEnable\u0026#34; : false, \u0026#34;enabled\u0026#34; : true, \u0026#34;autoban\u0026#34; : false, \u0026#34;proxyAuthUser\u0026#34; : null, \u0026#34;shareOverLan\u0026#34; : false, \u0026#34;localPort\u0026#34; : 1080 } 附录 # 一些命令\n$ /usr/bin/python /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start # /etc/shadowsocks.json { \u0026#34;server\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, \u0026#34;server_port\u0026#34;:8989, \u0026#34;local_address\u0026#34;:\u0026#34;127.0.0.1\u0026#34;, \u0026#34;local_port\u0026#34;:1080, \u0026#34;password\u0026#34;:\u0026#34;****\u0026#34;, \u0026#34;timeout\u0026#34;:300, \u0026#34;method\u0026#34;:\u0026#34;aes-256-cfb\u0026#34;, \u0026#34;fast_open\u0026#34;:false } kcp config\n{ \u0026#34;listen\u0026#34;: \u0026#34;:29900\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;127.0.0.1:8989\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;****\u0026#34;, \u0026#34;crypt\u0026#34;: \u0026#34;salsa20\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;fast2\u0026#34;, \u0026#34;mtu\u0026#34;: 1350, \u0026#34;sndwnd\u0026#34;: 1024, \u0026#34;rcvwnd\u0026#34;: 1024, \u0026#34;datashard\u0026#34;: 70, \u0026#34;parityshard\u0026#34;: 30, \u0026#34;dscp\u0026#34;: 46, \u0026#34;nocomp\u0026#34;: false, \u0026#34;acknodelay\u0026#34;: false, \u0026#34;nodelay\u0026#34;: 0, \u0026#34;interval\u0026#34;: 40, \u0026#34;resend\u0026#34;: 0, \u0026#34;nc\u0026#34;: 0, \u0026#34;sockbuf\u0026#34;: 4194304, \u0026#34;keepalive\u0026#34;: 10 } 数据流\n","date":"June 21 2018","permalink":"/posts/2018/shadow-socks-and-bandwagon/","section":"碎语闲言","summary":"这是干啥的 # 敏感你懂的，不多谈。🌝","title":"关于科学冲浪"},{"content":"Mark Zuckerberg 每年都会发布自己的年度挑战 Personal Challenge\nSo，我也要给自己立一些 Flag\u0026hellip;\n技术目标 # //\u0026lt;!-- --\u0026gt; console.log(\u0026#39;达到中初级前端工程师水平\u0026#39;) //\u0026lt;!-- --\u0026gt; UPDATE: 并没有达到 😢\n这将是技术广度拓宽的一年。\n最近几年，随着中年危机的提前到来，90年码农越来越焦虑，在知乎上的各种问题:\n35 岁以上的互联网 / 科技行业从业者面临裁员时，应如何规划职业发展？\n新时代的中年危机长啥样？\n30岁程序员的出路\n知乎圆桌 - 30 岁人生攻略\n等等\n很多人表达了这样一个观点，要想维持职场生命力，必须要努力掌握更深更广地技能。\n成为所谓的斜杠 (Slash) 青年，不再满足于单一职业，而是多元化发展。\n生活目标 # 早点睡觉 # 常年处于缺觉的状态，整个人都不好了\nTODO: 最好 11:30 pm 前睡觉\n锻炼身体 # 小肚子减减减呀！\n家里收拾好 # 养了点花花草草，买了一只小龟龟，希望它明年还在\nUPDATE: 小龟龟被我养死了 😭\n结婚吧 # 在一起快一年了，喜欢她的性格，也觉得该修成正果，安定下来了。\nUPDATE: 2018.12.01 相识 520 天，我们结婚啦！👫 💕💕\n","date":"January 29 2018","permalink":"/posts/2018/2018-personal-challenge/","section":"碎语闲言","summary":"\u003cp\u003eMark Zuckerberg 每年都会发布自己的年度挑战 \u003ca href=\"https://www.facebook.com/zuck/posts/10104380170714571\"\u003ePersonal Challenge\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-2018-Zuckerberg.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003eSo，我也要给自己立一些 Flag\u0026hellip;\u003c/p\u003e","title":"2018 个人目标 🎯"},{"content":"Chromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏\n当然是因为好 zhuāng 用 bī 了 😅 废话少说，下载地址： https://download-chromium.appspot.com/\n如果下载不了，可以试下：\nWindows https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/\nMac https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Mac/\n打不开之类的需要翻墙的问题自行解决吧。\n问题 # 打开 Chromium 会提示 缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用 😒\n由于 Chromium 使用的 API 都需要自行申请密钥才能使用。\n所以 在 https://console.cloud.google.com/ 上创建密钥。\n相关文档：http://www.chromium.org/developers/how-tos/api-keys\n最后密钥有三个，位置在 https://console.cloud.google.com/apis/credentials\nGOOGLE_API_KEY GOOGLE_DEFAULT_CLIENT_ID GOOGLE_DEFAULT_CLIENT_SECRET 解决 # 官方的解决方法是：\n将下面三行写到 ~/.bash_profile 中，然后重启浏览器即可\nexport GOOGLE_API_KEY=\u0026#34;****\u0026#34; export GOOGLE_DEFAULT_CLIENT_ID=\u0026#34;**** export GOOGLE_DEFAULT_CLIENT_SECRET=\u0026#34;****\u0026#34; $ source ~/.bash_profile 这样，有时是管用的。特别是在 Windows上，使用类似的在命令行输入：\nsetx GOOGLE_API_KEY your_key_goes_here setx GOOGLE_DEFAULT_CLIENT_ID your_client_id_goes_here setx GOOGLE_DEFAULT_CLIENT_SECRET your_client_secret_goes_here 但是 Mac 上有时不管用，参考:\nhttps://gist.github.com/cvan/44a6d60457b20133191bd7b104f9dcc4\n在文档最后，发现有个哥们写了一个 Python 脚本，试了下，很好用！\n我 Fork 了一下，修复了一个 bug，给他提了 PR (https://github.com/ezeeyahoo/ChromiumSyncEnabler/pull/1)\nhttps://github.com/ryderfang/ChromiumSyncEnabler\n跑下来重启 Chromium 就 OK 了！\n","date":"January 26 2018","permalink":"/posts/2018/chromium-api-keys/","section":"碎语闲言","summary":"\u003cp\u003eChromium 是 Chrome 的开发版本，也就是开发过程中存在一堆 Bug 的版本，那么为什么要用这个呢 😏\u003c/p\u003e","title":"Chromium 缺少 Google API 密钥解决办法"},{"content":"Visual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。\n其中 社区版 Community Version 是永久免费的。\n唯一不足的是在导出图表为图片时，右下角会有一个水印。\n本文就是要使用 Python 去除这个水印，输出 png 图片。\n该方法参考了网络上手动去除的方法，需要有一些操作\n导出 # 首先需要将完成的图表导出为 svg 格式的图片：\n选择 svg 格式保存：\n这样我们就得到了一个带水印的 svg 图片:\n去除水印 # 处理 svg 图片 Svg（Scalable Vector Graphics，可缩放矢量图形） 是一种矢量图片格式，可以使用文本编辑器直接打开，可以看得到在最后几行有水印的内容，所以我们可以用代码自动把他们去掉（当然也可以手动删除）。\n水印内容在 Svg 文件中：\n\u0026lt;text x=\u0026#34;68\u0026#34; xml:space=\u0026#34;preserve\u0026#34; y=\u0026#34;276\u0026#34; stroke=\u0026#34;none\u0026#34; \u0026gt;Powered ByVisual Paradigm Community Edition\u0026lt;/text \u0026gt;\u0026lt;image font-size=\u0026#34;12\u0026#34; x=\u0026#34;303\u0026#34; y=\u0026#34;264\u0026#34; fill=\u0026#34;white\u0026#34; width=\u0026#34;16\u0026#34; xlink:href=\u0026#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABvklEQVR42o1TPUgC YRi+z1PSzWrSc6ho6W/xNIhEoZoCl/a2fqaGoJKwyHIp16ZyCyIolwpq6c8lIz0h h6ACa/KWOHGz4byezz7lkNM8eHjf7/ve53l/vu84rsWXEcVo2uOJtYrhW5A3YCKE 48YXnE7zoSzfty3AyFHdln/R4bBA5O5fgQbyiUbIK6oY5gjxG1XCtyAngFl7qXT+ Y7UOwR+glTSK8EZkomlJMZsNCrKs7iuKOuXzJboUJYAqemrtHEBkGwsTIy/pe0bZ /Rmvd6K27svnx7Q/cu08LIliiPpmlvEGJo0DL4sRSKVyBuEZledznKpeYs+u6/YF nKt6C+jpe14QPjCsQUpmQVYgaNK0R9hPYJLtZ5Eo5JGkVF0AmUZAvoBLM5WBXhZs A6YB+pi+AAudD+zOnMuVjBcKheoMbOXyG0wcWKGtAPr77gauKyYTFU8g+xrsUWex mKu2r79Gye3eQkAE7i4wCtQG+YTMKZwt0zOUv274DjCLJGZBoEqv9JRtyyDfgrwK f09PNnyJ6OuBiYSxPAbecf9UMNZIbvovUBE8FjRINrEMNJbd1t9I28Gz7YD7DHKo WdwvFl2vGaThOSEAAAAASUVORK5CYII=\u0026#34; height=\u0026#34;16\u0026#34; stroke=\u0026#34;white\u0026#34; preserveAspectRatio=\u0026#34;none\u0026#34; /\u0026gt; 用 Python 读取文件内容，去除这一段内容即可。\n转换成 png 图片 然后将 Svg 格式转换成 png格式，这里有现成的库 cairosvg 来实现。\n完整的代码可以在 我的 Github 上找到。\n使用方法 # 需要先安装 cairosvg: $ pip3 install cairosvg 可能会报错，Pillow 安装失败，提示： The headers or library files could not be found for zlib.\n可以尝试一下:\n$ xcode-select —-install $ brew install libtiff libjpeg webp little-cms2 $ pip3 install Pillow 安装 cairosvg 成功后，使用 Python3 import cairosvg 发现还是报错:\n\u0026gt;\u0026gt;\u0026gt; import cairosvg Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/__init__.py\u0026#34;, line 29, in \u0026lt;module\u0026gt; from . import surface File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairosvg/surface.py\u0026#34;, line 24, in \u0026lt;module\u0026gt; import cairocffi as cairo File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\u0026#34;, line 41, in \u0026lt;module\u0026gt; cairo = dlopen(ffi, \u0026#39;cairo\u0026#39;, \u0026#39;cairo-2\u0026#39;) File \u0026#34;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/cairocffi/__init__.py\u0026#34;, line 38, in dlopen raise OSError(\u0026#34;dlopen() failed to load a library: %s\u0026#34; % \u0026#39; / \u0026#39;.join(names)) OSError: dlopen() failed to load a library: cairo / cairo-2 经过搜索，发现还需要安装 cairo 和 libffi：\n$ brew install cairo pango gdk-pixbuf libffi 终于弄完了 源文件： vp_remove_watermark.py\n核心代码如下： import cairosvg svg_content = \u0026#39;\u0026#39; with open(src_name, \u0026#39;r\u0026#39;) as f: svg_content = f.read() end = svg_content.rfind(\u0026#39;\u0026lt;/g\u0026#39;) beg = svg_content.rfind(\u0026#39;\u0026lt;g\u0026#39;, 0, end) svg_content = svg_content[:beg] + svg_content[end:] with open(\u0026#39;./vp_test_out.svg\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(svg_content) cairosvg.svg2png(url=\u0026#39;./vp_test_out.svg\u0026#39;, write_to=dst_name) 赶紧跑起来 $ python vp_remove_watermark test.svg -o out.png ","date":"January 25 2018","permalink":"/posts/2018/visual-paradigm-remove-watermark/","section":"碎语闲言","summary":"\u003cp\u003eVisual Paradigm 是一个不错的画流程图、时序图和类图的工具，有 30 天试用版和社区版。\u003c/p\u003e\n\u003cp\u003e其中 \u003ca href=\"https://www.visual-paradigm.com/cn/download/community.jsp\"\u003e社区版 Community Version\u003c/a\u003e 是永久免费的。\u003c/p\u003e","title":"移除 Visual Paradigm 流程图的水印"},{"content":"最近开始学习 Vue.js, 一脸懵逼地进入前端世界。\n不使用 vue-cli 和 webpack 这些构建工具，使用单个 html 引入 Vue。\nhtml 内容是这样的:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Vue\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#39;app\u0026#39;\u0026gt; \u0026lt;span v-bind:title=\u0026#34;message\u0026#34;\u0026gt;鼠标悬停\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;页面加载于 \u0026#39; + new Date().toLocaleString() } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用浏览器打开这个 html 就可以看到效果（鼠标悬停显示『页面加载于yyyy-MM-dd hh:mm:ss』）\n安装 Vue-Devtools，但是插件栏显示\nVue.js not detected\n由于访问的路径是 file:// 文件路径，Chrome 扩展默认是不能访问的。\nVue.js not detected # 打开右上角 ... -\u0026gt; 更多工具 -\u0026gt; 扩展程序，找到 Vue.js devtools，选中 允许访问文件网址:\nOK，然后 devtools 仍然不可用，提示\nVue.js is detected on this page. Devtools inspection is not available because it's in production mode or explicitly disabled by the author.\n由于我们使用的 vue.js https://cdn.jsdelivr.net/npm/vue 是生产版本，所以不能访问。\nProduction mode # 下载开发版本的vue.js，放到本地，修改src路径为本地即可。\n开发版本: https://vuejs.org/js/vue.js\n生产版本: https://vuejs.org/js/vue.min.js (或者 https://cdn.jsdelivr.net/npm/vue)\nVue-Devtools # 这样，打开开发者工具 (option + command + i || F12)\n可以看到多了一个Vue的Tab:\n","date":"January 24 2018","permalink":"/posts/2018/vue-devtools/","section":"碎语闲言","summary":"\u003cp\u003e最近开始学习 \u003ca href=\"https://cn.vuejs.org/\"\u003eVue.js\u003c/a\u003e, 一脸懵逼地进入前端世界。\u003c/p\u003e\n\u003cp\u003e不使用 \u003ccode\u003evue-cli\u003c/code\u003e 和 \u003ccode\u003ewebpack\u003c/code\u003e 这些构建工具，使用单个 html 引入 Vue。\u003c/p\u003e","title":"Vue 调试工具 Devtools"},{"content":"速查手册 # *斜体* ~\u0026gt; 斜体\n**粗体** ~\u0026gt; 粗体\n***粗斜体*** ~\u0026gt; 粗斜体\n~~删除线~~ ~\u0026gt; 删除线\n*** ~\u0026gt; 分割线\n# 一级标题\n###### 六级标题\n[超链接](http://fangr.cc/) ~\u0026gt; 超链接\n[超链接][1] [1]:http://fangr.cc ~\u0026gt;\n超链接\n\u0026lt;http://fangr.cc/\u0026gt; ~\u0026gt; http://fangr.cc/\n*/+/- 无序列表 ~\u0026gt;\n无序列表 无序列表 1. 有序列表 ~\u0026gt;\n有序列表 有序列表 \u0026gt;\u0026gt;\u0026gt; 引用 ~\u0026gt;\n多层引用\n多层引用\n![图片alt](图片url \u0026quot;图片title\u0026quot;)\n锚点: [速查手册](#速查手册) -\u0026gt; 速查手册\n整理版 # 原作者: HaoqiangChen, LeaNote\n目录 # 有些编辑器使用`[TOC]`可以直接生成目录, 但原生并不支持。 0. 目录 1. 分级标题 2. 斜体和粗体 3. 超链接\n3.1 行内式 3.2 参考式 3.3 自动链接\n4. 锚点 5. 列表\n5.1 无序列表 5.2 有序列表 5.3 定义型列表 5.4 列表缩进 5.5 包含段落的列表 5.6 包含引用的列表 5.7 包含代码区块的引用 5.8 一个特殊情况\n6. 引用\n6.1 引用的多层嵌套 6.2 引用其它要素\n7. 插入图像\n7.1 行内式 7.2 参考式\n8. 分隔线和预格式化\n8.1 分隔线 8.2 预格式化\n9. 表格 10. 注脚 11. LaTeX公式\n11.1 $表示行内公式 11.2 $$表示整行公式\n12. 流程图 13. 代码\n13.1 行内式 13.2 缩进式多行代码 13.3 包裹多行代码 13.4 HTML原始码\n分级标题 # 第一种写法:\n这是一个一级标题 ============================ 这是一个二级标题 -------------------------------------------------- 第二种写法:\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题字号最大, 依级递减。 显示效果: \u0026lt;!- ignore -\u0026gt;\n斜体和粗体 # 代码:\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号, 被 * 或 _ 包围的字词会被转成用 \u0026lt;em\u0026gt; 标签包围, 用两个 * 或 _ 包起来的话, 则会被转成 \u0026lt;strong\u0026gt;, 例如: *斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~ 但是目前MarkdownPad2和GitHub的Markdown并不支持~~删除线~~这个语法功能, 可以用html的\u0026lt;del\u0026gt;\u0026lt;/del\u0026gt;或\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt;代替。 显示效果:\n这是一段斜体 这是一段粗体 这是一段加粗斜体 这是一段删除线 超链接 # Markdown 支持两种形式的链接语法: 行内式和参考式两种形式, 行内式一般使用较多。\n行内式 # 语法说明:\n[]里写链接文字, ()里写链接地址, ()里面\u0026quot; \u0026ldquo;中的内容可以为链接指定title属性, title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 \u0026ldquo;链接标题\u0026rdquo;)这样的形式。链接地址与链接标题前有一个空格。 代码:\n欢迎来到[Markdown语法篇](https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown) 欢迎来到[Markdown语法篇](https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown \u0026#34;Markdown语法篇\u0026#34;) 显示效果:\n欢迎来到Markdown语法篇\n欢迎来到Markdown语法篇\n参考式 # 参考式超链接一般用在学术论文上面, 或者另一种情况, 如果某一个链接在文章中多处使用, 那么使用引用 的方式创建链接将非常好, 它可以让你对链接进行统一的管理。\n语法说明:\n参考式链接分为两部分, 文中的写法 [链接文字][链接标记], 在文本的任意位置添加[链接标记]:链接地址 \u0026quot;链接标题\u0026quot;, 链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记, 你也可以写成[链接文字][] [链接文字]:链接地址的形式, 见代码的最后一行。\n代码:\n欢迎阅读本[Markdown语法篇][1], 还有这几篇高手总结的也不错:[入门篇][2]、 [简明版][3]、[完整版][4], 我就喜欢把百家汇成[自己一家][]^_^。 [1]:https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown \u0026#34;Markdown语法篇\u0026#34; [2]:https://sspai.com/post/25137 \u0026#34;入门篇\u0026#34; [3]:http://wowubuntu.com/Markdown/index.html \u0026#34;简明版\u0026#34; [4]:http://blog.leanote.com/post/freewalk/Markdown-语法手册 \u0026#34;完整版\u0026#34; [自己一家]:https://github.com/HaoqiangChen/Hq-note/tree/master/Markdown 显示效果:\n欢迎阅读本Markdown语法篇, 还有这几篇高手总结的也不错:入门篇、 简明版、完整版, 我就喜欢把百家汇成自己一家^_^。\n自动链接 # 语法说明: Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱, 只要是用\u0026lt;\u0026gt;包起来,Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样, 例如:\n代码:\n\u0026lt;http://example.com/\u0026gt; \u0026lt;address@example.com\u0026gt; 显示效果:\nhttp://example.com/ address@example.com\n锚点 # 网页中, 锚点其实就是页内超链接, 也就是链接本文档内部的某些元素, 实现当前页面中的跳转。比如我这里写下一个锚点, 点击回到目录, 就能跳转到目录。 在目录中点击这一节, 就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。\n注意:\nMarkdown Extra 只支持在标题后插入锚点, 其它地方无效。 Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转, 所以点来点去发现没有跳转不必惊慌, 但是你发布成笔记或博文后是支持跳转的。 非常遗憾的是, 目前MarkdownPad2和GitHub的Markdown并不支持[TOC]目录和锚点这个功能, 暂时只能用HTML的标签id来使用页内跳转。 语法描述:\n使用[TOC]标记编辑器会把所有标题写到目录大纲中。 在你准备跳转到的指定标题后插入锚点{\\#标记}, 然后在文档的其它地方写上连接到锚点的链接。 直接HTML语法锚点功能。 而说到这个就有一个值得一提的地方了, 就是如何在GitHub上也能实现页面跳转, 原先我用的是HTML的a标签锚点, 并且自己给每个标题套上个span#id, 但是发现在gitbook可以有效果, 但是在GitHub上不行, 后面发现这个原生Markdown会自动帮你处理, 自动转成 HTML 实体, 然后我就去看是怎么转化的, 发现它转化每个标题的同时都会赋予一个ID, 那么我们完全直接拿这个ID来做锚点, 至于怎么拿到这个ID, 这个应该就不用我说了吧, 会点编程都知道, 直接打开chrome或者Firefox等调试工具就可以看到了。 代码:\n## 0. 目录{#index} [TOC] 上面这两种方法原生Markdown都不支持, 但是第一种在gitbook居然有效果, 可惜在GitHub还是没有效果 \u0026lt;span id=\u0026#34;#index\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 跳转到[目录](#目录) 显示效果:\n跳转到目录\n列表 # 无序列表 # 使用 *, +, - 表示无序列表, 三个都显示为实心圆点。\n代码:\n- 无序列表项 一 - 无序列表项 二 - 无序列表项 三 显示效果:\n无序列表项 一 无序列表项 二 无序列表项 三 有序列表 # 有序列表则使用数字接着一个英文句点再加个空格。\n代码:\n1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 显示效果:\n有序列表项 一 有序列表项 二 有序列表项 三 定义型列表 # 语法说明:\n定义型列表由名词和解释组成。一行写上定义, 紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\n代码:\nMarkdown :轻量级文本标记语言, 可以转换成html, pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 :这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 显示效果:\nMarkdown :轻量级文本标记语言, 可以转换成html, pdf等格式(没效果, 可能又是不支持吧)\n代码块 2 这是代码块的定义(没效果, 可能又是不支持吧) 代码块（左侧有八个不可见的空格）\n注:方法一和二在马克飞象编辑器是有效果的, 但是gitbook没有, 可能又是不支持, 至于有没有什么方法可以实现我也不知道- -！\n列表缩进 # 语法说明:\n列表项目标记通常是放在最左边, 但是其实也可以缩进, 最多 3 个空格, 项目标记后面则一定要接着至少一个空格或制表符。\n要让列表看起来更漂亮, 你可以把内容用固定的缩进整理好（显示效果与代码一致）:但是可能又是不支持缘故, gitbook需要每一行末尾空两空格换行才行。\n*轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ *那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 但是如果你懒, 那也行: 代码:\n* 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ * 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 显示效果:\n轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 包含段落的列表 # 语法说明:\n列表项目可以包含多个段落, 每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）:但是可能又是不支持缘故, gitbook需要每一行末尾空两空格换行才行。\n* 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ * 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 如果你每行都有缩进, 看起来会看好很多, 当然, 再次地, 如果你很懒惰, Markdown 也允许:\n代码:\n* 轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！ * 悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 显示效果:\n轻轻的我走了,正如我轻轻的来； 我轻轻的招手,作别西天的云彩。 那河畔的金柳,是夕阳中的新娘； 波光里的艳影,在我的心头荡漾。 软泥上的青荇,油油的在水底招摇； 在康河的柔波里,我甘心做一条水草！ 那榆荫下的一潭,不是清泉,是天上虹； 揉碎在浮藻间,沉淀着彩虹似的梦。 寻梦？撑一支长篙,向青草更青处漫溯； 满载一船星辉,在星辉斑斓里放歌。 但我不能放歌,悄悄是别离的笙箫； 夏虫也为我沉默,沉默是今晚的康桥！\n悄悄的我走了,正如我悄悄的来； 我挥一挥衣袖,不带走一片云彩。 包含引用的列表 # 语法说明:\n如果要在列表项目内放进引用, 那在 \u0026gt; 前面需要缩进:\n代码:\n* 阅读的方法: \u0026gt; 打开书本。 \u0026gt; 打开电灯。 显示效果:\n阅读的方法: 打开书本。 打开电灯。\n包含代码区块的引用 # 语法说明: 如果要放代码区块的话, 该区块就需要缩进两次, 也就是 8 个空格或是 2 个制表符:\n一列表项包含一个列表区块: \u0026lt;代码写在这\u0026gt;\n一个特殊情况 # 在特殊情况下, 项目列表很可能会不小心产生, 像是下面这样的写法:\n1986. What a great season. 会显示成:\nWhat a great season. 换句话说, 也就是在行首出现数字-句点-空白, 要避免这样的状况, 你可以在句点前面加上反斜杠:\n1986\\. What a great season. 会显示成:\n1986. What a great season.\n引用 # 语法说明:\n引用需要在被引用的文本前加上\u0026gt;符号。\n代码:\n\u0026gt; 这是一个有两段文字的引用, \u0026gt; 无意义的占行文字1. \u0026gt; 无意义的占行文字2. \u0026gt; \u0026gt; 无意义的占行文字3. \u0026gt; 无意义的占行文字4. 显示效果:\n这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2.\n无意义的占行文字3. 无意义的占行文字4.\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt; :\n代码:\n\u0026gt; 这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2. \u0026gt; 无意义的占行文字3. 无意义的占行文字4. 显示效果:\n这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2.\n无意义的占行文字3. 无意义的占行文字4.\n引用的多层嵌套 # 区块引用可以嵌套（例如:引用内的引用）, 只要根据层次加上不同数量的 \u0026gt; :\n代码:\n\u0026gt;\u0026gt;\u0026gt; 请问 Markdwon 怎么用？ - 小白 \u0026gt;\u0026gt; 自己看教程！ - 愤青 \u0026gt; 教程在哪？ - 小白 显示效果:\n请问 Markdwon 怎么用？ - 小白\n自己看教程！ - 愤青\n教程在哪？ - 小白\n引用其它要素 # 引用的区块内也可以使用其他的 Markdown 语法, 包括标题、列表、代码区块等:\n代码:\n\u0026gt; 1. 这是第一行列表项。 \u0026gt; 2. 这是第二行列表项。 \u0026gt; \u0026gt; 给出一些例子代码: \u0026gt; \u0026gt; return shell_exec(\u0026#34;echo $input | $Markdown_script\u0026#34;); 显示效果:\n这是第一行列表项。 这是第二行列表项。 给出一些例子代码:\nreturn shell_exec(\u0026ldquo;echo $input | $Markdown_script\u0026rdquo;);\n插入图像 # 图片的创建方式与超链接相似, 而且和超链接一样也有两种写法, 行内式和参考式写法。\n语法中图片Alt的意思是如果图片因为某些原因不能显示, 就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样, 表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的, 可以省略, 但建议写上。\n行内式 # 语法说明:![图片Alt](图片地址 \u0026ldquo;图片Title\u0026rdquo;)\n代码:\n美丽花儿: ![美丽花儿](https://raw.githubusercontent.com/HaoqiangChen/Hq-note/master/asset/Markdown/img/flower.jpg \u0026#34;美丽花儿\u0026#34;) 显示效果:\n美丽花儿: 美丽花儿 参考式 # 语法说明:\n在文档要插入图片的地方写![图片Alt][标记]\n在文档的最后写上[标记]:图片地址 \u0026ldquo;Title\u0026rdquo;\n代码:\n美丽花儿: ![美丽花儿][flower] [flower]:https://raw.githubusercontent.com/HaoqiangChen/Hq-note/master/asset/Markdown/img/flower.jpg \u0026#34;美丽花儿\u0026#34; 显示效果:\n美丽花儿: 美丽花儿 分隔线和预格式化 # 分隔线 # 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线, 行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线:\n代码:\n* * * *** ***** - - - --------------------------------------- 显示效果都一样:\n预格式化 # 用```+中间你所想注释的内容或代码+```包裹:预格式化, 可用于Markdown里面的注释, 解释说明什么的 Markdown的预格式化 相当于HTML的\u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt;预格式化, 不过Markdown这个除了预格式化之外还会添加了一个背景色与其他内容区分开, 相当好用。\n表格 # 语法说明:\n不管是哪种方式, 第一行为表头, 第二行分隔表头和主体部分, 第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐, 在-符号右边加上冒号: 就会右对齐。 代码:\n简单方式写表格:\n学号|姓名|分数 -|-|- 小明|男|75 小红|女|79 小陆|男|92 原生方式写表格:\n|学号|姓名|分数| |-|-|-| |小明|男|75| |小红|女|79| |小陆|男|92| 为表格第二列指定方向:\n产品|价格 -|-: Leanote 高级账号|60元/年 Leanote 超级账号|120元/年 显示效果: 简单方式写表格:\n学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 原生方式写表格:\n学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 为表格第二列指定方向:\n产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 注脚 # 语法说明:\n在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注, 脚注前必须有对应的脚注名字。\n注意:经测试注脚与注脚之间必须空一行, 不然会失效。成功后会发现, 即使你没有把注脚写在文末, 经Markdown转换后, 也会自动归类到文章的最后。\n代码:\n使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台, 支持Markdown和笔记直接发为博文 **注:脚注自动被搬运到最后面, 请到文章末尾查看, 并且脚注后方的链接可以直接跳转回到加注的地方。** 显示效果:\n注:因为Markdown是没有一个所谓的规范的(Markdown官网都不支持这么做), 因此导致gitbook没有目录[TOC]和注脚功能, 所以某些特性功能需要写作工具自己支持才可以, 像马克飞象和Leanote就可以。\nLaTeX公式 # $表示行内公式 # 代码:\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 显示效果：\n质能守恒方程可以用一个很简洁的方程式 E=mc2来表达。\n注: 原生不支持LaTeX公式。可以用codecogs的云服务, 在线LaTeX数学公式编辑工具, api+一大串LaTex, 比如: 当然这么强大的在线公式编辑器肯定提供了在线GUI给大家, 打开网址:\nhttp://www.codecogs.com/latex/eqneditor.php,\n你就可以随心所欲的编辑公式了, 它同样想Mathtype一样提供了不少模板, 直接编辑, 也很方便。编辑完成之后, 页面上就会实时得到编辑的Latex格式公式图片。\n或者:http://latex.codecogs.com/\n这个网址的使用方法:![](http://latex.codecogs.com/gif.latex?\\frac{1}{1+sin(x)})\n-\u0026gt;\n所以, 上面的例子可以修改为\n质能守恒方程可以用一个很简洁的方程式 ![](http://latex.codecogs.com/gif.latex?E=mc^2) 来表达。\n显示效果:\n质能守恒方程可以用一个很简洁的方程式 来表达。\n$$表示整行公式 # 代码:\n$$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$ 同上, 原生不支持, 使用上面的网站即可。\n显示效果:\n\\sum_{i=1}^n a_i=0 \\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k} 访问 MathJax 参考更多使用方法。\n流程图 # 代码:\nflow st=\u0026gt;start: Start:\u0026gt;https://www.zybuluo.com io=\u0026gt;inputoutput: verification op=\u0026gt;operation: Your Operation cond=\u0026gt;condition: Yes or No? sub=\u0026gt;subroutine: Your Subroutine e=\u0026gt;end st-\u0026gt;io-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;sub-\u0026gt;io 显示效果:\nCreated with Raphaël 2.1.0https://www.zybuluo.comStarthttps://www.zybuluo.comverificationYour OperationYes or No?EndYour Subroutineyesno 从上面的例子可以看出原生对流程图同样也是不支持, 所以只能采取迂回取巧方法了, 就是用一些支持流程图的编辑器先画出来, 然后截图放到这个不支持的页面上\n更多语法参考:流程图语法参考\n代码 # 对于程序员来说这个功能是必不可少的, 插入程序代码的方式有两种, 一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。\n语法说明:\n插入行内代码, 即插入一个单词或者一句代码的情况, 使用`code`这样的形式插入。 插入多行代码, 可以使用缩进或者“` code “`,具体看示例。 注意: 缩进式插入前方必须有空行\n行内式 # 代码:\nC语言里的函数 `scanf()` 怎么使用？ 显示效果:\nC语言里的函数 scanf() 怎么使用？\n缩进式多行代码 # 缩进 4 个空格或是 1 个制表符\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n代码:\n# 空一行 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } 显示效果:\n#include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026quot;Hello world\\n\u0026quot;); } 包裹多行代码 # 代码:\n#include \u0026lt;stdio.h\u0026gt;; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } 显示效果:\n#include \u0026lt;stdio.h\u0026gt;; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } HTML原始码 # 在代码区块里面,\u0026amp; 、 \u0026lt; 和 \u0026gt; 会自动转成 HTML 实体, 这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码, 只需要复制贴上, 剩下的 Markdown 都会帮你处理, 例如:\nTip: 值得注意的是，Markdown对空格、空行很敏感，在解析成HTML时会自动添加一些\u0026lt;br\u0026gt;标签导致出现大段空白，所以HTML块要尽量紧凑。\n代码:\n第一个例子:\n\u0026lt;div\u0026gt;\u0026amp;copy; 2007 Foo Corporation\u0026lt;/div\u0026gt; 第二个例子:\n\u0026lt;table\u0026gt;\u0026lt;tbody\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;值班人员\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;星期一\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;星期二\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;星期三\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;李强\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;张明\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;王平\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; 显示效果:\n第一个例子:\n\u0026copy; 2007 Foo Corporation 第二个例子:\n值班人员星期一星期二星期三李强张明王平 ","date":"October 12 2017","permalink":"/posts/2017/markdown-tutorial/","section":"碎语闲言","summary":"速查手册 # *斜体* ~\u0026gt; 斜体","title":"Markdown 完全手册"},{"content":"关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是:\n$ npm install -g hexo $ hexo init $ hexo generate (hexo g) $ hexo server (hexo s) $ hexo new [name] - 新建文章 $ hexo new page [name] - 新建页面 正常情况下，这样就会启动本地的服务:http://localhost:4000，但现实总是残酷的，\n由于国内XXX的网络环境，总会遇到各种各样的问题，\n下面总结一下本博客迁移到Hexo过程中遇到的一些问题。\nNPM 源 # node的包管理工具npm，默认使用国外的源，访问比较慢，建议换成国内源，比如 淘宝npm:\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用cnpm代替npm进行模块安装了:\n$ cnpm install [name] 或者，使用nrm (npm的源管理工具):\n$ npm install nrm $ nrm ls * npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ $ nrm use taobao $ nrm test taobao Hexo 安装 # hexo-server # hexo server执行失败:\nERROR Plugin load filed: hexo-server 需要单独安装hexo-server:\n$ npm install hexo-server --save node-sass # $ npm install node-sass --save 如果出现如下情况:\n$ node scripts/install.js Cannot download \u0026#34;https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node\u0026#34;: read ECONNRESET Hint: If github.com is not accessible in your location try setting a proxy via HTTP_PROXY, e.g. export HTTP_PROXY=http://example.com:1234 or configure npm proxy via npm config set proxy http://example.com:8080 $ node-sass@4.5.3 postinstall /private/tmp/node_modules/node-sass $ node scripts/build.js 说明 github 访问比较慢，两种方法：\n修改 host: http://tool.chinaz.com/dns?type=1\u0026amp;host=github.com\u0026amp;ip=\n找一个TTL比较小的host，如:\n192.30.255.112 github.com 直接去github下载 https://github.com/sass/node-sass/releases/download/v4.5.3/darwin-x64-51_binding.node\n然后将该文件放到目录:~/.npm/node-sass/4.5.3/darwin-x64-51_binding.node\n再执行安装命令\n$ npm intall node-sass --save hexo-renderer-scss # 有些主题需要安装hexo-renderer-scss:\n$ npm install hexo-renderer-scss --save 会出现错误:\nERROR Plugin load failed: hexo-renderer-scss Error: ENOENT: no such file or directory, scandir \u0026#39;xxx/node_modules/node-sass/vendor\u0026#39; at Object.fs.readdirSync (fs.js:914:18) ... 提示这个目录找不到，那我们手动创建好了:\n$ mkdir xxx/node_modules/node-sass/vendor $ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor 接下来还是报错:\nERROR Plugin load failed: hexo-renderer-scss Error: Missing binding xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 7.x Found bindings for the following environments: 到这个目录下，把刚刚下载的darwin-x64-51_binding.node重命名复制进去好了:\n$ mkdir xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/ $ cp darwin-x64-51_binding.node xxx/node_modules/hexo-renderer-scss/node_modules/node-sass/vendor/darwin-x64-51/binding.node 页面空白 # 有时执行hexo s后显示服务启动，但页面打开空白，显示Cannot GET /，这种情况有很多原因，\n可以尝试:\n$ npm install $ hexo cl $ hexo g $ hexo s 如果还有问题，查看一下npm插件是否安装正常:\n$ npm ls --depth 0 hexo-site@0.0.0 xxx ├── hexo@3.3.9 ├── hexo-deployer-git@0.3.1 ├── hexo-generator-archive@0.1.4 ├── hexo-generator-baidu-sitemap@0.1.2 ├── hexo-generator-category@0.1.3 ├── hexo-generator-feed@1.2.2 ├── hexo-generator-index@0.2.1 ├── hexo-generator-sitemap@1.2.0 ├── hexo-generator-tag@0.2.0 ├── hexo-renderer-ejs@0.3.1 ├── hexo-renderer-marked@0.3.0 ├── hexo-renderer-scss@1.0.3 ├── hexo-renderer-stylus@0.3.3 ├── hexo-server@0.2.2 └── node-sass@4.5.3 npm ERR! invalid: hexo-generator-baidu-sitemap@0.0.8 xxx/node_modules/hexo-generator-baidu-sitemap/node_modules/hexo-generator-baidu-sitemap 可以看到hexo-generator-baidu-sitemap这个插件安装失败了，尝试重新安装或者删除它:\n$ npm install hexo-generator-baidu-sitemap --save $ npm uninstall hexo-generator-baidu-sitemap 或者在package.json中将它删除掉。\n","date":"September 27 2017","permalink":"/posts/2017/hexo-workflow/","section":"碎语闲言","summary":"\u003cp\u003e关于 Hexo 如何使用，网上已经有很多教程了，不再赘述。涉及的几个相关命令也就是:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ npm install -g hexo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo init\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo generate \u003cspan class=\"o\"\u003e(\u003c/span\u003ehexo g\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo server \u003cspan class=\"o\"\u003e(\u003c/span\u003ehexo s\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo new \u003cspan class=\"o\"\u003e[\u003c/span\u003ename\u003cspan class=\"o\"\u003e]\u003c/span\u003e - 新建文章\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ hexo new page \u003cspan class=\"o\"\u003e[\u003c/span\u003ename\u003cspan class=\"o\"\u003e]\u003c/span\u003e - 新建页面\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"使用 Hexo 遇到的一些问题"},{"content":" 来自一个神奇的域名: http://fuckingblocksyntax.com/\n使用方法 # 局部变量 # returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; 例如：\ndouble (^multiply)(double, double) = ^double(double a, double b) { return a * b; }; // 其中返回值可以省略 double (^multiply)(double, double) = ^(double a, double b) { return a * b; }; // 如果参数为空，可以继续省略 void (^voidBlock)(void) = ^{ }; 属性 property # @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); 例如：\n@property (nonatomic, copy) double (^multiply)(double, double); @property (nonatomic, copy) void (^voidBlock)(void); 方法参数 # - (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; 例如：\n- (void)someMethodCallBlock:(double (^_Nonnull)(double, double))multiply { } 这里 _Nonnull 修饰的是 block 本身，也就是传一个 nil 的 block，会有 warning\nNull passed to a callee that requires a non-null argument\n参数调用 # [someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; 例如：\n[self someMethodCallBlock:^(double a, double b) { return a * b; }]; 这里的返回值也可以忽略。\ntypedef 定义 # typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; 例如：\ntypedef double (^Multiplier)(double, double); @property (nonatomic, copy) Multiplier multiply; Hint # block 在 ARC 下是否声明为 copy 属性 It is still a good idea to declare block properties as having copy semantics since a block assigned to a strong property will in fact be copied.\nApple recommends this as well:\nYou should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior.\n","date":"May 31 2017","permalink":"/posts/2017/how-to-declare-block-in-oc/","section":"碎语闲言","summary":"来自一个神奇的域名: http://fuckingblocksyntax.","title":"在 ObjC 中如何定义 Block"},{"content":"最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。\n我自己在虚拟机中试了下，确实这样！\n在用户机器中获取了 DUMP，只看到有几个线程一直在跑，调用堆栈中也看不到太多信息（主要是没有线程 CPU 占用信息），一时没有方法。\n今天突然想到 VS2013，新版本增加了一些功能，貌似有性能分析相关的。\n找了一下，果然在调试菜单下发现了性能与诊断：\n选择 CPU使用率，就开始分析啦！\n很快就给出了分析结果：\n哈哈！瞬间定位 CPU 占用元凶，原来是一个后台线程一直在跑（空转），设计不合理。这个线程最早设计成自驱动的，找到原因就好办了，改成被驱动式就行了！\n","date":"August 8 2016","permalink":"/posts/2016/detect-cpu-usage-with-vs2013/","section":"碎语闲言","summary":"\u003cp\u003e最近开发的一个程序，用户反馈 CPU 占用非常高，基本把一个内核占用满了。\u003c/p\u003e","title":"VS2013 检测 CPU 占用率"},{"content":" 安装 Ruby 和 Ruby DevKit\nRuby 2.2.4 Ruby DevKit 切换到安装目录：\n$ cd C:\\RubyDevKit $ ruby dk.rb init $ ruby dk.rb install 安装Jekyll\n$ gem install jekyll $ gem install wdm 切换到博客目录运行\n$ jekyll build [--watch/-w] $ jekyll serve [--watch/-w] 用浏览器打开http://127.0.0.1:4000，即可看到效果，而且在修改文件的同时刷新页面即可实时更新。\n可以通过\u0026ndash;port 888指定端口号，更多命令行参数参考[官方手册]1\n安装有问题，可以参考更多文档：\n[Running Jekyll on Windows]2\n[Jekyll Windows]3\n[Setup Jekyll on Windows]4\nhttp://jekyll.bootcss.com/docs/configuration/ \u0026ldquo;配置\u0026rdquo;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttp://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttp://jekyll-windows.juthilo.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttp://yizeng.me/2013/05/10/setup-jekyll-on-windows/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"June 5 2016","permalink":"/posts/2016/install-jekyll-locally/","section":"碎语闲言","summary":"\u003cp\u003e\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://ryder-1252249141.cos.ap-shanghai.myqcloud.com/uPic/2022-04-07-jekyll.jpg\" alt=\"\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e安装 Ruby 和 Ruby DevKit\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-2.2.4.exe\"\u003eRuby 2.2.4\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://dl.bintray.com/oneclick/rubyinstaller/DevKit-mingw64-32-4.7.2-20130224-1151-sfx.exe\"\u003eRuby DevKit\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Jekyll 本地安装"}]